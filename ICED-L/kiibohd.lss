
kiibohd.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000a29c  00002000  00002000  00002000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .usbdescriptortable 00000120  1fff8000  1fff8000  00018000  2**2
                  ALLOC
  2 .usbbuffers   00000870  1fff8120  1fff8120  00018000  2**0
                  ALLOC
  3 .data         00000914  1fff8990  0000c29c  00010990  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  4 .bss          000013c4  1fff92a4  0000cbb0  000112a4  2**2
                  ALLOC
  5 .debug_info   00010c44  00000000  00000000  000112a4  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00002954  00000000  00000000  00021ee8  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_aranges 000007f0  00000000  00000000  0002483c  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_ranges 00000bc0  00000000  00000000  0002502c  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_macro  0000979d  00000000  00000000  00025bec  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_line   000049ba  00000000  00000000  0002f389  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    00024489  00000000  00000000  00033d43  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .comment      0000001f  00000000  00000000  000581cc  2**0
                  CONTENTS, READONLY
 13 .ARM.attributes 00000033  00000000  00000000  000581eb  2**0
                  CONTENTS, READONLY
 14 .debug_frame  00001554  00000000  00000000  00058220  2**2
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_loc    000070f3  00000000  00000000  00059774  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00002000 <gVectors>:
    2000:	00 80 00 20 bd 21 00 00 85 24 00 00 91 24 00 00     ... .!...$...$..
    2010:	c5 24 00 00 05 25 00 00 45 25 00 00 3d 24 00 00     .$...%..E%..=$..
    2020:	3d 24 00 00 3d 24 00 00 3d 24 00 00 7d 24 00 00     =$..=$..=$..}$..
    2030:	7d 24 00 00 3d 24 00 00 7d 24 00 00 2d 24 00 00     }$..=$..}$..-$..
    2040:	7d 24 00 00 7d 24 00 00 7d 24 00 00 7d 24 00 00     }$..}$..}$..}$..
    2050:	7d 24 00 00 7d 24 00 00 7d 24 00 00 7d 24 00 00     }$..}$..}$..}$..
    2060:	7d 24 00 00 7d 24 00 00 7d 24 00 00 7d 24 00 00     }$..}$..}$..}$..
    2070:	7d 24 00 00 7d 24 00 00 7d 24 00 00 7d 24 00 00     }$..}$..}$..}$..
    2080:	7d 24 00 00 7d 24 00 00 7d 24 00 00 7d 24 00 00     }$..}$..}$..}$..
    2090:	7d 24 00 00 7d 24 00 00 7d 24 00 00 7d 24 00 00     }$..}$..}$..}$..
    20a0:	11 27 00 00 7d 24 00 00 7d 24 00 00 7d 24 00 00     .'..}$..}$..}$..
    20b0:	7d 24 00 00 7d 24 00 00 7d 24 00 00 7d 24 00 00     }$..}$..}$..}$..
    20c0:	7d 24 00 00 7d 24 00 00 7d 24 00 00 7d 24 00 00     }$..}$..}$..}$..
    20d0:	7d 24 00 00 7d 24 00 00 7d 24 00 00 7d 24 00 00     }$..}$..}$..}$..
    20e0:	7d 24 00 00 7d 24 00 00 7d 24 00 00 7d 24 00 00     }$..}$..}$..}$..
    20f0:	7d 24 00 00 7d 24 00 00 7d 24 00 00 7d 24 00 00     }$..}$..}$..}$..
    2100:	7d 24 00 00 7d 24 00 00 7d 24 00 00 7d 24 00 00     }$..}$..}$..}$..
    2110:	7d 24 00 00 7d 24 00 00 7d 24 00 00 7d 24 00 00     }$..}$..}$..}$..
    2120:	7d 24 00 00 7d 24 00 00 7d 24 00 00 7d 24 00 00     }$..}$..}$..}$..
    2130:	7d 24 00 00 7d 24 00 00 7d 24 00 00 7d 24 00 00     }$..}$..}$..}$..
    2140:	7d 24 00 00 7d 24 00 00 7d 24 00 00 7d 24 00 00     }$..}$..}$..}$..
    2150:	7d 24 00 00 7d 24 00 00 7d 24 00 00 7d 24 00 00     }$..}$..}$..}$..
    2160:	7d 24 00 00 e9 63 00 00 7d 24 00 00 7d 24 00 00     }$...c..}$..}$..
    2170:	7d 24 00 00 7d 24 00 00 7d 24 00 00 7d 24 00 00     }$..}$..}$..}$..
    2180:	7d 24 00 00 7d 24 00 00 7d 24 00 00 7d 24 00 00     }$..}$..}$..}$..
    2190:	7d 24 00 00 7d 24 00 00 7d 24 00 00 7d 24 00 00     }$..}$..}$..}$..
    21a0:	7d 24 00 00 7d 24 00 00 7d 24 00 00 7d 24 00 00     }$..}$..}$..}$..
    21b0:	7d 24 00 00 7d 24 00 00 7d 24 00 00                 }$..}$..}$..

000021bc <ResetHandler>:

// ----- Chip Entry Point -----

__attribute__ ((section(".startup")))
void ResetHandler()
{
    21bc:	b508      	push	{r3, lr}
		SCB_VTOR = addr; // relocate vector table
		jump_to_app( addr );
	}
#endif
	// Disable Watchdog
	WDOG_UNLOCK = WDOG_UNLOCK_SEQ1;
    21be:	4b3b      	ldr	r3, [pc, #236]	; (22ac <ResetHandler+0xf0>)
    21c0:	f24c 5220 	movw	r2, #50464	; 0xc520
    21c4:	801a      	strh	r2, [r3, #0]
	WDOG_UNLOCK = WDOG_UNLOCK_SEQ2;
    21c6:	f64d 1228 	movw	r2, #55592	; 0xd928
    21ca:	801a      	strh	r2, [r3, #0]
	WDOG_STCTRLH = WDOG_STCTRLH_ALLOWUPDATE;
    21cc:	2210      	movs	r2, #16
    21ce:	f823 2c0e 	strh.w	r2, [r3, #-14]

	uint32_t *src = (uint32_t*)&_etext;
	uint32_t *dest = (uint32_t*)&_sdata;

	// Enable clocks to always-used peripherals
	SIM_SCGC5 = 0x00043F82; // Clocks active to all GPIO
    21d2:	4b37      	ldr	r3, [pc, #220]	; (22b0 <ResetHandler+0xf4>)
    21d4:	4a37      	ldr	r2, [pc, #220]	; (22b4 <ResetHandler+0xf8>)
    21d6:	601a      	str	r2, [r3, #0]
	SIM_SCGC6 = SIM_SCGC6_FTM0 | SIM_SCGC6_FTM1 | SIM_SCGC6_ADC0 | SIM_SCGC6_FTFL;
    21d8:	4a37      	ldr	r2, [pc, #220]	; (22b8 <ResetHandler+0xfc>)
    21da:	605a      	str	r2, [r3, #4]
#if defined(_mk20dx128_)
	SIM_SCGC6 |= SIM_SCGC6_RTC;
#elif defined(_mk20dx256_) || defined(_mk20dx256vlh7_)
	SIM_SCGC3 = SIM_SCGC3_ADC1 | SIM_SCGC3_FTM2;
    21dc:	4a37      	ldr	r2, [pc, #220]	; (22bc <ResetHandler+0x100>)
    21de:	f04f 6110 	mov.w	r1, #150994944	; 0x9000000
    21e2:	6011      	str	r1, [r2, #0]
	SIM_SCGC6 |= SIM_SCGC6_RTC;
    21e4:	685a      	ldr	r2, [r3, #4]
    21e6:	f042 5200 	orr.w	r2, r2, #536870912	; 0x20000000
    21ea:	605a      	str	r2, [r3, #4]
		RTC_CR = RTC_CR_SC16P | RTC_CR_SC4P | RTC_CR_OSCE;
	}
#endif

	// release I/O pins hold, if we woke up from VLLS mode
	if ( PMC_REGSC & PMC_REGSC_ACKISO )
    21ec:	4b34      	ldr	r3, [pc, #208]	; (22c0 <ResetHandler+0x104>)
    21ee:	781a      	ldrb	r2, [r3, #0]
    21f0:	0711      	lsls	r1, r2, #28
    21f2:	d503      	bpl.n	21fc <ResetHandler+0x40>
	{
		PMC_REGSC |= PMC_REGSC_ACKISO;
    21f4:	781a      	ldrb	r2, [r3, #0]
    21f6:	f042 0208 	orr.w	r2, r2, #8
    21fa:	701a      	strb	r2, [r3, #0]

// ----- Chip Entry Point -----

__attribute__ ((section(".startup")))
void ResetHandler()
{
    21fc:	2300      	movs	r3, #0
    21fe:	4a31      	ldr	r2, [pc, #196]	; (22c4 <ResetHandler+0x108>)
	{
		PMC_REGSC |= PMC_REGSC_ACKISO;
	}

	// Prepare RAM
	while ( dest < (uint32_t*)&_edata ) *dest++ = *src++;
    2200:	4931      	ldr	r1, [pc, #196]	; (22c8 <ResetHandler+0x10c>)
    2202:	1898      	adds	r0, r3, r2
    2204:	4288      	cmp	r0, r1
    2206:	d204      	bcs.n	2212 <ResetHandler+0x56>
    2208:	4930      	ldr	r1, [pc, #192]	; (22cc <ResetHandler+0x110>)
    220a:	5859      	ldr	r1, [r3, r1]
    220c:	5099      	str	r1, [r3, r2]
    220e:	3304      	adds	r3, #4
    2210:	e7f5      	b.n	21fe <ResetHandler+0x42>
    2212:	4b2f      	ldr	r3, [pc, #188]	; (22d0 <ResetHandler+0x114>)
	dest = (uint32_t*)&_sbss;
	while ( dest < (uint32_t*)&_ebss ) *dest++ = 0;
    2214:	4a2f      	ldr	r2, [pc, #188]	; (22d4 <ResetHandler+0x118>)
    2216:	4293      	cmp	r3, r2
    2218:	d203      	bcs.n	2222 <ResetHandler+0x66>
    221a:	2200      	movs	r2, #0
    221c:	f843 2b04 	str.w	r2, [r3], #4
    2220:	e7f8      	b.n	2214 <ResetHandler+0x58>
    2222:	4b2d      	ldr	r3, [pc, #180]	; (22d8 <ResetHandler+0x11c>)
#endif

	// default all interrupts to medium priority level
	for ( unsigned int i = 0; i < NVIC_NUM_INTERRUPTS; i++ )
	{
		NVIC_SET_PRIORITY( i, 128 );
    2224:	2280      	movs	r2, #128	; 0x80
    2226:	f803 2b01 	strb.w	r2, [r3], #1
	// use vector table in flash
	SCB_VTOR = 0;
#endif

	// default all interrupts to medium priority level
	for ( unsigned int i = 0; i < NVIC_NUM_INTERRUPTS; i++ )
    222a:	4a2c      	ldr	r2, [pc, #176]	; (22dc <ResetHandler+0x120>)
    222c:	4293      	cmp	r3, r2
    222e:	d1f9      	bne.n	2224 <ResetHandler+0x68>
		NVIC_SET_PRIORITY( i, 128 );
	}

	// start in FEI mode
	// enable capacitors for crystal
	OSC0_CR = OSC_SC8P | OSC_SC2P;
    2230:	4b2b      	ldr	r3, [pc, #172]	; (22e0 <ResetHandler+0x124>)
    2232:	220a      	movs	r2, #10
    2234:	701a      	strb	r2, [r3, #0]

	// enable osc, 8-32 MHz range, low power mode
	MCG_C2 = MCG_C2_RANGE0( 2 ) | MCG_C2_EREFS;
    2236:	4b2b      	ldr	r3, [pc, #172]	; (22e4 <ResetHandler+0x128>)
    2238:	2224      	movs	r2, #36	; 0x24
    223a:	701a      	strb	r2, [r3, #0]

	// switch to crystal as clock source, FLL input = 16 MHz / 512
	MCG_C1 =  MCG_C1_CLKS( 2 ) | MCG_C1_FRDIV( 4 );
    223c:	22a0      	movs	r2, #160	; 0xa0
    223e:	f803 2c01 	strb.w	r2, [r3, #-1]

	// wait for crystal oscillator to begin
	while ( (MCG_S & MCG_S_OSCINIT0) == 0 );
    2242:	4b29      	ldr	r3, [pc, #164]	; (22e8 <ResetHandler+0x12c>)
    2244:	781a      	ldrb	r2, [r3, #0]
    2246:	0792      	lsls	r2, r2, #30
    2248:	d5fb      	bpl.n	2242 <ResetHandler+0x86>

	// wait for FLL to use oscillator
	while ( (MCG_S & MCG_S_IREFST) != 0 );
    224a:	781a      	ldrb	r2, [r3, #0]
    224c:	06d0      	lsls	r0, r2, #27
    224e:	d4fc      	bmi.n	224a <ResetHandler+0x8e>

	// wait for MCGOUT to use oscillator
	while ( (MCG_S & MCG_S_CLKST_MASK) != MCG_S_CLKST( 2 ) );
    2250:	781a      	ldrb	r2, [r3, #0]
    2252:	f002 020c 	and.w	r2, r2, #12
    2256:	2a08      	cmp	r2, #8
    2258:	d1fa      	bne.n	2250 <ResetHandler+0x94>

	// now we're in FBE mode
#if F_CPU == 72000000
	// config PLL input for 16 MHz Crystal / 8 = 2 MHz
	MCG_C5 = MCG_C5_PRDIV0( 7 );
    225a:	4b24      	ldr	r3, [pc, #144]	; (22ec <ResetHandler+0x130>)
    225c:	2207      	movs	r2, #7
    225e:	701a      	strb	r2, [r3, #0]
	MCG_C5 = MCG_C5_PRDIV0( 3 );
#endif

#if F_CPU == 72000000
	// config PLL for 72 MHz output (36 * 2 MHz Ext PLL)
	MCG_C6 = MCG_C6_PLLS | MCG_C6_VDIV0( 12 );
    2260:	224c      	movs	r2, #76	; 0x4c
    2262:	705a      	strb	r2, [r3, #1]
	// config PLL for 96 MHz output
	MCG_C6 = MCG_C6_PLLS | MCG_C6_VDIV0( 0 );
#endif

	// wait for PLL to start using xtal as its input
	while ( !(MCG_S & MCG_S_PLLST) );
    2264:	4b20      	ldr	r3, [pc, #128]	; (22e8 <ResetHandler+0x12c>)
    2266:	781a      	ldrb	r2, [r3, #0]
    2268:	0691      	lsls	r1, r2, #26
    226a:	d5fb      	bpl.n	2264 <ResetHandler+0xa8>

	// wait for PLL to lock
	while ( !(MCG_S & MCG_S_LOCK0) );
    226c:	781a      	ldrb	r2, [r3, #0]
    226e:	0652      	lsls	r2, r2, #25
    2270:	d5fc      	bpl.n	226c <ResetHandler+0xb0>
#if F_CPU == 96000000
	// config divisors: 96 MHz core, 48 MHz bus, 24 MHz flash
	SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIV1( 0 ) | SIM_CLKDIV1_OUTDIV2( 1 ) | SIM_CLKDIV1_OUTDIV4( 3 );
#elif F_CPU == 72000000
	// config divisors: 72 MHz core, 36 MHz bus, 24 MHz flash
	SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIV1( 0 ) | SIM_CLKDIV1_OUTDIV2( 1 ) | SIM_CLKDIV1_OUTDIV4( 2 );
    2272:	4b1f      	ldr	r3, [pc, #124]	; (22f0 <ResetHandler+0x134>)
    2274:	f04f 7281 	mov.w	r2, #16908288	; 0x1020000
    2278:	601a      	str	r2, [r3, #0]
	SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIV1( 3 ) | SIM_CLKDIV1_OUTDIV2( 3 ) | SIM_CLKDIV1_OUTDIV4( 3 );
#else
#error "Error, F_CPU must be 96000000, 72000000, 48000000, or 24000000"
#endif
	// switch to PLL as clock source, FLL input = 16 MHz / 512
	MCG_C1 = MCG_C1_CLKS( 0 ) | MCG_C1_FRDIV( 4 );
    227a:	4b1e      	ldr	r3, [pc, #120]	; (22f4 <ResetHandler+0x138>)
    227c:	2220      	movs	r2, #32
    227e:	701a      	strb	r2, [r3, #0]

	// wait for PLL clock to be used
	while ( (MCG_S & MCG_S_CLKST_MASK) != MCG_S_CLKST( 3 ) );
    2280:	4b19      	ldr	r3, [pc, #100]	; (22e8 <ResetHandler+0x12c>)
    2282:	781b      	ldrb	r3, [r3, #0]
    2284:	f003 030c 	and.w	r3, r3, #12
    2288:	2b0c      	cmp	r3, #12
    228a:	d1f9      	bne.n	2280 <ResetHandler+0xc4>

	// now we're in PEE mode
#if F_CPU == 72000000
	// configure USB for 48 MHz clock
	SIM_CLKDIV2 = SIM_CLKDIV2_USBDIV( 2 ) | SIM_CLKDIV2_USBFRAC; // USB = 72 MHz PLL / 1.5
    228c:	4b1a      	ldr	r3, [pc, #104]	; (22f8 <ResetHandler+0x13c>)
    228e:	2205      	movs	r2, #5
    2290:	601a      	str	r2, [r3, #0]
	// configure USB for 48 MHz clock
	SIM_CLKDIV2 = SIM_CLKDIV2_USBDIV( 1 ); // USB = 96 MHz PLL / 2
#endif

	// USB uses PLL clock, trace is CPU clock, CLKOUT=OSCERCLK0
	SIM_SOPT2 = SIM_SOPT2_USBSRC | SIM_SOPT2_PLLFLLSEL | SIM_SOPT2_TRACECLKSEL | SIM_SOPT2_CLKOUTSEL( 6 );
    2292:	4a1a      	ldr	r2, [pc, #104]	; (22fc <ResetHandler+0x140>)
    2294:	f843 2c44 	str.w	r2, [r3, #-68]

#endif

#if !defined(_bootloader_)
	// Initialize the SysTick counter
	SYST_RVR = (F_CPU / 1000) - 1;
    2298:	4b19      	ldr	r3, [pc, #100]	; (2300 <ResetHandler+0x144>)
    229a:	4a1a      	ldr	r2, [pc, #104]	; (2304 <ResetHandler+0x148>)
    229c:	601a      	str	r2, [r3, #0]
	SYST_CSR = SYST_CSR_CLKSOURCE | SYST_CSR_TICKINT | SYST_CSR_ENABLE;
    229e:	2207      	movs	r2, #7
    22a0:	f843 2c04 	str.w	r2, [r3, #-4]

	__enable_irq();
    22a4:	b662      	cpsie	i
#else
	// Disable Watchdog for bootloader
	WDOG_STCTRLH &= ~WDOG_STCTRLH_WDOGEN;
#endif

	main();
    22a6:	f000 f8ab 	bl	2400 <main>
    22aa:	e7fe      	b.n	22aa <ResetHandler+0xee>
    22ac:	4005200e 	.word	0x4005200e
    22b0:	40048038 	.word	0x40048038
    22b4:	00043f82 	.word	0x00043f82
    22b8:	0b000001 	.word	0x0b000001
    22bc:	40048030 	.word	0x40048030
    22c0:	4007d002 	.word	0x4007d002
    22c4:	1fff8990 	.word	0x1fff8990
    22c8:	1fff92a4 	.word	0x1fff92a4
    22cc:	0000c29c 	.word	0x0000c29c
    22d0:	1fff92a4 	.word	0x1fff92a4
    22d4:	1fffa668 	.word	0x1fffa668
    22d8:	e000e400 	.word	0xe000e400
    22dc:	e000e45f 	.word	0xe000e45f
    22e0:	40065000 	.word	0x40065000
    22e4:	40064001 	.word	0x40064001
    22e8:	40064006 	.word	0x40064006
    22ec:	40064004 	.word	0x40064004
    22f0:	40048044 	.word	0x40048044
    22f4:	40064000 	.word	0x40064000
    22f8:	40048048 	.word	0x40048048
    22fc:	000510c0 	.word	0x000510c0
    2300:	e000e014 	.word	0xe000e014
    2304:	0001193f 	.word	0x0001193f
    2308:	00000000 	.word	0x00000000
    230c:	00000000 	.word	0x00000000
    2310:	00000000 	.word	0x00000000
    2314:	00000000 	.word	0x00000000
    2318:	00000000 	.word	0x00000000
    231c:	00000000 	.word	0x00000000
    2320:	00000000 	.word	0x00000000
    2324:	00000000 	.word	0x00000000
    2328:	00000000 	.word	0x00000000
    232c:	00000000 	.word	0x00000000
    2330:	00000000 	.word	0x00000000
    2334:	00000000 	.word	0x00000000
    2338:	00000000 	.word	0x00000000
    233c:	00000000 	.word	0x00000000
    2340:	00000000 	.word	0x00000000
    2344:	00000000 	.word	0x00000000
    2348:	00000000 	.word	0x00000000
    234c:	00000000 	.word	0x00000000
    2350:	00000000 	.word	0x00000000
    2354:	00000000 	.word	0x00000000
    2358:	00000000 	.word	0x00000000
    235c:	00000000 	.word	0x00000000
    2360:	00000000 	.word	0x00000000
    2364:	00000000 	.word	0x00000000
    2368:	00000000 	.word	0x00000000
    236c:	00000000 	.word	0x00000000
    2370:	00000000 	.word	0x00000000
    2374:	00000000 	.word	0x00000000
    2378:	00000000 	.word	0x00000000
    237c:	00000000 	.word	0x00000000
    2380:	00000000 	.word	0x00000000
    2384:	00000000 	.word	0x00000000
    2388:	00000000 	.word	0x00000000
    238c:	00000000 	.word	0x00000000
    2390:	00000000 	.word	0x00000000
    2394:	00000000 	.word	0x00000000
    2398:	00000000 	.word	0x00000000
    239c:	00000000 	.word	0x00000000
    23a0:	00000000 	.word	0x00000000
    23a4:	00000000 	.word	0x00000000
    23a8:	00000000 	.word	0x00000000
    23ac:	00000000 	.word	0x00000000
    23b0:	00000000 	.word	0x00000000
    23b4:	00000000 	.word	0x00000000
    23b8:	00000000 	.word	0x00000000
    23bc:	00000000 	.word	0x00000000
    23c0:	00000000 	.word	0x00000000
    23c4:	00000000 	.word	0x00000000
    23c8:	00000000 	.word	0x00000000
    23cc:	00000000 	.word	0x00000000
    23d0:	00000000 	.word	0x00000000
    23d4:	00000000 	.word	0x00000000
    23d8:	00000000 	.word	0x00000000
    23dc:	00000000 	.word	0x00000000
    23e0:	00000000 	.word	0x00000000
    23e4:	00000000 	.word	0x00000000
    23e8:	00000000 	.word	0x00000000
    23ec:	00000000 	.word	0x00000000
    23f0:	00000000 	.word	0x00000000
    23f4:	00000000 	.word	0x00000000
    23f8:	00000000 	.word	0x00000000
    23fc:	00000000 	.word	0x00000000

00002400 <main>:


// ----- Functions -----

int main()
{
    2400:	b508      	push	{r3, lr}
	CLKPR = 0x80;
	CLKPR = 0x00;
#endif

	// Enable CLI
	CLI_init();
    2402:	f004 ffdd 	bl	73c0 <CLI_init>

	// Setup Modules
	Output_setup();
    2406:	f003 febb 	bl	6180 <Output_setup>
	Macro_setup();
    240a:	f003 faff 	bl	5a0c <Macro_setup>
	Scan_setup();
    240e:	f002 fb3d 	bl	4a8c <Scan_setup>

	// Main Detection Loop
	while ( 1 )
	{
		// Process CLI
		CLI_process();
    2412:	f005 f8b7 	bl	7584 <CLI_process>

		// Acquire Key Indices
		// Loop continuously until scan_loop returns 0
		cli();
    2416:	b672      	cpsid	i
		while ( Scan_loop() );
    2418:	f002 fb4c 	bl	4ab4 <Scan_loop>
    241c:	2800      	cmp	r0, #0
    241e:	d1fb      	bne.n	2418 <main+0x18>
		sei();
    2420:	b662      	cpsie	i

		// Run Macros over Key Indices and convert to USB Keys
		Macro_process();
    2422:	f003 f911 	bl	5648 <Macro_process>

		// Sends USB data only if changed
		Output_send();
    2426:	f003 febb 	bl	61a0 <Output_send>
	}
    242a:	e7f2      	b.n	2412 <main+0x12>

0000242c <systick_default_isr>:

// NVIC - SysTick ISR
extern volatile uint32_t systick_millis_count;
void systick_default_isr()
{
	systick_millis_count++;
    242c:	4b02      	ldr	r3, [pc, #8]	; (2438 <systick_default_isr+0xc>)
    242e:	681a      	ldr	r2, [r3, #0]
    2430:	3201      	adds	r2, #1
    2432:	601a      	str	r2, [r3, #0]
    2434:	4770      	bx	lr
    2436:	bf00      	nop
    2438:	1fff92a4 	.word	0x1fff92a4

0000243c <fault_isr>:

// ----- Interrupts -----

// NVIC - Default ISR
void fault_isr()
{
    243c:	b508      	push	{r3, lr}
	print("Fault!" NL );
    243e:	480d      	ldr	r0, [pc, #52]	; (2474 <fault_isr+0x38>)
    2440:	f005 f9e0 	bl	7804 <_print>
	while ( 1 )
	{
		// keep polling some communication while in fault
		// mode, so we don't completely die.
		if ( SIM_SCGC4 & SIM_SCGC4_USBOTG ) usb_isr();
    2444:	4c0c      	ldr	r4, [pc, #48]	; (2478 <fault_isr+0x3c>)
    2446:	6823      	ldr	r3, [r4, #0]
    2448:	0358      	lsls	r0, r3, #13
    244a:	d501      	bpl.n	2450 <fault_isr+0x14>
    244c:	f003 ffcc 	bl	63e8 <usb_isr>
		if ( SIM_SCGC4 & SIM_SCGC4_UART0 )  uart0_status_isr();
    2450:	6823      	ldr	r3, [r4, #0]
    2452:	0559      	lsls	r1, r3, #21
    2454:	d501      	bpl.n	245a <fault_isr+0x1e>
    2456:	f000 f811 	bl	247c <unused_isr>
		if ( SIM_SCGC4 & SIM_SCGC4_UART1 )  uart1_status_isr();
    245a:	6823      	ldr	r3, [r4, #0]
    245c:	051a      	lsls	r2, r3, #20
    245e:	d501      	bpl.n	2464 <fault_isr+0x28>
    2460:	f000 f80c 	bl	247c <unused_isr>
		if ( SIM_SCGC4 & SIM_SCGC4_UART2 )  uart2_status_isr();
    2464:	4b04      	ldr	r3, [pc, #16]	; (2478 <fault_isr+0x3c>)
    2466:	681b      	ldr	r3, [r3, #0]
    2468:	04db      	lsls	r3, r3, #19
    246a:	d5eb      	bpl.n	2444 <fault_isr+0x8>
    246c:	f000 f806 	bl	247c <unused_isr>
    2470:	e7e8      	b.n	2444 <fault_isr+0x8>
    2472:	bf00      	nop
    2474:	00008d7c 	.word	0x00008d7c
    2478:	40048034 	.word	0x40048034

0000247c <unused_isr>:
	}
}

void unused_isr()
{
    247c:	b508      	push	{r3, lr}
	fault_isr();
    247e:	f7ff ffdd 	bl	243c <fault_isr>
    2482:	0000      	movs	r0, r0

00002484 <nmi_default_isr>:


// NVIC - Non-Maskable Interrupt ISR
void nmi_default_isr()
{
	print("NMI!" NL );
    2484:	4801      	ldr	r0, [pc, #4]	; (248c <nmi_default_isr+0x8>)
    2486:	f005 b9bd 	b.w	7804 <_print>
    248a:	bf00      	nop
    248c:	00007a4a 	.word	0x00007a4a

00002490 <hard_fault_default_isr>:
}


// NVIC - Hard Fault ISR
void hard_fault_default_isr()
{
    2490:	b508      	push	{r3, lr}
	print("Hard Fault! SCB_HFSR: ");
    2492:	4807      	ldr	r0, [pc, #28]	; (24b0 <hard_fault_default_isr+0x20>)
    2494:	f005 f9b6 	bl	7804 <_print>
	printHex32( SCB_HFSR );
    2498:	4b06      	ldr	r3, [pc, #24]	; (24b4 <hard_fault_default_isr+0x24>)
    249a:	2101      	movs	r1, #1
    249c:	6818      	ldr	r0, [r3, #0]
    249e:	f005 fa6f 	bl	7980 <printHex32_op>
	print( NL );
    24a2:	4805      	ldr	r0, [pc, #20]	; (24b8 <hard_fault_default_isr+0x28>)
    24a4:	f005 f9ae 	bl	7804 <_print>
	SOFTWARE_RESET();
    24a8:	4a04      	ldr	r2, [pc, #16]	; (24bc <hard_fault_default_isr+0x2c>)
    24aa:	4b05      	ldr	r3, [pc, #20]	; (24c0 <hard_fault_default_isr+0x30>)
    24ac:	601a      	str	r2, [r3, #0]
    24ae:	bd08      	pop	{r3, pc}
    24b0:	00007a51 	.word	0x00007a51
    24b4:	e000ed2c 	.word	0xe000ed2c
    24b8:	0000bafb 	.word	0x0000bafb
    24bc:	05fa0004 	.word	0x05fa0004
    24c0:	e000ed0c 	.word	0xe000ed0c

000024c4 <memmanage_fault_default_isr>:
}


// NVIC - Memory Manager Fault ISR
void memmanage_fault_default_isr()
{
    24c4:	b508      	push	{r3, lr}
	print("Memory Manager Fault! SCB_CFSR: ");
    24c6:	480a      	ldr	r0, [pc, #40]	; (24f0 <memmanage_fault_default_isr+0x2c>)
    24c8:	f005 f99c 	bl	7804 <_print>
	printHex32( SCB_CFSR );
    24cc:	4b09      	ldr	r3, [pc, #36]	; (24f4 <memmanage_fault_default_isr+0x30>)
    24ce:	2101      	movs	r1, #1
    24d0:	6818      	ldr	r0, [r3, #0]
    24d2:	f005 fa55 	bl	7980 <printHex32_op>
	print(" SCB_MMAR: ");
    24d6:	4808      	ldr	r0, [pc, #32]	; (24f8 <memmanage_fault_default_isr+0x34>)
    24d8:	f005 f994 	bl	7804 <_print>
	printHex32( SCB_MMAR );
    24dc:	4b07      	ldr	r3, [pc, #28]	; (24fc <memmanage_fault_default_isr+0x38>)
    24de:	2101      	movs	r1, #1
    24e0:	6818      	ldr	r0, [r3, #0]
    24e2:	f005 fa4d 	bl	7980 <printHex32_op>
	print( NL );
    24e6:	4806      	ldr	r0, [pc, #24]	; (2500 <memmanage_fault_default_isr+0x3c>)
}
    24e8:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
{
	print("Memory Manager Fault! SCB_CFSR: ");
	printHex32( SCB_CFSR );
	print(" SCB_MMAR: ");
	printHex32( SCB_MMAR );
	print( NL );
    24ec:	f005 b98a 	b.w	7804 <_print>
    24f0:	00007a68 	.word	0x00007a68
    24f4:	e000ed28 	.word	0xe000ed28
    24f8:	00007a89 	.word	0x00007a89
    24fc:	e000ed34 	.word	0xe000ed34
    2500:	0000bafb 	.word	0x0000bafb

00002504 <bus_fault_default_isr>:
}


// NVIC - Bus Fault ISR
void bus_fault_default_isr()
{
    2504:	b508      	push	{r3, lr}
	print("Bus Fault! SCB_CFSR: ");
    2506:	480a      	ldr	r0, [pc, #40]	; (2530 <bus_fault_default_isr+0x2c>)
    2508:	f005 f97c 	bl	7804 <_print>
	printHex32( SCB_CFSR );
    250c:	4b09      	ldr	r3, [pc, #36]	; (2534 <bus_fault_default_isr+0x30>)
    250e:	2101      	movs	r1, #1
    2510:	6818      	ldr	r0, [r3, #0]
    2512:	f005 fa35 	bl	7980 <printHex32_op>
	print(" SCB_BFAR: ");
    2516:	4808      	ldr	r0, [pc, #32]	; (2538 <bus_fault_default_isr+0x34>)
    2518:	f005 f974 	bl	7804 <_print>
	printHex32( SCB_BFAR );
    251c:	4b07      	ldr	r3, [pc, #28]	; (253c <bus_fault_default_isr+0x38>)
    251e:	2101      	movs	r1, #1
    2520:	6818      	ldr	r0, [r3, #0]
    2522:	f005 fa2d 	bl	7980 <printHex32_op>
	print( NL );
    2526:	4806      	ldr	r0, [pc, #24]	; (2540 <bus_fault_default_isr+0x3c>)
}
    2528:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
{
	print("Bus Fault! SCB_CFSR: ");
	printHex32( SCB_CFSR );
	print(" SCB_BFAR: ");
	printHex32( SCB_BFAR );
	print( NL );
    252c:	f005 b96a 	b.w	7804 <_print>
    2530:	00007a95 	.word	0x00007a95
    2534:	e000ed28 	.word	0xe000ed28
    2538:	00007aab 	.word	0x00007aab
    253c:	e000ed38 	.word	0xe000ed38
    2540:	0000bafb 	.word	0x0000bafb

00002544 <usage_fault_default_isr>:
}


// NVIC - Usage Fault ISR
void usage_fault_default_isr()
{
    2544:	b508      	push	{r3, lr}
	print("Usage Fault! SCB_CFSR: ");
    2546:	4806      	ldr	r0, [pc, #24]	; (2560 <usage_fault_default_isr+0x1c>)
    2548:	f005 f95c 	bl	7804 <_print>
	printHex32( SCB_CFSR );
    254c:	4b05      	ldr	r3, [pc, #20]	; (2564 <usage_fault_default_isr+0x20>)
    254e:	2101      	movs	r1, #1
    2550:	6818      	ldr	r0, [r3, #0]
    2552:	f005 fa15 	bl	7980 <printHex32_op>
	print( NL );
    2556:	4804      	ldr	r0, [pc, #16]	; (2568 <usage_fault_default_isr+0x24>)
}
    2558:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
// NVIC - Usage Fault ISR
void usage_fault_default_isr()
{
	print("Usage Fault! SCB_CFSR: ");
	printHex32( SCB_CFSR );
	print( NL );
    255c:	f005 b952 	b.w	7804 <_print>
    2560:	00007ab7 	.word	0x00007ab7
    2564:	e000ed28 	.word	0xe000ed28
    2568:	0000bafb 	.word	0x0000bafb

0000256c <memset>:
	__builtin_unreachable();
}
#endif

void *memset( void *addr, int val, unsigned int len )
{
    256c:	4402      	add	r2, r0
	char *buf = addr;
    256e:	4603      	mov	r3, r0

	for (; len > 0; --len, ++buf)
    2570:	4293      	cmp	r3, r2
    2572:	d002      	beq.n	257a <memset+0xe>
		*buf = val;
    2574:	f803 1b01 	strb.w	r1, [r3], #1
    2578:	e7fa      	b.n	2570 <memset+0x4>
	return (addr);
}
    257a:	4770      	bx	lr

0000257c <memcpy>:
		/* NOTHING */;
	return (val);
}

void *memcpy( void *dst, const void *src, unsigned int len )
{
    257c:	b510      	push	{r4, lr}
	char *dstbuf = dst;
	const char *srcbuf = src;

	for (; len > 0; --len, ++dstbuf, ++srcbuf)
    257e:	2300      	movs	r3, #0
    2580:	4293      	cmp	r3, r2
    2582:	d003      	beq.n	258c <memcpy+0x10>
		*dstbuf = *srcbuf;
    2584:	5ccc      	ldrb	r4, [r1, r3]
    2586:	54c4      	strb	r4, [r0, r3]
    2588:	3301      	adds	r3, #1
    258a:	e7f9      	b.n	2580 <memcpy+0x4>
	return (dst);
}
    258c:	bd10      	pop	{r4, pc}

0000258e <yield>:



// ----- Functions -----

void yield(void) {};
    258e:	4770      	bx	lr

00002590 <micros>:

uint32_t micros(void)
{
	uint32_t count, current, istatus;

	__disable_irq();
    2590:	b672      	cpsid	i
	current = SYST_CVR;
    2592:	4b0c      	ldr	r3, [pc, #48]	; (25c4 <micros+0x34>)
	count = systick_millis_count;
	istatus = SCB_ICSR; // bit 26 indicates if systick exception pending
    2594:	490c      	ldr	r1, [pc, #48]	; (25c8 <micros+0x38>)
uint32_t micros(void)
{
	uint32_t count, current, istatus;

	__disable_irq();
	current = SYST_CVR;
    2596:	681a      	ldr	r2, [r3, #0]
	count = systick_millis_count;
    2598:	4b0c      	ldr	r3, [pc, #48]	; (25cc <micros+0x3c>)
    259a:	681b      	ldr	r3, [r3, #0]
	istatus = SCB_ICSR; // bit 26 indicates if systick exception pending
    259c:	6809      	ldr	r1, [r1, #0]
	__enable_irq();
    259e:	b662      	cpsie	i
	if ((istatus & SCB_ICSR_PENDSTSET) && current > ((F_CPU / 1000) - 50)) count++;
    25a0:	0149      	lsls	r1, r1, #5
    25a2:	d503      	bpl.n	25ac <micros+0x1c>
    25a4:	490a      	ldr	r1, [pc, #40]	; (25d0 <micros+0x40>)
    25a6:	428a      	cmp	r2, r1
    25a8:	bf88      	it	hi
    25aa:	3301      	addhi	r3, #1
	current = ((F_CPU / 1000) - 1) - current;
    25ac:	f5c2 328c 	rsb	r2, r2, #71680	; 0x11800
	return count * 1000 + current / (F_CPU / 1000000);
    25b0:	2148      	movs	r1, #72	; 0x48
	current = SYST_CVR;
	count = systick_millis_count;
	istatus = SCB_ICSR; // bit 26 indicates if systick exception pending
	__enable_irq();
	if ((istatus & SCB_ICSR_PENDSTSET) && current > ((F_CPU / 1000) - 50)) count++;
	current = ((F_CPU / 1000) - 1) - current;
    25b2:	f202 123f 	addw	r2, r2, #319	; 0x13f
	return count * 1000 + current / (F_CPU / 1000000);
    25b6:	fbb2 f2f1 	udiv	r2, r2, r1
}
    25ba:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
    25be:	fb00 2003 	mla	r0, r0, r3, r2
    25c2:	4770      	bx	lr
    25c4:	e000e018 	.word	0xe000e018
    25c8:	e000ed04 	.word	0xe000ed04
    25cc:	1fff92a4 	.word	0x1fff92a4
    25d0:	0001190e 	.word	0x0001190e

000025d4 <delay>:

void delay(uint32_t ms)
{
    25d4:	b538      	push	{r3, r4, r5, lr}
    25d6:	4604      	mov	r4, r0
	uint32_t start = micros();
    25d8:	f7ff ffda 	bl	2590 <micros>
    25dc:	4605      	mov	r5, r0

	while (1) {
		if ((micros() - start) >= 1000) {
    25de:	f7ff ffd7 	bl	2590 <micros>
    25e2:	1b40      	subs	r0, r0, r5
    25e4:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
    25e8:	d303      	bcc.n	25f2 <delay+0x1e>
			ms--;
			if (ms == 0) break;
    25ea:	3c01      	subs	r4, #1
    25ec:	d004      	beq.n	25f8 <delay+0x24>
			start += 1000;
    25ee:	f505 757a 	add.w	r5, r5, #1000	; 0x3e8
		}
		yield();
    25f2:	f7ff ffcc 	bl	258e <yield>
	}
    25f6:	e7f2      	b.n	25de <delay+0xa>
    25f8:	bd38      	pop	{r3, r4, r5, pc}

000025fa <I2C_BufferLen>:


inline uint16_t I2C_BufferLen( I2C_Buffer *buffer )
{
	// Tail >= Head
	if ( buffer->tail >= buffer->head )
    25fa:	8802      	ldrh	r2, [r0, #0]
    25fc:	8843      	ldrh	r3, [r0, #2]
    25fe:	4293      	cmp	r3, r2
		return buffer->head + buffer->size - buffer->tail;
    2600:	bf24      	itt	cs
    2602:	88c0      	ldrhcs	r0, [r0, #6]
    2604:	1812      	addcs	r2, r2, r0

	// Head > Tail
	return buffer->head - buffer->tail;
    2606:	1ad3      	subs	r3, r2, r3
    2608:	b298      	uxth	r0, r3
}
    260a:	4770      	bx	lr

0000260c <I2C_BufferPush>:


void I2C_BufferPush( uint8_t byte, I2C_Buffer *buffer )
{
    260c:	b538      	push	{r3, r4, r5, lr}
    260e:	460c      	mov	r4, r1
    2610:	4605      	mov	r5, r0
	dbug_msg("DATA: ");
    2612:	4813      	ldr	r0, [pc, #76]	; (2660 <I2C_BufferPush+0x54>)
    2614:	f005 f8f6 	bl	7804 <_print>
	printHex( byte );
    2618:	2101      	movs	r1, #1
    261a:	4628      	mov	r0, r5
    261c:	f005 f97b 	bl	7916 <printHex_op>

	// Make sure buffer isn't full
	if ( buffer->tail + 1 == buffer->head || ( buffer->head > buffer->tail && buffer->tail + 1 - buffer->size == buffer->head ) )
    2620:	8861      	ldrh	r1, [r4, #2]
    2622:	8822      	ldrh	r2, [r4, #0]
    2624:	1c4b      	adds	r3, r1, #1
    2626:	4293      	cmp	r3, r2
    2628:	d005      	beq.n	2636 <I2C_BufferPush+0x2a>
    262a:	428a      	cmp	r2, r1
    262c:	88e1      	ldrh	r1, [r4, #6]
    262e:	d90e      	bls.n	264e <I2C_BufferPush+0x42>
    2630:	1a58      	subs	r0, r3, r1
    2632:	4290      	cmp	r0, r2
    2634:	d10b      	bne.n	264e <I2C_BufferPush+0x42>
	{
		warn_msg("I2C_BufferPush failed, buffer full: ");
    2636:	480b      	ldr	r0, [pc, #44]	; (2664 <I2C_BufferPush+0x58>)
    2638:	f005 f8e4 	bl	7804 <_print>
		printHex( byte );
    263c:	4628      	mov	r0, r5
    263e:	2101      	movs	r1, #1
    2640:	f005 f969 	bl	7916 <printHex_op>
		print( NL );
    2644:	4808      	ldr	r0, [pc, #32]	; (2668 <I2C_BufferPush+0x5c>)
		buffer->tail++;
	}

	// Add byte to buffer
	buffer->buffer[ buffer->tail ] = byte;
}
    2646:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	// Make sure buffer isn't full
	if ( buffer->tail + 1 == buffer->head || ( buffer->head > buffer->tail && buffer->tail + 1 - buffer->size == buffer->head ) )
	{
		warn_msg("I2C_BufferPush failed, buffer full: ");
		printHex( byte );
		print( NL );
    264a:	f005 b8db 	b.w	7804 <_print>
		return;
	}

	// Check for wrap-around case
	if ( buffer->tail + 1 >= buffer->size )
    264e:	428b      	cmp	r3, r1
	{
		buffer->tail = 0;
    2650:	bfa8      	it	ge
    2652:	2300      	movge	r3, #0
	}
	// Normal case
	else
	{
		buffer->tail++;
    2654:	8063      	strh	r3, [r4, #2]
	}

	// Add byte to buffer
	buffer->buffer[ buffer->tail ] = byte;
    2656:	8863      	ldrh	r3, [r4, #2]
    2658:	68a2      	ldr	r2, [r4, #8]
    265a:	54d5      	strb	r5, [r2, r3]
    265c:	bd38      	pop	{r3, r4, r5, pc}
    265e:	bf00      	nop
    2660:	00007bf1 	.word	0x00007bf1
    2664:	00007c0b 	.word	0x00007c0b
    2668:	0000bafb 	.word	0x0000bafb

0000266c <I2C_TxBufferPop>:
}


uint8_t I2C_TxBufferPop()
{
    266c:	b538      	push	{r3, r4, r5, lr}
	// Return 0xFF if no buffer left (do not rely on this)
	if ( I2C_BufferLen( (I2C_Buffer*)&I2C_TxBuffer ) >= I2C_TxBuffer.size )
    266e:	4d23      	ldr	r5, [pc, #140]	; (26fc <I2C_TxBufferPop+0x90>)
    2670:	4628      	mov	r0, r5
    2672:	f7ff ffc2 	bl	25fa <I2C_BufferLen>
    2676:	88eb      	ldrh	r3, [r5, #6]
    2678:	b29b      	uxth	r3, r3
    267a:	4298      	cmp	r0, r3
    267c:	462c      	mov	r4, r5
    267e:	d31b      	bcc.n	26b8 <I2C_TxBufferPop+0x4c>
	{
		erro_msg("No buffer to pop an entry from... ");
    2680:	481f      	ldr	r0, [pc, #124]	; (2700 <I2C_TxBufferPop+0x94>)
    2682:	f005 f8bf 	bl	7804 <_print>
		printHex( I2C_TxBuffer.head );
    2686:	8828      	ldrh	r0, [r5, #0]
    2688:	2101      	movs	r1, #1
    268a:	b280      	uxth	r0, r0
    268c:	f005 f943 	bl	7916 <printHex_op>
		print(" ");
    2690:	481c      	ldr	r0, [pc, #112]	; (2704 <I2C_TxBufferPop+0x98>)
    2692:	f005 f8b7 	bl	7804 <_print>
		printHex( I2C_TxBuffer.tail );
    2696:	8868      	ldrh	r0, [r5, #2]
    2698:	2101      	movs	r1, #1
    269a:	b280      	uxth	r0, r0
    269c:	f005 f93b 	bl	7916 <printHex_op>
		print(" ");
    26a0:	4818      	ldr	r0, [pc, #96]	; (2704 <I2C_TxBufferPop+0x98>)
    26a2:	f005 f8af 	bl	7804 <_print>
		printHex( I2C_TxBuffer.sequencePos );
    26a6:	7928      	ldrb	r0, [r5, #4]
    26a8:	2101      	movs	r1, #1
    26aa:	f005 f934 	bl	7916 <printHex_op>
		print(NL);
    26ae:	4816      	ldr	r0, [pc, #88]	; (2708 <I2C_TxBufferPop+0x9c>)
    26b0:	f005 f8a8 	bl	7804 <_print>
    26b4:	20ff      	movs	r0, #255	; 0xff
    26b6:	bd38      	pop	{r3, r4, r5, pc}
		return 0xFF;
	}

	// If there is currently no sequence being sent, the first entry in the RingBuffer is the length
	if ( I2C_TxBuffer.sequencePos == 0 )
    26b8:	792b      	ldrb	r3, [r5, #4]
    26ba:	b943      	cbnz	r3, 26ce <I2C_TxBufferPop+0x62>
	{
		I2C_TxBuffer.sequencePos = 0xFF; // So this doesn't become an infinite loop
    26bc:	23ff      	movs	r3, #255	; 0xff
    26be:	712b      	strb	r3, [r5, #4]
		I2C_RxBuffer.sequencePos = I2C_TxBufferPop();
    26c0:	f7ff ffd4 	bl	266c <I2C_TxBufferPop>
    26c4:	4b11      	ldr	r3, [pc, #68]	; (270c <I2C_TxBufferPop+0xa0>)
    26c6:	7118      	strb	r0, [r3, #4]
		I2C_TxBuffer.sequencePos = I2C_TxBufferPop();
    26c8:	f7ff ffd0 	bl	266c <I2C_TxBufferPop>
    26cc:	7128      	strb	r0, [r5, #4]
	}

	uint8_t data = I2C_TxBuffer.buffer[ I2C_TxBuffer.head ];
    26ce:	68a2      	ldr	r2, [r4, #8]
    26d0:	8823      	ldrh	r3, [r4, #0]
    26d2:	b29b      	uxth	r3, r3
    26d4:	5cd0      	ldrb	r0, [r2, r3]

	// Prune head
	I2C_TxBuffer.head++;
    26d6:	8823      	ldrh	r3, [r4, #0]
    26d8:	b29b      	uxth	r3, r3
    26da:	3301      	adds	r3, #1
    26dc:	b29b      	uxth	r3, r3
    26de:	8023      	strh	r3, [r4, #0]

	// Wrap-around case
	if ( I2C_TxBuffer.head >= I2C_TxBuffer.size )
    26e0:	8822      	ldrh	r2, [r4, #0]
    26e2:	88e3      	ldrh	r3, [r4, #6]
    26e4:	b292      	uxth	r2, r2
    26e6:	b29b      	uxth	r3, r3
    26e8:	429a      	cmp	r2, r3
    26ea:	d302      	bcc.n	26f2 <I2C_TxBufferPop+0x86>
		I2C_TxBuffer.head = 0;
    26ec:	4b03      	ldr	r3, [pc, #12]	; (26fc <I2C_TxBufferPop+0x90>)
    26ee:	2200      	movs	r2, #0
    26f0:	801a      	strh	r2, [r3, #0]

	// Decrement buffer sequence (until next stop will be sent)
	I2C_TxBuffer.sequencePos--;
    26f2:	7923      	ldrb	r3, [r4, #4]
    26f4:	3b01      	subs	r3, #1
    26f6:	b2db      	uxtb	r3, r3
    26f8:	7123      	strb	r3, [r4, #4]
	print(" ");
	printHex( I2C_TxBuffer.sequencePos );
	print(NL);
	*/
	return data;
}
    26fa:	bd38      	pop	{r3, r4, r5, pc}
    26fc:	1fff899c 	.word	0x1fff899c
    2700:	00007c45 	.word	0x00007c45
    2704:	00008156 	.word	0x00008156
    2708:	0000bafb 	.word	0x0000bafb
    270c:	1fff8990 	.word	0x1fff8990

00002710 <i2c0_isr>:


// ----- Interrupt Functions -----

void i2c0_isr()
{
    2710:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	cli(); // Disable Interrupts
    2714:	b672      	cpsid	i

	uint8_t status = I2C0_S; // Read I2C Bus status
    2716:	f8df 8108 	ldr.w	r8, [pc, #264]	; 2820 <L_397_delayMicroseconds+0x3e>

	// Master Mode Transmit
	if ( I2C0_C1 & I2C_C1_TX )
    271a:	4d39      	ldr	r5, [pc, #228]	; (2800 <L_397_delayMicroseconds+0x1e>)

void i2c0_isr()
{
	cli(); // Disable Interrupts

	uint8_t status = I2C0_S; // Read I2C Bus status
    271c:	f898 6000 	ldrb.w	r6, [r8]

	// Master Mode Transmit
	if ( I2C0_C1 & I2C_C1_TX )
    2720:	782b      	ldrb	r3, [r5, #0]
    2722:	4c38      	ldr	r4, [pc, #224]	; (2804 <L_397_delayMicroseconds+0x22>)
    2724:	f013 0f10 	tst.w	r3, #16

void i2c0_isr()
{
	cli(); // Disable Interrupts

	uint8_t status = I2C0_S; // Read I2C Bus status
    2728:	b2f6      	uxtb	r6, r6
	// Master Mode Transmit
	if ( I2C0_C1 & I2C_C1_TX )
	{
		// Check current use of the I2C bus
		// Currently sending data
		if ( I2C_TxBuffer.sequencePos > 0 )
    272a:	7923      	ldrb	r3, [r4, #4]
	cli(); // Disable Interrupts

	uint8_t status = I2C0_S; // Read I2C Bus status

	// Master Mode Transmit
	if ( I2C0_C1 & I2C_C1_TX )
    272c:	d04f      	beq.n	27ce <L_336_delayMicroseconds+0x2e>
	{
		// Check current use of the I2C bus
		// Currently sending data
		if ( I2C_TxBuffer.sequencePos > 0 )
    272e:	b15b      	cbz	r3, 2748 <i2c0_isr+0x38>
		{
			// Make sure slave sent an ACK
			if ( status & I2C_S_RXAK )
    2730:	07f6      	lsls	r6, r6, #31
    2732:	d547      	bpl.n	27c4 <L_336_delayMicroseconds+0x24>
			{
				// NACK Detected, disable interrupt
				erro_print("I2C NAK detected...");
    2734:	4834      	ldr	r0, [pc, #208]	; (2808 <L_397_delayMicroseconds+0x26>)
    2736:	f005 f865 	bl	7804 <_print>
				I2C0_C1 = I2C_C1_IICEN;
    273a:	2380      	movs	r3, #128	; 0x80
    273c:	702b      	strb	r3, [r5, #0]

				// Abort Tx Buffer
				I2C_TxBuffer.head = 0;
    273e:	2300      	movs	r3, #0
    2740:	8023      	strh	r3, [r4, #0]
				I2C_TxBuffer.tail = 0;
    2742:	8063      	strh	r3, [r4, #2]
				I2C_TxBuffer.sequencePos = 0;
    2744:	7123      	strb	r3, [r4, #4]
    2746:	e054      	b.n	27f2 <L_397_delayMicroseconds+0x10>
				// Transmit byte
				I2C0_D = I2C_TxBufferPop();
			}
		}
		// Receiving data
		else if ( I2C_RxBuffer.sequencePos > 0 )
    2748:	4f30      	ldr	r7, [pc, #192]	; (280c <L_397_delayMicroseconds+0x2a>)
    274a:	793b      	ldrb	r3, [r7, #4]
    274c:	b30b      	cbz	r3, 2792 <i2c0_isr+0x82>
		{
			// Master Receive, addr sent
			if ( status & I2C_S_ARBL )
    274e:	06f0      	lsls	r0, r6, #27
    2750:	d507      	bpl.n	2762 <i2c0_isr+0x52>
			{
				// Arbitration Lost
				erro_print("Arbitration lost...");
    2752:	482f      	ldr	r0, [pc, #188]	; (2810 <L_397_delayMicroseconds+0x2e>)
    2754:	f005 f856 	bl	7804 <_print>
				// TODO Abort Rx

				I2C0_C1 = I2C_C1_IICEN;
    2758:	2380      	movs	r3, #128	; 0x80
    275a:	702b      	strb	r3, [r5, #0]
				I2C0_S = I2C_S_ARBL | I2C_S_IICIF; // Clear ARBL flag and interrupt
    275c:	2312      	movs	r3, #18
    275e:	f888 3000 	strb.w	r3, [r8]
			}
			if ( status & I2C_S_RXAK )
    2762:	07f1      	lsls	r1, r6, #31
    2764:	d503      	bpl.n	276e <i2c0_isr+0x5e>
			{
				// Slave Address NACK Detected, disable interrupt
				erro_print("Slave Address I2C NAK detected...");
    2766:	482b      	ldr	r0, [pc, #172]	; (2814 <L_397_delayMicroseconds+0x32>)
    2768:	f005 f84c 	bl	7804 <_print>
    276c:	e03b      	b.n	27e6 <L_397_delayMicroseconds+0x4>

				I2C0_C1 = I2C_C1_IICEN;
			}
			else
			{
				dbug_msg("Attempting to read byte - ");
    276e:	482a      	ldr	r0, [pc, #168]	; (2818 <L_397_delayMicroseconds+0x36>)
    2770:	f005 f848 	bl	7804 <_print>
				printHex( I2C_RxBuffer.sequencePos );
    2774:	7938      	ldrb	r0, [r7, #4]
    2776:	2101      	movs	r1, #1
    2778:	f005 f8cd 	bl	7916 <printHex_op>
				print( NL );
    277c:	4827      	ldr	r0, [pc, #156]	; (281c <L_397_delayMicroseconds+0x3a>)
    277e:	f005 f841 	bl	7804 <_print>
				I2C0_C1 = I2C_RxBuffer.sequencePos == 1
    2782:	793a      	ldrb	r2, [r7, #4]
    2784:	2a01      	cmp	r2, #1
    2786:	bf14      	ite	ne
    2788:	22e0      	movne	r2, #224	; 0xe0
    278a:	22e8      	moveq	r2, #232	; 0xe8
    278c:	4b1c      	ldr	r3, [pc, #112]	; (2800 <L_397_delayMicroseconds+0x1e>)
    278e:	701a      	strb	r2, [r3, #0]
    2790:	e02f      	b.n	27f2 <L_397_delayMicroseconds+0x10>
#elif F_CPU == 48000000
	uint32_t n = usec << 4;
#elif F_CPU == 24000000
	uint32_t n = usec << 3;
#endif
	asm volatile(
    2792:	2320      	movs	r3, #32

00002794 <L_323_delayMicroseconds>:
    2794:	3b01      	subs	r3, #1
    2796:	d1fd      	bne.n	2794 <L_323_delayMicroseconds>
			print(NL);
			*/

			// Delay around STOP to make sure it actually happens...
			delayMicroseconds( 1 );
			I2C0_C1 = I2C_C1_IICEN; // Send STOP
    2798:	4b19      	ldr	r3, [pc, #100]	; (2800 <L_397_delayMicroseconds+0x1e>)
    279a:	2280      	movs	r2, #128	; 0x80
    279c:	701a      	strb	r2, [r3, #0]
    279e:	23e0      	movs	r3, #224	; 0xe0

000027a0 <L_336_delayMicroseconds>:
    27a0:	3b01      	subs	r3, #1
    27a2:	d1fd      	bne.n	27a0 <L_336_delayMicroseconds>
			delayMicroseconds( 7 );

			// If there is another sequence, start sending
			if ( I2C_BufferLen( (I2C_Buffer*)&I2C_TxBuffer ) < I2C_TxBuffer.size )
    27a4:	4817      	ldr	r0, [pc, #92]	; (2804 <L_397_delayMicroseconds+0x22>)
    27a6:	f7ff ff28 	bl	25fa <I2C_BufferLen>
    27aa:	88e3      	ldrh	r3, [r4, #6]
    27ac:	b29b      	uxth	r3, r3
    27ae:	4298      	cmp	r0, r3
    27b0:	d21f      	bcs.n	27f2 <L_397_delayMicroseconds+0x10>
			{
				// Clear status flags
				I2C0_S = I2C_S_IICIF | I2C_S_ARBL;
    27b2:	4b1b      	ldr	r3, [pc, #108]	; (2820 <L_397_delayMicroseconds+0x3e>)
    27b4:	2212      	movs	r2, #18
    27b6:	701a      	strb	r2, [r3, #0]

				// Wait...till the master dies
				while ( I2C0_S & I2C_S_BUSY );
    27b8:	781a      	ldrb	r2, [r3, #0]
    27ba:	0692      	lsls	r2, r2, #26
    27bc:	d4fc      	bmi.n	27b8 <L_336_delayMicroseconds+0x18>

				// Enable I2C interrupt
				I2C0_C1 = I2C_C1_IICEN | I2C_C1_IICIE | I2C_C1_MST | I2C_C1_TX;
    27be:	4b10      	ldr	r3, [pc, #64]	; (2800 <L_397_delayMicroseconds+0x1e>)
    27c0:	22f0      	movs	r2, #240	; 0xf0
    27c2:	701a      	strb	r2, [r3, #0]

				// Transmit byte
				I2C0_D = I2C_TxBufferPop();
    27c4:	f7ff ff52 	bl	266c <I2C_TxBufferPop>
    27c8:	4b16      	ldr	r3, [pc, #88]	; (2824 <L_397_delayMicroseconds+0x42>)
    27ca:	7018      	strb	r0, [r3, #0]
    27cc:	e011      	b.n	27f2 <L_397_delayMicroseconds+0x10>
	{
		// XXX Do we need to handle 2nd last byte?
		//I2C0_C1 = I2C_C1_IICEN | I2C_C1_IICIE | I2C_C1_MST | I2C_C1_TXAK; // No STOP, Rx, NAK on recv

		// Last byte
		if ( I2C_TxBuffer.sequencePos <= 1 )
    27ce:	2b01      	cmp	r3, #1
    27d0:	4b14      	ldr	r3, [pc, #80]	; (2824 <L_397_delayMicroseconds+0x42>)
    27d2:	d80a      	bhi.n	27ea <L_397_delayMicroseconds+0x8>
		{
			// Change to Tx mode
			I2C0_C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_TX;
    27d4:	22b0      	movs	r2, #176	; 0xb0
    27d6:	702a      	strb	r2, [r5, #0]

			// Grab last byte
			I2C_BufferPush( I2C0_D, (I2C_Buffer*)&I2C_RxBuffer );
    27d8:	7818      	ldrb	r0, [r3, #0]
    27da:	490c      	ldr	r1, [pc, #48]	; (280c <L_397_delayMicroseconds+0x2a>)
    27dc:	f7ff ff16 	bl	260c <I2C_BufferPush>
    27e0:	2320      	movs	r3, #32

000027e2 <L_397_delayMicroseconds>:
    27e2:	3b01      	subs	r3, #1
    27e4:	d1fd      	bne.n	27e2 <L_397_delayMicroseconds>

			delayMicroseconds( 1 ); // Should be enough time before issuing the stop
			I2C0_C1 = I2C_C1_IICEN; // Send STOP
    27e6:	2280      	movs	r2, #128	; 0x80
    27e8:	e7d0      	b.n	278c <i2c0_isr+0x7c>
		}
		else
		{
			// Retrieve data
			I2C_BufferPush( I2C0_D, (I2C_Buffer*)&I2C_RxBuffer );
    27ea:	7818      	ldrb	r0, [r3, #0]
    27ec:	4907      	ldr	r1, [pc, #28]	; (280c <L_397_delayMicroseconds+0x2a>)
    27ee:	f7ff ff0d 	bl	260c <I2C_BufferPush>
		}
	}

	I2C0_S = I2C_S_IICIF; // Clear interrupt
    27f2:	4b0b      	ldr	r3, [pc, #44]	; (2820 <L_397_delayMicroseconds+0x3e>)
    27f4:	2202      	movs	r2, #2
    27f6:	701a      	strb	r2, [r3, #0]

	sei(); // Re-enable Interrupts
    27f8:	b662      	cpsie	i
    27fa:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    27fe:	bf00      	nop
    2800:	40066002 	.word	0x40066002
    2804:	1fff899c 	.word	0x1fff899c
    2808:	00007c7d 	.word	0x00007c7d
    280c:	1fff8990 	.word	0x1fff8990
    2810:	00007ca8 	.word	0x00007ca8
    2814:	00007cd3 	.word	0x00007cd3
    2818:	00007d0c 	.word	0x00007d0c
    281c:	0000bafb 	.word	0x0000bafb
    2820:	40066003 	.word	0x40066003
    2824:	40066004 	.word	0x40066004

00002828 <I2C_Send>:
	return data;
}


uint8_t I2C_Send( uint8_t *data, uint8_t sendLen, uint8_t recvLen )
{
    2828:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
inline uint8_t I2C_BufferCopy( uint8_t *data, uint8_t sendLen, uint8_t recvLen, I2C_Buffer *buffer )
{
	uint8_t reTurn = 0;

	// If sendLen is greater than buffer fail right away
	if ( sendLen > buffer->size )
    282c:	4c33      	ldr	r4, [pc, #204]	; (28fc <I2C_Send+0xd4>)
    282e:	88e3      	ldrh	r3, [r4, #6]
    2830:	b29b      	uxth	r3, r3
    2832:	428b      	cmp	r3, r1
	return data;
}


uint8_t I2C_Send( uint8_t *data, uint8_t sendLen, uint8_t recvLen )
{
    2834:	4680      	mov	r8, r0
    2836:	460d      	mov	r5, r1
    2838:	4691      	mov	r9, r2
inline uint8_t I2C_BufferCopy( uint8_t *data, uint8_t sendLen, uint8_t recvLen, I2C_Buffer *buffer )
{
	uint8_t reTurn = 0;

	// If sendLen is greater than buffer fail right away
	if ( sendLen > buffer->size )
    283a:	d358      	bcc.n	28ee <I2C_Send+0xc6>
	// The second element in the new buffer is the length of the buffer sequence (+1)
	uint16_t newTail = buffer->tail + sendLen + 2;
	if ( newTail >= buffer->size )
		newTail -= buffer->size;

	if ( I2C_BufferLen( buffer ) < sendLen + 2 )
    283c:	4620      	mov	r0, r4
    283e:	f7ff fedc 	bl	25fa <I2C_BufferLen>
    2842:	1c6b      	adds	r3, r5, #1
    2844:	4283      	cmp	r3, r0
    2846:	da52      	bge.n	28ee <I2C_Send+0xc6>
	printHex( newTail );
	print("@");
*/

	// If buffer is clean, return 1, otherwise 2
	reTurn = buffer->head == buffer->tail ? 1 : 2;
    2848:	8822      	ldrh	r2, [r4, #0]
    284a:	8863      	ldrh	r3, [r4, #2]
    284c:	b292      	uxth	r2, r2
    284e:	b29b      	uxth	r3, r3
    2850:	429a      	cmp	r2, r3
    2852:	bf14      	ite	ne
    2854:	2202      	movne	r2, #2
    2856:	2201      	moveq	r2, #1

	// Add to buffer, already know there is enough room (simplifies adding logic)
	uint8_t bufferHeaderPos = 0;
	for ( uint16_t c = 0; c < sendLen; c++ )
    2858:	2300      	movs	r3, #0

	// If buffer is clean, return 1, otherwise 2
	reTurn = buffer->head == buffer->tail ? 1 : 2;

	// Add to buffer, already know there is enough room (simplifies adding logic)
	uint8_t bufferHeaderPos = 0;
    285a:	4619      	mov	r1, r3
	for ( uint16_t c = 0; c < sendLen; c++ )
    285c:	42ab      	cmp	r3, r5
    285e:	d229      	bcs.n	28b4 <I2C_Send+0x8c>
	{
		// Add data to buffer
		switch ( bufferHeaderPos )
    2860:	b149      	cbz	r1, 2876 <I2C_Send+0x4e>
    2862:	2901      	cmp	r1, #1
    2864:	d110      	bne.n	2888 <I2C_Send+0x60>
			bufferHeaderPos++;
			c--;
			break;

		case 1:
			buffer->buffer[ buffer->tail ] = sendLen;
    2866:	8861      	ldrh	r1, [r4, #2]
    2868:	68a0      	ldr	r0, [r4, #8]
    286a:	b289      	uxth	r1, r1
			bufferHeaderPos++;
			c--;
    286c:	3b01      	subs	r3, #1
			bufferHeaderPos++;
			c--;
			break;

		case 1:
			buffer->buffer[ buffer->tail ] = sendLen;
    286e:	5445      	strb	r5, [r0, r1]
			bufferHeaderPos++;
			c--;
    2870:	b29b      	uxth	r3, r3
			c--;
			break;

		case 1:
			buffer->buffer[ buffer->tail ] = sendLen;
			bufferHeaderPos++;
    2872:	2102      	movs	r1, #2
    2874:	e00e      	b.n	2894 <I2C_Send+0x6c>
	{
		// Add data to buffer
		switch ( bufferHeaderPos )
		{
		case 0:
			buffer->buffer[ buffer->tail ] = recvLen;
    2876:	8861      	ldrh	r1, [r4, #2]
    2878:	68a0      	ldr	r0, [r4, #8]
    287a:	b289      	uxth	r1, r1
			bufferHeaderPos++;
			c--;
    287c:	3b01      	subs	r3, #1
	{
		// Add data to buffer
		switch ( bufferHeaderPos )
		{
		case 0:
			buffer->buffer[ buffer->tail ] = recvLen;
    287e:	f800 9001 	strb.w	r9, [r0, r1]
			bufferHeaderPos++;
			c--;
    2882:	b29b      	uxth	r3, r3
		// Add data to buffer
		switch ( bufferHeaderPos )
		{
		case 0:
			buffer->buffer[ buffer->tail ] = recvLen;
			bufferHeaderPos++;
    2884:	2101      	movs	r1, #1
    2886:	e005      	b.n	2894 <I2C_Send+0x6c>
			bufferHeaderPos++;
			c--;
			break;

		default:
			buffer->buffer[ buffer->tail ] = data[ c ];
    2888:	8860      	ldrh	r0, [r4, #2]
    288a:	f818 7003 	ldrb.w	r7, [r8, r3]
    288e:	68a6      	ldr	r6, [r4, #8]
    2890:	b280      	uxth	r0, r0
    2892:	5437      	strb	r7, [r6, r0]
			break;
		}

		// Check for wrap-around case
		if ( buffer->tail + 1 >= buffer->size )
    2894:	8867      	ldrh	r7, [r4, #2]
    2896:	88e0      	ldrh	r0, [r4, #6]
    2898:	4e18      	ldr	r6, [pc, #96]	; (28fc <I2C_Send+0xd4>)
    289a:	b2bf      	uxth	r7, r7
    289c:	b280      	uxth	r0, r0
    289e:	3701      	adds	r7, #1
    28a0:	4287      	cmp	r7, r0
		{
			buffer->tail = 0;
    28a2:	bfa8      	it	ge
    28a4:	2000      	movge	r0, #0
	// If buffer is clean, return 1, otherwise 2
	reTurn = buffer->head == buffer->tail ? 1 : 2;

	// Add to buffer, already know there is enough room (simplifies adding logic)
	uint8_t bufferHeaderPos = 0;
	for ( uint16_t c = 0; c < sendLen; c++ )
    28a6:	f103 0301 	add.w	r3, r3, #1
		}

		// Check for wrap-around case
		if ( buffer->tail + 1 >= buffer->size )
		{
			buffer->tail = 0;
    28aa:	bfac      	ite	ge
    28ac:	8070      	strhge	r0, [r6, #2]
		}
		// Normal case
		else
		{
			buffer->tail++;
    28ae:	8077      	strhlt	r7, [r6, #2]
	// If buffer is clean, return 1, otherwise 2
	reTurn = buffer->head == buffer->tail ? 1 : 2;

	// Add to buffer, already know there is enough room (simplifies adding logic)
	uint8_t bufferHeaderPos = 0;
	for ( uint16_t c = 0; c < sendLen; c++ )
    28b0:	b29b      	uxth	r3, r3
    28b2:	e7d3      	b.n	285c <I2C_Send+0x34>
{
	// Check head and tail pointers
	// If full, return 0
	// If empty, start up I2C Master Tx
	// If buffer is non-empty and non-full, just append to the buffer
	switch ( I2C_BufferCopy( data, sendLen, recvLen, (I2C_Buffer*)&I2C_TxBuffer ) )
    28b4:	2a01      	cmp	r2, #1
    28b6:	d11d      	bne.n	28f4 <I2C_Send+0xcc>
		return 0;

	// Empty buffer, initialize I2C
	case 1:
		// Clear status flags
		I2C0_S = I2C_S_IICIF | I2C_S_ARBL;
    28b8:	4a11      	ldr	r2, [pc, #68]	; (2900 <I2C_Send+0xd8>)
    28ba:	2312      	movs	r3, #18
    28bc:	7013      	strb	r3, [r2, #0]

		// Check to see if we already have control of the bus
		if ( I2C0_C1 & I2C_C1_MST )
    28be:	4b11      	ldr	r3, [pc, #68]	; (2904 <I2C_Send+0xdc>)
    28c0:	7819      	ldrb	r1, [r3, #0]
    28c2:	f011 0f20 	tst.w	r1, #32
    28c6:	4619      	mov	r1, r3
    28c8:	d002      	beq.n	28d0 <I2C_Send+0xa8>
		{
			// Already the master (ah yeah), send a repeated start
			I2C0_C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_RSTA | I2C_C1_TX;
    28ca:	22b4      	movs	r2, #180	; 0xb4
    28cc:	701a      	strb	r2, [r3, #0]
    28ce:	e004      	b.n	28da <I2C_Send+0xb2>
		}
		// Otherwise, seize control
		else
		{
			// Wait...till the master dies
			while ( I2C0_S & I2C_S_BUSY );
    28d0:	7813      	ldrb	r3, [r2, #0]
    28d2:	069f      	lsls	r7, r3, #26
    28d4:	d4fc      	bmi.n	28d0 <I2C_Send+0xa8>

			// Now we're the master (ah yisss), get ready to send stuffs
			I2C0_C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_TX;
    28d6:	23b0      	movs	r3, #176	; 0xb0
    28d8:	700b      	strb	r3, [r1, #0]
		}

		// Enable I2C interrupt
		I2C0_C1 = I2C_C1_IICEN | I2C_C1_IICIE | I2C_C1_MST | I2C_C1_TX;
    28da:	4b0a      	ldr	r3, [pc, #40]	; (2904 <I2C_Send+0xdc>)
    28dc:	22f0      	movs	r2, #240	; 0xf0
    28de:	701a      	strb	r2, [r3, #0]

		// Depending on what type of transfer, the first byte is configured for R or W
		I2C0_D = I2C_TxBufferPop();
    28e0:	f7ff fec4 	bl	266c <I2C_TxBufferPop>
    28e4:	4b08      	ldr	r3, [pc, #32]	; (2908 <I2C_Send+0xe0>)
    28e6:	7018      	strb	r0, [r3, #0]

		return 1;
    28e8:	2001      	movs	r0, #1
    28ea:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		printHex( sendLen );
		print("|");
		printHex( I2C_TxBuffer.size );
		print( NL );
		*/
		return 0;
    28ee:	2000      	movs	r0, #0
    28f0:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

		return 1;
	}

	// Dirty buffer, I2C already initialized
	return 2;
    28f4:	2002      	movs	r0, #2
}
    28f6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    28fa:	bf00      	nop
    28fc:	1fff899c 	.word	0x1fff899c
    2900:	40066003 	.word	0x40066003
    2904:	40066002 	.word	0x40066002
    2908:	40066004 	.word	0x40066004

0000290c <LED_zeroPages>:
	// Enable I2C Interrupt
	NVIC_ENABLE_IRQ( IRQ_I2C0 );
}

void LED_zeroPages( uint8_t startPage, uint8_t numPages, uint8_t startReg, uint8_t endReg )
{
    290c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    2910:	4698      	mov	r8, r3
	// Page Setup
	uint8_t pageSetup[] = { 0xE8, 0xFD, 0x00 };
    2912:	4b1a      	ldr	r3, [pc, #104]	; (297c <LED_zeroPages+0x70>)
	// Enable I2C Interrupt
	NVIC_ENABLE_IRQ( IRQ_I2C0 );
}

void LED_zeroPages( uint8_t startPage, uint8_t numPages, uint8_t startReg, uint8_t endReg )
{
    2914:	b0b0      	sub	sp, #192	; 0xc0
	// Page Setup
	uint8_t pageSetup[] = { 0xE8, 0xFD, 0x00 };
    2916:	881b      	ldrh	r3, [r3, #0]
	// Enable I2C Interrupt
	NVIC_ENABLE_IRQ( IRQ_I2C0 );
}

void LED_zeroPages( uint8_t startPage, uint8_t numPages, uint8_t startReg, uint8_t endReg )
{
    2918:	4605      	mov	r5, r0
    291a:	4616      	mov	r6, r2
    291c:	460f      	mov	r7, r1
	// Page Setup
	uint8_t pageSetup[] = { 0xE8, 0xFD, 0x00 };

	// Max length of a page + chip id + reg start
	uint8_t fullPage[ 0xB4 + 2 ] = { 0 }; // Max size of page
    291e:	a802      	add	r0, sp, #8
    2920:	2100      	movs	r1, #0
    2922:	22b6      	movs	r2, #182	; 0xb6
}

void LED_zeroPages( uint8_t startPage, uint8_t numPages, uint8_t startReg, uint8_t endReg )
{
	// Page Setup
	uint8_t pageSetup[] = { 0xE8, 0xFD, 0x00 };
    2924:	f8ad 3004 	strh.w	r3, [sp, #4]

	// Max length of a page + chip id + reg start
	uint8_t fullPage[ 0xB4 + 2 ] = { 0 }; // Max size of page
    2928:	f7ff fe20 	bl	256c <memset>
	fullPage[0] = 0xE8;     // Set chip id
    292c:	23e8      	movs	r3, #232	; 0xe8
    292e:	f88d 3008 	strb.w	r3, [sp, #8]
	fullPage[1] = startReg; // Set start reg
    2932:	f88d 6009 	strb.w	r6, [sp, #9]

	// Iterate through given pages, zero'ing out the given register regions
	for ( uint8_t page = startPage; page < startPage + numPages; page++ )
    2936:	462c      	mov	r4, r5
    2938:	19eb      	adds	r3, r5, r7
    293a:	429c      	cmp	r4, r3
    293c:	da1b      	bge.n	2976 <LED_zeroPages+0x6a>
	{
		// Set page
		pageSetup[2] = page;
    293e:	f88d 4006 	strb.w	r4, [sp, #6]

		// Setup page
		while ( I2C_Send( pageSetup, sizeof( pageSetup ), 0 ) == 0 )
    2942:	a801      	add	r0, sp, #4
    2944:	2103      	movs	r1, #3
    2946:	2200      	movs	r2, #0
    2948:	f7ff ff6e 	bl	2828 <I2C_Send>
    294c:	b918      	cbnz	r0, 2956 <LED_zeroPages+0x4a>
			delay(1);
    294e:	2001      	movs	r0, #1
    2950:	f7ff fe40 	bl	25d4 <delay>
    2954:	e7f5      	b.n	2942 <LED_zeroPages+0x36>

		// Zero out page
		while ( I2C_Send( fullPage, endReg - startReg + 2, 0 ) == 0 )
    2956:	f108 0102 	add.w	r1, r8, #2
    295a:	1b89      	subs	r1, r1, r6
    295c:	a802      	add	r0, sp, #8
    295e:	b2c9      	uxtb	r1, r1
    2960:	2200      	movs	r2, #0
    2962:	f7ff ff61 	bl	2828 <I2C_Send>
    2966:	b918      	cbnz	r0, 2970 <LED_zeroPages+0x64>
			delay(1);
    2968:	2001      	movs	r0, #1
    296a:	f7ff fe33 	bl	25d4 <delay>
    296e:	e7f2      	b.n	2956 <LED_zeroPages+0x4a>
	uint8_t fullPage[ 0xB4 + 2 ] = { 0 }; // Max size of page
	fullPage[0] = 0xE8;     // Set chip id
	fullPage[1] = startReg; // Set start reg

	// Iterate through given pages, zero'ing out the given register regions
	for ( uint8_t page = startPage; page < startPage + numPages; page++ )
    2970:	3401      	adds	r4, #1
    2972:	b2e4      	uxtb	r4, r4
    2974:	e7e0      	b.n	2938 <LED_zeroPages+0x2c>

		// Zero out page
		while ( I2C_Send( fullPage, endReg - startReg + 2, 0 ) == 0 )
			delay(1);
	}
}
    2976:	b030      	add	sp, #192	; 0xc0
    2978:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    297c:	00007ae5 	.word	0x00007ae5

00002980 <cliFunc_ledZero>:
	print( NL ); // No \r\n by default after the command is entered
	LED_sendPage( (uint8_t*)LED_defaultBrightness1, sizeof( LED_defaultBrightness1 ), 0 );
}

void cliFunc_ledZero( char* args )
{
    2980:	b510      	push	{r4, lr}
	print( NL ); // No \r\n by default after the command is entered
    2982:	4805      	ldr	r0, [pc, #20]	; (2998 <cliFunc_ledZero+0x18>)
    2984:	f004 ff3e 	bl	7804 <_print>
	LED_zeroPages( 0x00, 8, 0x24, 0xB4 ); // Only PWMs
    2988:	2000      	movs	r0, #0
    298a:	2108      	movs	r1, #8
    298c:	2224      	movs	r2, #36	; 0x24
    298e:	23b4      	movs	r3, #180	; 0xb4
}
    2990:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
}

void cliFunc_ledZero( char* args )
{
	print( NL ); // No \r\n by default after the command is entered
	LED_zeroPages( 0x00, 8, 0x24, 0xB4 ); // Only PWMs
    2994:	f7ff bfba 	b.w	290c <LED_zeroPages>
    2998:	0000bafb 	.word	0x0000bafb

0000299c <LED_sendPage>:
			delay(1);
	}
}

void LED_sendPage( uint8_t *buffer, uint8_t len, uint8_t page )
{
    299c:	b537      	push	{r0, r1, r2, r4, r5, lr}
	// Page Setup
	uint8_t pageSetup[] = { 0xE8, 0xFD, page };
    299e:	23e8      	movs	r3, #232	; 0xe8
    29a0:	f88d 3004 	strb.w	r3, [sp, #4]
    29a4:	23fd      	movs	r3, #253	; 0xfd
			delay(1);
	}
}

void LED_sendPage( uint8_t *buffer, uint8_t len, uint8_t page )
{
    29a6:	4605      	mov	r5, r0
    29a8:	460c      	mov	r4, r1
	// Page Setup
	uint8_t pageSetup[] = { 0xE8, 0xFD, page };
    29aa:	f88d 3005 	strb.w	r3, [sp, #5]
    29ae:	f88d 2006 	strb.w	r2, [sp, #6]

	// Setup page
	while ( I2C_Send( pageSetup, sizeof( pageSetup ), 0 ) == 0 )
    29b2:	a801      	add	r0, sp, #4
    29b4:	2103      	movs	r1, #3
    29b6:	2200      	movs	r2, #0
    29b8:	f7ff ff36 	bl	2828 <I2C_Send>
    29bc:	b918      	cbnz	r0, 29c6 <LED_sendPage+0x2a>
		delay(1);
    29be:	2001      	movs	r0, #1
    29c0:	f7ff fe08 	bl	25d4 <delay>
    29c4:	e7f5      	b.n	29b2 <LED_sendPage+0x16>

	// Write page to I2C Tx Buffer
	while ( I2C_Send( buffer, len, 0 ) == 0 )
    29c6:	4628      	mov	r0, r5
    29c8:	4621      	mov	r1, r4
    29ca:	2200      	movs	r2, #0
    29cc:	f7ff ff2c 	bl	2828 <I2C_Send>
    29d0:	b918      	cbnz	r0, 29da <LED_sendPage+0x3e>
		delay(1);
    29d2:	2001      	movs	r0, #1
    29d4:	f7ff fdfe 	bl	25d4 <delay>
    29d8:	e7f5      	b.n	29c6 <LED_sendPage+0x2a>

}
    29da:	b003      	add	sp, #12
    29dc:	bd30      	pop	{r4, r5, pc}
    29de:	0000      	movs	r0, r0

000029e0 <cliFunc_ledTest>:
	LED_sendPage( (uint8_t*)LED_ledEnableMask1, sizeof( LED_ledEnableMask1 ), 0 );

}

void cliFunc_ledTest( char* args )
{
    29e0:	b508      	push	{r3, lr}
	print( NL ); // No \r\n by default after the command is entered
    29e2:	4805      	ldr	r0, [pc, #20]	; (29f8 <cliFunc_ledTest+0x18>)
    29e4:	f004 ff0e 	bl	7804 <_print>
	LED_sendPage( (uint8_t*)LED_defaultBrightness1, sizeof( LED_defaultBrightness1 ), 0 );
    29e8:	4804      	ldr	r0, [pc, #16]	; (29fc <cliFunc_ledTest+0x1c>)
    29ea:	2192      	movs	r1, #146	; 0x92
    29ec:	2200      	movs	r2, #0
}
    29ee:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
}

void cliFunc_ledTest( char* args )
{
	print( NL ); // No \r\n by default after the command is entered
	LED_sendPage( (uint8_t*)LED_defaultBrightness1, sizeof( LED_defaultBrightness1 ), 0 );
    29f2:	f7ff bfd3 	b.w	299c <LED_sendPage>
    29f6:	bf00      	nop
    29f8:	0000bafb 	.word	0x0000bafb
    29fc:	00007e13 	.word	0x00007e13

00002a00 <LED_writeReg>:
		delay(1);

}

void LED_writeReg( uint8_t reg, uint8_t val, uint8_t page )
{
    2a00:	b513      	push	{r0, r1, r4, lr}
	// Page Setup
	uint8_t pageSetup[] = { 0xE8, 0xFD, page };
    2a02:	23e8      	movs	r3, #232	; 0xe8
    2a04:	24fd      	movs	r4, #253	; 0xfd
    2a06:	f88d 3000 	strb.w	r3, [sp]
    2a0a:	f88d 4001 	strb.w	r4, [sp, #1]
    2a0e:	f88d 2002 	strb.w	r2, [sp, #2]

	// Reg Write Setup
	uint8_t writeData[] = { 0xE8, reg, val };
    2a12:	f88d 3004 	strb.w	r3, [sp, #4]
    2a16:	f88d 0005 	strb.w	r0, [sp, #5]
    2a1a:	f88d 1006 	strb.w	r1, [sp, #6]

	// Setup page
	while ( I2C_Send( pageSetup, sizeof( pageSetup ), 0 ) == 0 )
    2a1e:	4668      	mov	r0, sp
    2a20:	2103      	movs	r1, #3
    2a22:	2200      	movs	r2, #0
    2a24:	f7ff ff00 	bl	2828 <I2C_Send>
    2a28:	b918      	cbnz	r0, 2a32 <LED_writeReg+0x32>
		delay(1);
    2a2a:	2001      	movs	r0, #1
    2a2c:	f7ff fdd2 	bl	25d4 <delay>
    2a30:	e7f5      	b.n	2a1e <LED_writeReg+0x1e>

	while ( I2C_Send( writeData, sizeof( writeData ), 0 ) == 0 )
    2a32:	a801      	add	r0, sp, #4
    2a34:	2103      	movs	r1, #3
    2a36:	2200      	movs	r2, #0
    2a38:	f7ff fef6 	bl	2828 <I2C_Send>
    2a3c:	b918      	cbnz	r0, 2a46 <LED_writeReg+0x46>
		delay(1);
    2a3e:	2001      	movs	r0, #1
    2a40:	f7ff fdc8 	bl	25d4 <delay>
    2a44:	e7f5      	b.n	2a32 <LED_writeReg+0x32>
}
    2a46:	b002      	add	sp, #8
    2a48:	bd10      	pop	{r4, pc}
    2a4a:	0000      	movs	r0, r0

00002a4c <LED_setup>:
	LED_writeReg( 0x0A, 0x01, 0x0B );
}

// Setup
inline void LED_setup()
{
    2a4c:	b508      	push	{r3, lr}
	// Register Scan CLI dictionary
	CLI_registerDictionary( ledCLIDict, ledCLIDictName );
    2a4e:	4823      	ldr	r0, [pc, #140]	; (2adc <LED_setup+0x90>)
    2a50:	4923      	ldr	r1, [pc, #140]	; (2ae0 <LED_setup+0x94>)
    2a52:	f004 fc99 	bl	7388 <CLI_registerDictionary>
// ----- Functions -----

inline void I2C_setup()
{
	// Enable I2C internal clock
	SIM_SCGC4 |= SIM_SCGC4_I2C0; // Bus 0
    2a56:	4b23      	ldr	r3, [pc, #140]	; (2ae4 <LED_setup+0x98>)
    2a58:	681a      	ldr	r2, [r3, #0]
    2a5a:	f042 0240 	orr.w	r2, r2, #64	; 0x40
    2a5e:	601a      	str	r2, [r3, #0]

	// External pull-up resistor
	PORTB_PCR0 = PORT_PCR_ODE | PORT_PCR_SRE | PORT_PCR_DSE | PORT_PCR_MUX(2);
    2a60:	4a21      	ldr	r2, [pc, #132]	; (2ae8 <LED_setup+0x9c>)
    2a62:	f44f 7319 	mov.w	r3, #612	; 0x264
    2a66:	6013      	str	r3, [r2, #0]
	PORTB_PCR1 = PORT_PCR_ODE | PORT_PCR_SRE | PORT_PCR_DSE | PORT_PCR_MUX(2);
    2a68:	6053      	str	r3, [r2, #4]

	// SCL Frequency Divider
	// 400kHz -> 120 (0x85) @ 48 MHz F_BUS
	I2C0_F = 0x85;
    2a6a:	4b20      	ldr	r3, [pc, #128]	; (2aec <LED_setup+0xa0>)
    2a6c:	2285      	movs	r2, #133	; 0x85
    2a6e:	701a      	strb	r2, [r3, #0]
	I2C0_FLT = 4;
    2a70:	2204      	movs	r2, #4
    2a72:	715a      	strb	r2, [r3, #5]
	I2C0_C1 = I2C_C1_IICEN;
    2a74:	2280      	movs	r2, #128	; 0x80
    2a76:	705a      	strb	r2, [r3, #1]
	I2C0_C2 = I2C_C2_HDRS; // High drive select
    2a78:	2220      	movs	r2, #32
    2a7a:	711a      	strb	r2, [r3, #4]

	// Enable I2C Interrupt
	NVIC_ENABLE_IRQ( IRQ_I2C0 );
    2a7c:	4b1c      	ldr	r3, [pc, #112]	; (2af0 <LED_setup+0xa4>)
    2a7e:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
    2a82:	601a      	str	r2, [r3, #0]
	// Initialize I2C
	I2C_setup();

	// Zero out Frame Registers
	// This needs to be done before disabling the hardware shutdown (or the leds will do undefined things)
	LED_zeroPages( 0x0B, 1, 0x00, 0x0C ); // Control Registers
    2a84:	200b      	movs	r0, #11
    2a86:	2101      	movs	r1, #1
    2a88:	2200      	movs	r2, #0
    2a8a:	230c      	movs	r3, #12
    2a8c:	f7ff ff3e 	bl	290c <LED_zeroPages>

	// Disable Hardware shutdown of ISSI chip (pull high)
	GPIOB_PDDR |= (1<<16);
    2a90:	4b18      	ldr	r3, [pc, #96]	; (2af4 <LED_setup+0xa8>)
    2a92:	681a      	ldr	r2, [r3, #0]
    2a94:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
    2a98:	601a      	str	r2, [r3, #0]
	PORTB_PCR16 = PORT_PCR_SRE | PORT_PCR_DSE | PORT_PCR_MUX(1);
    2a9a:	4b17      	ldr	r3, [pc, #92]	; (2af8 <LED_setup+0xac>)
    2a9c:	f44f 72a2 	mov.w	r2, #324	; 0x144
    2aa0:	601a      	str	r2, [r3, #0]
	GPIOB_PSOR |= (1<<16);
    2aa2:	4b16      	ldr	r3, [pc, #88]	; (2afc <LED_setup+0xb0>)
    2aa4:	681a      	ldr	r2, [r3, #0]

	// Clear LED Pages
	LED_zeroPages( 0x00, 8, 0x00, 0xB4 ); // LED Registers
    2aa6:	2000      	movs	r0, #0
	LED_zeroPages( 0x0B, 1, 0x00, 0x0C ); // Control Registers

	// Disable Hardware shutdown of ISSI chip (pull high)
	GPIOB_PDDR |= (1<<16);
	PORTB_PCR16 = PORT_PCR_SRE | PORT_PCR_DSE | PORT_PCR_MUX(1);
	GPIOB_PSOR |= (1<<16);
    2aa8:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
    2aac:	601a      	str	r2, [r3, #0]

	// Clear LED Pages
	LED_zeroPages( 0x00, 8, 0x00, 0xB4 ); // LED Registers
    2aae:	2108      	movs	r1, #8
    2ab0:	23b4      	movs	r3, #180	; 0xb4
    2ab2:	4602      	mov	r2, r0
    2ab4:	f7ff ff2a 	bl	290c <LED_zeroPages>

	// Enable LEDs based upon mask
	LED_sendPage( (uint8_t*)LED_ledEnableMask1, sizeof( LED_ledEnableMask1 ), 0 );
    2ab8:	4811      	ldr	r0, [pc, #68]	; (2b00 <LED_setup+0xb4>)
    2aba:	2114      	movs	r1, #20
    2abc:	2200      	movs	r2, #0
    2abe:	f7ff ff6d 	bl	299c <LED_sendPage>

	// Set default brightness
	LED_sendPage( (uint8_t*)LED_defaultBrightness1, sizeof( LED_defaultBrightness1 ), 0 );
    2ac2:	4810      	ldr	r0, [pc, #64]	; (2b04 <LED_setup+0xb8>)
    2ac4:	2192      	movs	r1, #146	; 0x92
    2ac6:	2200      	movs	r2, #0
    2ac8:	f7ff ff68 	bl	299c <LED_sendPage>

	// Disable Software shutdown of ISSI chip
	LED_writeReg( 0x0A, 0x01, 0x0B );
    2acc:	200a      	movs	r0, #10
    2ace:	2101      	movs	r1, #1
    2ad0:	220b      	movs	r2, #11
}
    2ad2:	e8bd 4008 	ldmia.w	sp!, {r3, lr}

	// Set default brightness
	LED_sendPage( (uint8_t*)LED_defaultBrightness1, sizeof( LED_defaultBrightness1 ), 0 );

	// Disable Software shutdown of ISSI chip
	LED_writeReg( 0x0A, 0x01, 0x0B );
    2ad6:	f7ff bf93 	b.w	2a00 <LED_writeReg>
    2ada:	bf00      	nop
    2adc:	00007b4c 	.word	0x00007b4c
    2ae0:	00007fa7 	.word	0x00007fa7
    2ae4:	40048034 	.word	0x40048034
    2ae8:	4004a000 	.word	0x4004a000
    2aec:	40066001 	.word	0x40066001
    2af0:	e000e100 	.word	0xe000e100
    2af4:	400ff054 	.word	0x400ff054
    2af8:	4004a040 	.word	0x4004a040
    2afc:	400ff044 	.word	0x400ff044
    2b00:	00007f93 	.word	0x00007f93
    2b04:	00007e13 	.word	0x00007e13

00002b08 <cliFunc_ledStart>:
		data[1]++;
	}
}

void cliFunc_ledStart( char* args )
{
    2b08:	b508      	push	{r3, lr}
	print( NL ); // No \r\n by default after the command is entered
    2b0a:	480a      	ldr	r0, [pc, #40]	; (2b34 <cliFunc_ledStart+0x2c>)
    2b0c:	f004 fe7a 	bl	7804 <_print>
	LED_zeroPages( 0x0B, 1, 0x00, 0x0C ); // Control Registers
    2b10:	230c      	movs	r3, #12
    2b12:	200b      	movs	r0, #11
    2b14:	2101      	movs	r1, #1
    2b16:	2200      	movs	r2, #0
    2b18:	f7ff fef8 	bl	290c <LED_zeroPages>
	//LED_zeroPages( 0x00, 8, 0x00, 0xB4 ); // LED Registers
	LED_writeReg( 0x0A, 0x01, 0x0B );
    2b1c:	200a      	movs	r0, #10
    2b1e:	2101      	movs	r1, #1
    2b20:	220b      	movs	r2, #11
    2b22:	f7ff ff6d 	bl	2a00 <LED_writeReg>
	LED_sendPage( (uint8_t*)LED_ledEnableMask1, sizeof( LED_ledEnableMask1 ), 0 );
    2b26:	4804      	ldr	r0, [pc, #16]	; (2b38 <cliFunc_ledStart+0x30>)
    2b28:	2114      	movs	r1, #20
    2b2a:	2200      	movs	r2, #0

}
    2b2c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
{
	print( NL ); // No \r\n by default after the command is entered
	LED_zeroPages( 0x0B, 1, 0x00, 0x0C ); // Control Registers
	//LED_zeroPages( 0x00, 8, 0x00, 0xB4 ); // LED Registers
	LED_writeReg( 0x0A, 0x01, 0x0B );
	LED_sendPage( (uint8_t*)LED_ledEnableMask1, sizeof( LED_ledEnableMask1 ), 0 );
    2b30:	f7ff bf34 	b.w	299c <LED_sendPage>
    2b34:	0000bafb 	.word	0x0000bafb
    2b38:	00007f93 	.word	0x00007f93

00002b3c <LED_readPage>:
	while ( I2C_Send( writeData, sizeof( writeData ), 0 ) == 0 )
		delay(1);
}

void LED_readPage( uint8_t len, uint8_t page )
{
    2b3c:	b530      	push	{r4, r5, lr}
	// Software shutdown must be enabled to read registers
	LED_writeReg( 0x0A, 0x00, 0x0B );
    2b3e:	220b      	movs	r2, #11
	while ( I2C_Send( writeData, sizeof( writeData ), 0 ) == 0 )
		delay(1);
}

void LED_readPage( uint8_t len, uint8_t page )
{
    2b40:	b085      	sub	sp, #20
    2b42:	460c      	mov	r4, r1
    2b44:	4605      	mov	r5, r0
	// Software shutdown must be enabled to read registers
	LED_writeReg( 0x0A, 0x00, 0x0B );
    2b46:	2100      	movs	r1, #0
    2b48:	200a      	movs	r0, #10
    2b4a:	f7ff ff59 	bl	2a00 <LED_writeReg>

	// Page Setup
	uint8_t pageSetup[] = { 0xE8, 0xFD, page };
    2b4e:	23e8      	movs	r3, #232	; 0xe8
    2b50:	f88d 300c 	strb.w	r3, [sp, #12]
    2b54:	23fd      	movs	r3, #253	; 0xfd
    2b56:	f88d 300d 	strb.w	r3, [sp, #13]
    2b5a:	f88d 400e 	strb.w	r4, [sp, #14]

	// Setup page
	while ( I2C_Send( pageSetup, sizeof( pageSetup ), 0 ) == 0 )
    2b5e:	a803      	add	r0, sp, #12
    2b60:	2103      	movs	r1, #3
    2b62:	2200      	movs	r2, #0
    2b64:	f7ff fe60 	bl	2828 <I2C_Send>
    2b68:	b918      	cbnz	r0, 2b72 <LED_readPage+0x36>
		delay(1);
    2b6a:	2001      	movs	r0, #1
    2b6c:	f7ff fd32 	bl	25d4 <delay>
    2b70:	e7f5      	b.n	2b5e <LED_readPage+0x22>

	// Register Setup
	uint8_t regSetup[] = { 0xE8, 0x00 };
    2b72:	23e8      	movs	r3, #232	; 0xe8
    2b74:	2400      	movs	r4, #0
    2b76:	f88d 3008 	strb.w	r3, [sp, #8]
    2b7a:	f88d 4009 	strb.w	r4, [sp, #9]

	// Read each register in the page
	for ( uint8_t reg = 0; reg < len; reg++ )
    2b7e:	42ac      	cmp	r4, r5
    2b80:	d01e      	beq.n	2bc0 <LED_readPage+0x84>
	{
		// Update register to read
		regSetup[1] = reg;
    2b82:	f88d 4009 	strb.w	r4, [sp, #9]

		// Configure register
		while ( I2C_Send( regSetup, sizeof( regSetup ), 0 ) == 0 )
    2b86:	a802      	add	r0, sp, #8
    2b88:	2102      	movs	r1, #2
    2b8a:	2200      	movs	r2, #0
    2b8c:	f7ff fe4c 	bl	2828 <I2C_Send>
    2b90:	b918      	cbnz	r0, 2b9a <LED_readPage+0x5e>
			delay(1);
    2b92:	2001      	movs	r0, #1
    2b94:	f7ff fd1e 	bl	25d4 <delay>
    2b98:	e7f5      	b.n	2b86 <LED_readPage+0x4a>

		// Register Read Command
		uint8_t regReadCmd[] = { 0xE9 };
    2b9a:	23e9      	movs	r3, #233	; 0xe9
    2b9c:	f88d 3004 	strb.w	r3, [sp, #4]

		// Request single register byte
		while ( I2C_Send( regReadCmd, sizeof( regReadCmd ), 1 ) == 0 )
    2ba0:	2101      	movs	r1, #1
    2ba2:	a801      	add	r0, sp, #4
    2ba4:	460a      	mov	r2, r1
    2ba6:	f7ff fe3f 	bl	2828 <I2C_Send>
    2baa:	b918      	cbnz	r0, 2bb4 <LED_readPage+0x78>
			delay(1);
    2bac:	2001      	movs	r0, #1
    2bae:	f7ff fd11 	bl	25d4 <delay>
    2bb2:	e7f5      	b.n	2ba0 <LED_readPage+0x64>
		dbug_print("NEXT");
    2bb4:	4806      	ldr	r0, [pc, #24]	; (2bd0 <LED_readPage+0x94>)

	// Register Setup
	uint8_t regSetup[] = { 0xE8, 0x00 };

	// Read each register in the page
	for ( uint8_t reg = 0; reg < len; reg++ )
    2bb6:	3401      	adds	r4, #1
		uint8_t regReadCmd[] = { 0xE9 };

		// Request single register byte
		while ( I2C_Send( regReadCmd, sizeof( regReadCmd ), 1 ) == 0 )
			delay(1);
		dbug_print("NEXT");
    2bb8:	f004 fe24 	bl	7804 <_print>

	// Register Setup
	uint8_t regSetup[] = { 0xE8, 0x00 };

	// Read each register in the page
	for ( uint8_t reg = 0; reg < len; reg++ )
    2bbc:	b2e4      	uxtb	r4, r4
    2bbe:	e7de      	b.n	2b7e <LED_readPage+0x42>
			delay(1);
		dbug_print("NEXT");
	}

	// Disable software shutdown
	LED_writeReg( 0x0A, 0x01, 0x0B );
    2bc0:	200a      	movs	r0, #10
    2bc2:	2101      	movs	r1, #1
    2bc4:	220b      	movs	r2, #11
    2bc6:	f7ff ff1b 	bl	2a00 <LED_writeReg>
}
    2bca:	b005      	add	sp, #20
    2bcc:	bd30      	pop	{r4, r5, pc}
    2bce:	bf00      	nop
    2bd0:	00007d3a 	.word	0x00007d3a

00002bd4 <cliFunc_ledRPage>:
	I2C_Send( buffer, bufferLen, 1 ); // Only 1 byte is ever read at a time with the ISSI chip
}

// TODO Currently not working correctly
void cliFunc_ledRPage( char* args )
{
    2bd4:	b513      	push	{r0, r1, r4, lr}
	// Parse number from argument
	//  NOTE: Only first argument is used
	char* arg1Ptr;
	char* arg2Ptr;
	CLI_argumentIsolation( args, &arg1Ptr, &arg2Ptr );
    2bd6:	4669      	mov	r1, sp
    2bd8:	aa01      	add	r2, sp, #4
    2bda:	f004 fb61 	bl	72a0 <CLI_argumentIsolation>

	// Default to 0 if no argument is given
	uint8_t page = 0;

	if ( arg1Ptr[0] != '\0' )
    2bde:	9800      	ldr	r0, [sp, #0]
    2be0:	7804      	ldrb	r4, [r0, #0]
    2be2:	b114      	cbz	r4, 2bea <cliFunc_ledRPage+0x16>
	{
		page = (uint8_t)numToInt( arg1Ptr );
    2be4:	f004 feec 	bl	79c0 <numToInt>
    2be8:	b2c4      	uxtb	r4, r0
	}

	// No \r\n by default after the command is entered
	print( NL );
    2bea:	4804      	ldr	r0, [pc, #16]	; (2bfc <cliFunc_ledRPage+0x28>)
    2bec:	f004 fe0a 	bl	7804 <_print>

	LED_readPage( 0x1, page );
    2bf0:	2001      	movs	r0, #1
    2bf2:	4621      	mov	r1, r4
    2bf4:	f7ff ffa2 	bl	2b3c <LED_readPage>
	//LED_readPage( 0xB4, page );
}
    2bf8:	b002      	add	sp, #8
    2bfa:	bd10      	pop	{r4, pc}
    2bfc:	0000bafb 	.word	0x0000bafb

00002c00 <cliFunc_i2cSend>:

// ----- CLI Command Functions -----

// TODO Currently not working correctly
void cliFunc_i2cSend( char* args )
{
    2c00:	b530      	push	{r4, r5, lr}
    2c02:	b085      	sub	sp, #20

	// Buffer used after interpretting the args, will be sent to I2C functions
	// NOTE: Limited to 8 bytes currently (can be increased if necessary
	#define i2cSend_BuffLenMax 8
	uint8_t buffer[ i2cSend_BuffLenMax ];
	uint8_t bufferLen = 0;
    2c04:	2400      	movs	r4, #0
// TODO Currently not working correctly
void cliFunc_i2cSend( char* args )
{
	char* curArgs;
	char* arg1Ptr;
	char* arg2Ptr = args;
    2c06:	9001      	str	r0, [sp, #4]
	#define i2cSend_BuffLenMax 8
	uint8_t buffer[ i2cSend_BuffLenMax ];
	uint8_t bufferLen = 0;

	// No \r\n by default after the command is entered
	print( NL );
    2c08:	481b      	ldr	r0, [pc, #108]	; (2c78 <cliFunc_i2cSend+0x78>)
    2c0a:	f004 fdfb 	bl	7804 <_print>
	info_msg("Sending: ");
    2c0e:	481b      	ldr	r0, [pc, #108]	; (2c7c <cliFunc_i2cSend+0x7c>)
    2c10:	f004 fdf8 	bl	7804 <_print>

	// Parse args until a \0 is found
	while ( bufferLen < i2cSend_BuffLenMax )
	{
		curArgs = arg2Ptr; // Use the previous 2nd arg pointer to separate the next arg from the list
		CLI_argumentIsolation( curArgs, &arg1Ptr, &arg2Ptr );
    2c14:	9801      	ldr	r0, [sp, #4]
    2c16:	4669      	mov	r1, sp
    2c18:	aa01      	add	r2, sp, #4
    2c1a:	f004 fb41 	bl	72a0 <CLI_argumentIsolation>

		// Stop processing args if no more are found
		if ( *arg1Ptr == '\0' )
    2c1e:	9800      	ldr	r0, [sp, #0]
    2c20:	7803      	ldrb	r3, [r0, #0]
    2c22:	b1eb      	cbz	r3, 2c60 <cliFunc_i2cSend+0x60>
			break;

		// If | is found, end sequence and start new one
		if ( *arg1Ptr == '|' )
    2c24:	2b7c      	cmp	r3, #124	; 0x7c
    2c26:	d10a      	bne.n	2c3e <cliFunc_i2cSend+0x3e>
		{
			print("| ");
    2c28:	4815      	ldr	r0, [pc, #84]	; (2c80 <cliFunc_i2cSend+0x80>)
    2c2a:	f004 fdeb 	bl	7804 <_print>
			I2C_Send( buffer, bufferLen, 0 );
    2c2e:	a802      	add	r0, sp, #8
    2c30:	4621      	mov	r1, r4
    2c32:	2200      	movs	r2, #0
    2c34:	f7ff fdf8 	bl	2828 <I2C_Send>
			bufferLen = 0;
    2c38:	2500      	movs	r5, #0
    2c3a:	462c      	mov	r4, r5
    2c3c:	e7ea      	b.n	2c14 <cliFunc_i2cSend+0x14>
			continue;
		}

		// Interpret the argument
		buffer[ bufferLen++ ] = (uint8_t)numToInt( arg1Ptr );
    2c3e:	f004 febf 	bl	79c0 <numToInt>
    2c42:	ab04      	add	r3, sp, #16
    2c44:	1c65      	adds	r5, r4, #1
    2c46:	441c      	add	r4, r3
    2c48:	b2ed      	uxtb	r5, r5
    2c4a:	f804 0c08 	strb.w	r0, [r4, #-8]

		// Print out the arg
		dPrint( arg1Ptr );
    2c4e:	9800      	ldr	r0, [sp, #0]
    2c50:	f003 fada 	bl	6208 <Output_putstr>
		print(" ");
    2c54:	480b      	ldr	r0, [pc, #44]	; (2c84 <cliFunc_i2cSend+0x84>)
    2c56:	f004 fdd5 	bl	7804 <_print>
	// No \r\n by default after the command is entered
	print( NL );
	info_msg("Sending: ");

	// Parse args until a \0 is found
	while ( bufferLen < i2cSend_BuffLenMax )
    2c5a:	2d07      	cmp	r5, #7
    2c5c:	d9ed      	bls.n	2c3a <cliFunc_i2cSend+0x3a>
    2c5e:	e000      	b.n	2c62 <cliFunc_i2cSend+0x62>
    2c60:	4625      	mov	r5, r4
		// Print out the arg
		dPrint( arg1Ptr );
		print(" ");
	}

	print( NL );
    2c62:	4805      	ldr	r0, [pc, #20]	; (2c78 <cliFunc_i2cSend+0x78>)
    2c64:	f004 fdce 	bl	7804 <_print>

	I2C_Send( buffer, bufferLen, 0 );
    2c68:	a802      	add	r0, sp, #8
    2c6a:	4629      	mov	r1, r5
    2c6c:	2200      	movs	r2, #0
    2c6e:	f7ff fddb 	bl	2828 <I2C_Send>
}
    2c72:	b005      	add	sp, #20
    2c74:	bd30      	pop	{r4, r5, pc}
    2c76:	bf00      	nop
    2c78:	0000bafb 	.word	0x0000bafb
    2c7c:	00007d54 	.word	0x00007d54
    2c80:	00007d70 	.word	0x00007d70
    2c84:	00008156 	.word	0x00008156

00002c88 <cliFunc_i2cRecv>:

void cliFunc_i2cRecv( char* args )
{
    2c88:	b530      	push	{r4, r5, lr}
    2c8a:	b085      	sub	sp, #20

	// Buffer used after interpretting the args, will be sent to I2C functions
	// NOTE: Limited to 8 bytes currently (can be increased if necessary
	#define i2cSend_BuffLenMax 8
	uint8_t buffer[ i2cSend_BuffLenMax ];
	uint8_t bufferLen = 0;
    2c8c:	2400      	movs	r4, #0

void cliFunc_i2cRecv( char* args )
{
	char* curArgs;
	char* arg1Ptr;
	char* arg2Ptr = args;
    2c8e:	9001      	str	r0, [sp, #4]
	#define i2cSend_BuffLenMax 8
	uint8_t buffer[ i2cSend_BuffLenMax ];
	uint8_t bufferLen = 0;

	// No \r\n by default after the command is entered
	print( NL );
    2c90:	481b      	ldr	r0, [pc, #108]	; (2d00 <cliFunc_i2cRecv+0x78>)
    2c92:	f004 fdb7 	bl	7804 <_print>
	info_msg("Sending: ");
    2c96:	481b      	ldr	r0, [pc, #108]	; (2d04 <cliFunc_i2cRecv+0x7c>)
    2c98:	f004 fdb4 	bl	7804 <_print>

	// Parse args until a \0 is found
	while ( bufferLen < i2cSend_BuffLenMax )
	{
		curArgs = arg2Ptr; // Use the previous 2nd arg pointer to separate the next arg from the list
		CLI_argumentIsolation( curArgs, &arg1Ptr, &arg2Ptr );
    2c9c:	9801      	ldr	r0, [sp, #4]
    2c9e:	4669      	mov	r1, sp
    2ca0:	aa01      	add	r2, sp, #4
    2ca2:	f004 fafd 	bl	72a0 <CLI_argumentIsolation>

		// Stop processing args if no more are found
		if ( *arg1Ptr == '\0' )
    2ca6:	9800      	ldr	r0, [sp, #0]
    2ca8:	7803      	ldrb	r3, [r0, #0]
    2caa:	b1eb      	cbz	r3, 2ce8 <cliFunc_i2cRecv+0x60>
			break;

		// If | is found, end sequence and start new one
		if ( *arg1Ptr == '|' )
    2cac:	2b7c      	cmp	r3, #124	; 0x7c
    2cae:	d10a      	bne.n	2cc6 <cliFunc_i2cRecv+0x3e>
		{
			print("| ");
    2cb0:	4815      	ldr	r0, [pc, #84]	; (2d08 <cliFunc_i2cRecv+0x80>)
    2cb2:	f004 fda7 	bl	7804 <_print>
			I2C_Send( buffer, bufferLen, 0 );
    2cb6:	a802      	add	r0, sp, #8
    2cb8:	4621      	mov	r1, r4
    2cba:	2200      	movs	r2, #0
    2cbc:	f7ff fdb4 	bl	2828 <I2C_Send>
			bufferLen = 0;
    2cc0:	2500      	movs	r5, #0
    2cc2:	462c      	mov	r4, r5
    2cc4:	e7ea      	b.n	2c9c <cliFunc_i2cRecv+0x14>
			continue;
		}

		// Interpret the argument
		buffer[ bufferLen++ ] = (uint8_t)numToInt( arg1Ptr );
    2cc6:	f004 fe7b 	bl	79c0 <numToInt>
    2cca:	ab04      	add	r3, sp, #16
    2ccc:	1c65      	adds	r5, r4, #1
    2cce:	441c      	add	r4, r3
    2cd0:	b2ed      	uxtb	r5, r5
    2cd2:	f804 0c08 	strb.w	r0, [r4, #-8]

		// Print out the arg
		dPrint( arg1Ptr );
    2cd6:	9800      	ldr	r0, [sp, #0]
    2cd8:	f003 fa96 	bl	6208 <Output_putstr>
		print(" ");
    2cdc:	480b      	ldr	r0, [pc, #44]	; (2d0c <cliFunc_i2cRecv+0x84>)
    2cde:	f004 fd91 	bl	7804 <_print>
	// No \r\n by default after the command is entered
	print( NL );
	info_msg("Sending: ");

	// Parse args until a \0 is found
	while ( bufferLen < i2cSend_BuffLenMax )
    2ce2:	2d07      	cmp	r5, #7
    2ce4:	d9ed      	bls.n	2cc2 <cliFunc_i2cRecv+0x3a>
    2ce6:	e000      	b.n	2cea <cliFunc_i2cRecv+0x62>
    2ce8:	4625      	mov	r5, r4
		// Print out the arg
		dPrint( arg1Ptr );
		print(" ");
	}

	print( NL );
    2cea:	4805      	ldr	r0, [pc, #20]	; (2d00 <cliFunc_i2cRecv+0x78>)
    2cec:	f004 fd8a 	bl	7804 <_print>

	I2C_Send( buffer, bufferLen, 1 ); // Only 1 byte is ever read at a time with the ISSI chip
    2cf0:	a802      	add	r0, sp, #8
    2cf2:	4629      	mov	r1, r5
    2cf4:	2201      	movs	r2, #1
    2cf6:	f7ff fd97 	bl	2828 <I2C_Send>
}
    2cfa:	b005      	add	sp, #20
    2cfc:	bd30      	pop	{r4, r5, pc}
    2cfe:	bf00      	nop
    2d00:	0000bafb 	.word	0x0000bafb
    2d04:	00007d54 	.word	0x00007d54
    2d08:	00007d70 	.word	0x00007d70
    2d0c:	00008156 	.word	0x00008156

00002d10 <cliFunc_ledWPage>:
	LED_readPage( 0x1, page );
	//LED_readPage( 0xB4, page );
}

void cliFunc_ledWPage( char* args )
{
    2d10:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	char* arg1Ptr;
	char* arg2Ptr = args;

	// First process page and starting address
	curArgs = arg2Ptr;
	CLI_argumentIsolation( curArgs, &arg1Ptr, &arg2Ptr );
    2d12:	a902      	add	r1, sp, #8
    2d14:	aa03      	add	r2, sp, #12

void cliFunc_ledWPage( char* args )
{
	char* curArgs;
	char* arg1Ptr;
	char* arg2Ptr = args;
    2d16:	9003      	str	r0, [sp, #12]

	// First process page and starting address
	curArgs = arg2Ptr;
	CLI_argumentIsolation( curArgs, &arg1Ptr, &arg2Ptr );
    2d18:	f004 fac2 	bl	72a0 <CLI_argumentIsolation>

	// Stop processing args if no more are found
	if ( *arg1Ptr == '\0' )
    2d1c:	9802      	ldr	r0, [sp, #8]
    2d1e:	7803      	ldrb	r3, [r0, #0]
    2d20:	2b00      	cmp	r3, #0
    2d22:	d040      	beq.n	2da6 <cliFunc_ledWPage+0x96>
		return;
	uint8_t page[] = { 0xE8, 0xFD, numToInt( arg1Ptr ) };
    2d24:	23fd      	movs	r3, #253	; 0xfd
    2d26:	24e8      	movs	r4, #232	; 0xe8
    2d28:	f88d 3001 	strb.w	r3, [sp, #1]
    2d2c:	f88d 4000 	strb.w	r4, [sp]
    2d30:	f004 fe46 	bl	79c0 <numToInt>

	curArgs = arg2Ptr;
	CLI_argumentIsolation( curArgs, &arg1Ptr, &arg2Ptr );
    2d34:	a902      	add	r1, sp, #8
	CLI_argumentIsolation( curArgs, &arg1Ptr, &arg2Ptr );

	// Stop processing args if no more are found
	if ( *arg1Ptr == '\0' )
		return;
	uint8_t page[] = { 0xE8, 0xFD, numToInt( arg1Ptr ) };
    2d36:	f88d 0002 	strb.w	r0, [sp, #2]

	curArgs = arg2Ptr;
	CLI_argumentIsolation( curArgs, &arg1Ptr, &arg2Ptr );
    2d3a:	aa03      	add	r2, sp, #12
    2d3c:	9803      	ldr	r0, [sp, #12]
    2d3e:	f004 faaf 	bl	72a0 <CLI_argumentIsolation>

	// Stop processing args if no more are found
	if ( *arg1Ptr == '\0' )
    2d42:	9802      	ldr	r0, [sp, #8]
    2d44:	7803      	ldrb	r3, [r0, #0]
    2d46:	b373      	cbz	r3, 2da6 <cliFunc_ledWPage+0x96>
		return;
	uint8_t data[] = { 0xE8, numToInt( arg1Ptr ), 0 };
    2d48:	f88d 4004 	strb.w	r4, [sp, #4]
    2d4c:	f004 fe38 	bl	79c0 <numToInt>
    2d50:	2300      	movs	r3, #0
    2d52:	f88d 0005 	strb.w	r0, [sp, #5]
    2d56:	f88d 3006 	strb.w	r3, [sp, #6]

	// Set the register page
	while ( I2C_Send( page, sizeof( page ), 0 ) == 0 )
    2d5a:	4668      	mov	r0, sp
    2d5c:	2103      	movs	r1, #3
    2d5e:	2200      	movs	r2, #0
    2d60:	f7ff fd62 	bl	2828 <I2C_Send>
    2d64:	b940      	cbnz	r0, 2d78 <cliFunc_ledWPage+0x68>
		delay(1);
    2d66:	2001      	movs	r0, #1
    2d68:	f7ff fc34 	bl	25d4 <delay>
    2d6c:	e7f5      	b.n	2d5a <cliFunc_ledWPage+0x4a>
		// Write register location and data to I2C
		while ( I2C_Send( data, sizeof( data ), 0 ) == 0 )
			delay(1);

		// Increment address
		data[1]++;
    2d6e:	f89d 3005 	ldrb.w	r3, [sp, #5]
    2d72:	3301      	adds	r3, #1
    2d74:	f88d 3005 	strb.w	r3, [sp, #5]

	// Process all args
	for ( ;; )
	{
		curArgs = arg2Ptr;
		CLI_argumentIsolation( curArgs, &arg1Ptr, &arg2Ptr );
    2d78:	9803      	ldr	r0, [sp, #12]
    2d7a:	a902      	add	r1, sp, #8
    2d7c:	aa03      	add	r2, sp, #12
    2d7e:	f004 fa8f 	bl	72a0 <CLI_argumentIsolation>

		// Stop processing args if no more are found
		if ( *arg1Ptr == '\0' )
    2d82:	9802      	ldr	r0, [sp, #8]
    2d84:	7803      	ldrb	r3, [r0, #0]
    2d86:	b173      	cbz	r3, 2da6 <cliFunc_ledWPage+0x96>
			break;

		data[2] = numToInt( arg1Ptr );
    2d88:	f004 fe1a 	bl	79c0 <numToInt>
    2d8c:	f88d 0006 	strb.w	r0, [sp, #6]

		// Write register location and data to I2C
		while ( I2C_Send( data, sizeof( data ), 0 ) == 0 )
    2d90:	a801      	add	r0, sp, #4
    2d92:	2103      	movs	r1, #3
    2d94:	2200      	movs	r2, #0
    2d96:	f7ff fd47 	bl	2828 <I2C_Send>
    2d9a:	2800      	cmp	r0, #0
    2d9c:	d1e7      	bne.n	2d6e <cliFunc_ledWPage+0x5e>
			delay(1);
    2d9e:	2001      	movs	r0, #1
    2da0:	f7ff fc18 	bl	25d4 <delay>
    2da4:	e7f4      	b.n	2d90 <cliFunc_ledWPage+0x80>

		// Increment address
		data[1]++;
	}
}
    2da6:	b004      	add	sp, #16
    2da8:	bd10      	pop	{r4, pc}

00002daa <LED_scan>:
	// I2C Busy
	// S & I2C_S_BUSY
	//I2C_S_BUSY

	return 0;
}
    2daa:	2000      	movs	r0, #0
    2dac:	4770      	bx	lr
    2dae:	0000      	movs	r0, r0

00002db0 <LED_control>:
		return;
	*/

	// Configure based upon the given mode
	// TODO Perhaps do gamma adjustment?
	switch ( control->mode )
    2db0:	7803      	ldrb	r3, [r0, #0]
	uint8_t        amount;
	uint16_t       index;
} LedControl;

void LED_control( LedControl *control )
{
    2db2:	b510      	push	{r4, lr}
		return;
	*/

	// Configure based upon the given mode
	// TODO Perhaps do gamma adjustment?
	switch ( control->mode )
    2db4:	2b05      	cmp	r3, #5
    2db6:	d836      	bhi.n	2e26 <LED_control+0x76>
    2db8:	e8df f003 	tbb	[pc, r3]
    2dbc:	17120a03 	.word	0x17120a03
    2dc0:	2d22      	.short	0x2d22
	{
	case LedControlMode_brightness_decrease:
		// Don't worry about rolling over, the cycle is quick
		LED_pageBuffer.buffer[ control->index ] -= control->amount;
    2dc2:	4a1e      	ldr	r2, [pc, #120]	; (2e3c <LED_control+0x8c>)
    2dc4:	8843      	ldrh	r3, [r0, #2]
    2dc6:	4413      	add	r3, r2
    2dc8:	7842      	ldrb	r2, [r0, #1]
    2dca:	7899      	ldrb	r1, [r3, #2]
    2dcc:	1a8a      	subs	r2, r1, r2
    2dce:	e005      	b.n	2ddc <LED_control+0x2c>
		break;

	case LedControlMode_brightness_increase:
		// Don't worry about rolling over, the cycle is quick
		LED_pageBuffer.buffer[ control->index ] += control->amount;
    2dd0:	4a1a      	ldr	r2, [pc, #104]	; (2e3c <LED_control+0x8c>)
    2dd2:	8843      	ldrh	r3, [r0, #2]
    2dd4:	4413      	add	r3, r2
    2dd6:	7842      	ldrb	r2, [r0, #1]
    2dd8:	7899      	ldrb	r1, [r3, #2]
    2dda:	440a      	add	r2, r1
    2ddc:	709a      	strb	r2, [r3, #2]
		break;
    2dde:	e022      	b.n	2e26 <LED_control+0x76>

	case LedControlMode_brightness_set:
		LED_pageBuffer.buffer[ control->index ] = control->amount;
    2de0:	8843      	ldrh	r3, [r0, #2]
    2de2:	4916      	ldr	r1, [pc, #88]	; (2e3c <LED_control+0x8c>)
    2de4:	7842      	ldrb	r2, [r0, #1]
    2de6:	440b      	add	r3, r1
    2de8:	e7f8      	b.n	2ddc <LED_control+0x2c>
    2dea:	4b15      	ldr	r3, [pc, #84]	; (2e40 <LED_control+0x90>)
    2dec:	f103 0290 	add.w	r2, r3, #144	; 0x90

	case LedControlMode_brightness_decrease_all:
		for ( uint8_t channel = 0; channel < LED_TotalChannels; channel++ )
		{
			// Don't worry about rolling over, the cycle is quick
			LED_pageBuffer.buffer[ channel ] -= control->amount;
    2df0:	78dc      	ldrb	r4, [r3, #3]
    2df2:	7841      	ldrb	r1, [r0, #1]
    2df4:	3301      	adds	r3, #1
    2df6:	1a61      	subs	r1, r4, r1
	case LedControlMode_brightness_set:
		LED_pageBuffer.buffer[ control->index ] = control->amount;
		break;

	case LedControlMode_brightness_decrease_all:
		for ( uint8_t channel = 0; channel < LED_TotalChannels; channel++ )
    2df8:	4293      	cmp	r3, r2
		{
			// Don't worry about rolling over, the cycle is quick
			LED_pageBuffer.buffer[ channel ] -= control->amount;
    2dfa:	7099      	strb	r1, [r3, #2]
	case LedControlMode_brightness_set:
		LED_pageBuffer.buffer[ control->index ] = control->amount;
		break;

	case LedControlMode_brightness_decrease_all:
		for ( uint8_t channel = 0; channel < LED_TotalChannels; channel++ )
    2dfc:	d1f8      	bne.n	2df0 <LED_control+0x40>
    2dfe:	e012      	b.n	2e26 <LED_control+0x76>
    2e00:	4b0f      	ldr	r3, [pc, #60]	; (2e40 <LED_control+0x90>)
    2e02:	f103 0290 	add.w	r2, r3, #144	; 0x90

	case LedControlMode_brightness_increase_all:
		for ( uint8_t channel = 0; channel < LED_TotalChannels; channel++ )
		{
			// Don't worry about rolling over, the cycle is quick
			LED_pageBuffer.buffer[ channel ] += control->amount;
    2e06:	78dc      	ldrb	r4, [r3, #3]
    2e08:	7841      	ldrb	r1, [r0, #1]
    2e0a:	3301      	adds	r3, #1
    2e0c:	4421      	add	r1, r4
			LED_pageBuffer.buffer[ channel ] -= control->amount;
		}
		break;

	case LedControlMode_brightness_increase_all:
		for ( uint8_t channel = 0; channel < LED_TotalChannels; channel++ )
    2e0e:	4293      	cmp	r3, r2
		{
			// Don't worry about rolling over, the cycle is quick
			LED_pageBuffer.buffer[ channel ] += control->amount;
    2e10:	7099      	strb	r1, [r3, #2]
			LED_pageBuffer.buffer[ channel ] -= control->amount;
		}
		break;

	case LedControlMode_brightness_increase_all:
		for ( uint8_t channel = 0; channel < LED_TotalChannels; channel++ )
    2e12:	d1f8      	bne.n	2e06 <LED_control+0x56>
    2e14:	e007      	b.n	2e26 <LED_control+0x76>
		return;
	*/

	// Configure based upon the given mode
	// TODO Perhaps do gamma adjustment?
	switch ( control->mode )
    2e16:	2300      	movs	r3, #0
    2e18:	4a08      	ldr	r2, [pc, #32]	; (2e3c <LED_control+0x8c>)
		break;

	case LedControlMode_brightness_set_all:
		for ( uint8_t channel = 0; channel < LED_TotalChannels; channel++ )
		{
			LED_pageBuffer.buffer[ channel ] = control->amount;
    2e1a:	7841      	ldrb	r1, [r0, #1]
    2e1c:	441a      	add	r2, r3
    2e1e:	3301      	adds	r3, #1
			LED_pageBuffer.buffer[ channel ] += control->amount;
		}
		break;

	case LedControlMode_brightness_set_all:
		for ( uint8_t channel = 0; channel < LED_TotalChannels; channel++ )
    2e20:	2b90      	cmp	r3, #144	; 0x90
		{
			LED_pageBuffer.buffer[ channel ] = control->amount;
    2e22:	7091      	strb	r1, [r2, #2]
			LED_pageBuffer.buffer[ channel ] += control->amount;
		}
		break;

	case LedControlMode_brightness_set_all:
		for ( uint8_t channel = 0; channel < LED_TotalChannels; channel++ )
    2e24:	d1f8      	bne.n	2e18 <LED_control+0x68>
		break;
	}

	// Sync LED buffer with ISSI chip buffer
	// TODO Support multiple frames
	LED_pageBuffer.i2c_addr = 0xE8; // Chip 1
    2e26:	4805      	ldr	r0, [pc, #20]	; (2e3c <LED_control+0x8c>)
    2e28:	23e8      	movs	r3, #232	; 0xe8
    2e2a:	7003      	strb	r3, [r0, #0]
	LED_pageBuffer.reg_addr = 0x24; // Brightness section
    2e2c:	2324      	movs	r3, #36	; 0x24
    2e2e:	7043      	strb	r3, [r0, #1]
	LED_sendPage( (uint8_t*)&LED_pageBuffer, sizeof( LED_Buffer ), 0 );
    2e30:	2192      	movs	r1, #146	; 0x92
    2e32:	2200      	movs	r2, #0
}
    2e34:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

	// Sync LED buffer with ISSI chip buffer
	// TODO Support multiple frames
	LED_pageBuffer.i2c_addr = 0xE8; // Chip 1
	LED_pageBuffer.reg_addr = 0x24; // Brightness section
	LED_sendPage( (uint8_t*)&LED_pageBuffer, sizeof( LED_Buffer ), 0 );
    2e38:	f7ff bdb0 	b.w	299c <LED_sendPage>
    2e3c:	1fff9c09 	.word	0x1fff9c09
    2e40:	1fff9c08 	.word	0x1fff9c08

00002e44 <cliFunc_ledCtrl>:
	print( NL ); // No \r\n by default after the command is entered
	LED_zeroPages( 0x00, 8, 0x24, 0xB4 ); // Only PWMs
}

void cliFunc_ledCtrl( char* args )
{
    2e44:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	char* arg2Ptr = args;
	LedControl control;

	// First process mode
	curArgs = arg2Ptr;
	CLI_argumentIsolation( curArgs, &arg1Ptr, &arg2Ptr );
    2e46:	a901      	add	r1, sp, #4
    2e48:	aa02      	add	r2, sp, #8

void cliFunc_ledCtrl( char* args )
{
	char* curArgs;
	char* arg1Ptr;
	char* arg2Ptr = args;
    2e4a:	9002      	str	r0, [sp, #8]
	LedControl control;

	// First process mode
	curArgs = arg2Ptr;
	CLI_argumentIsolation( curArgs, &arg1Ptr, &arg2Ptr );
    2e4c:	f004 fa28 	bl	72a0 <CLI_argumentIsolation>

	// Stop processing args if no more are found
	if ( *arg1Ptr == '\0' )
    2e50:	9801      	ldr	r0, [sp, #4]
    2e52:	7803      	ldrb	r3, [r0, #0]
    2e54:	b30b      	cbz	r3, 2e9a <cliFunc_ledCtrl+0x56>
		return;
	control.mode = numToInt( arg1Ptr );
    2e56:	f004 fdb3 	bl	79c0 <numToInt>


	// Next process amount
	curArgs = arg2Ptr;
	CLI_argumentIsolation( curArgs, &arg1Ptr, &arg2Ptr );
    2e5a:	a901      	add	r1, sp, #4
	CLI_argumentIsolation( curArgs, &arg1Ptr, &arg2Ptr );

	// Stop processing args if no more are found
	if ( *arg1Ptr == '\0' )
		return;
	control.mode = numToInt( arg1Ptr );
    2e5c:	f88d 000c 	strb.w	r0, [sp, #12]


	// Next process amount
	curArgs = arg2Ptr;
	CLI_argumentIsolation( curArgs, &arg1Ptr, &arg2Ptr );
    2e60:	aa02      	add	r2, sp, #8
    2e62:	9802      	ldr	r0, [sp, #8]
    2e64:	f004 fa1c 	bl	72a0 <CLI_argumentIsolation>

	// Stop processing args if no more are found
	if ( *arg1Ptr == '\0' )
    2e68:	9801      	ldr	r0, [sp, #4]
    2e6a:	7803      	ldrb	r3, [r0, #0]
    2e6c:	b1ab      	cbz	r3, 2e9a <cliFunc_ledCtrl+0x56>
		return;
	control.amount = numToInt( arg1Ptr );
    2e6e:	f004 fda7 	bl	79c0 <numToInt>


	// Finally process led index, if it exists
	// Default to 0
	curArgs = arg2Ptr;
	CLI_argumentIsolation( curArgs, &arg1Ptr, &arg2Ptr );
    2e72:	a901      	add	r1, sp, #4
	CLI_argumentIsolation( curArgs, &arg1Ptr, &arg2Ptr );

	// Stop processing args if no more are found
	if ( *arg1Ptr == '\0' )
		return;
	control.amount = numToInt( arg1Ptr );
    2e74:	f88d 000d 	strb.w	r0, [sp, #13]


	// Finally process led index, if it exists
	// Default to 0
	curArgs = arg2Ptr;
	CLI_argumentIsolation( curArgs, &arg1Ptr, &arg2Ptr );
    2e78:	aa02      	add	r2, sp, #8
    2e7a:	9802      	ldr	r0, [sp, #8]
    2e7c:	f004 fa10 	bl	72a0 <CLI_argumentIsolation>
	control.index = *arg1Ptr == '\0' ? 0 : numToInt( arg1Ptr );
    2e80:	9801      	ldr	r0, [sp, #4]
    2e82:	7803      	ldrb	r3, [r0, #0]
    2e84:	b11b      	cbz	r3, 2e8e <cliFunc_ledCtrl+0x4a>
    2e86:	f004 fd9b 	bl	79c0 <numToInt>
    2e8a:	b280      	uxth	r0, r0
    2e8c:	e000      	b.n	2e90 <cliFunc_ledCtrl+0x4c>
    2e8e:	4618      	mov	r0, r3
    2e90:	f8ad 000e 	strh.w	r0, [sp, #14]

	// Process request
	LED_control( &control );
    2e94:	a803      	add	r0, sp, #12
    2e96:	f7ff ff8b 	bl	2db0 <LED_control>
}
    2e9a:	b005      	add	sp, #20
    2e9c:	f85d fb04 	ldr.w	pc, [sp], #4

00002ea0 <LED_control_capability>:

uint8_t LED_control_timer = 0;
void LED_control_capability( uint8_t state, uint8_t stateType, uint8_t *args )
{
	// Display capability name
	if ( stateType == 0xFF && state == 0xFF )
    2ea0:	29ff      	cmp	r1, #255	; 0xff
	LED_sendPage( (uint8_t*)&LED_pageBuffer, sizeof( LED_Buffer ), 0 );
}

uint8_t LED_control_timer = 0;
void LED_control_capability( uint8_t state, uint8_t stateType, uint8_t *args )
{
    2ea2:	b573      	push	{r0, r1, r4, r5, r6, lr}
    2ea4:	460b      	mov	r3, r1
    2ea6:	4605      	mov	r5, r0
    2ea8:	4614      	mov	r4, r2
	// Display capability name
	if ( stateType == 0xFF && state == 0xFF )
    2eaa:	d107      	bne.n	2ebc <LED_control_capability+0x1c>
    2eac:	28ff      	cmp	r0, #255	; 0xff
    2eae:	d108      	bne.n	2ec2 <LED_control_capability+0x22>
	{
		print("LED_control_capability(mode,amount,index)");
    2eb0:	481c      	ldr	r0, [pc, #112]	; (2f24 <LED_control_capability+0x84>)
		return;
#endif

	// Modify led state of this node
	LED_control( control );
}
    2eb2:	b002      	add	sp, #8
    2eb4:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
void LED_control_capability( uint8_t state, uint8_t stateType, uint8_t *args )
{
	// Display capability name
	if ( stateType == 0xFF && state == 0xFF )
	{
		print("LED_control_capability(mode,amount,index)");
    2eb8:	f004 bca4 	b.w	7804 <_print>
		return;
	}

	// Only use capability on press
	// TODO Analog
	if ( stateType == 0x00 && state == 0x03 ) // Not on release
    2ebc:	b909      	cbnz	r1, 2ec2 <LED_control_capability+0x22>
    2ebe:	2803      	cmp	r0, #3
    2ec0:	d02d      	beq.n	2f1e <LED_control_capability+0x7e>
	// XXX
	// ISSI Chip locks up if we spam updates too quickly (might be an I2C bug on this side too -HaaTa)
	// Make sure we only send an update every 30 milliseconds at most
	// It may be possible to optimize speed even further, but will likely require serious time with a logic analyzer

	uint8_t currentTime = (uint8_t)systick_millis_count;
    2ec2:	4a19      	ldr	r2, [pc, #100]	; (2f28 <LED_control_capability+0x88>)
    2ec4:	6811      	ldr	r1, [r2, #0]
	int8_t compare = (int8_t)(currentTime - LED_control_timer) & 0x7F;
    2ec6:	4a19      	ldr	r2, [pc, #100]	; (2f2c <LED_control_capability+0x8c>)
    2ec8:	7810      	ldrb	r0, [r2, #0]
	// XXX
	// ISSI Chip locks up if we spam updates too quickly (might be an I2C bug on this side too -HaaTa)
	// Make sure we only send an update every 30 milliseconds at most
	// It may be possible to optimize speed even further, but will likely require serious time with a logic analyzer

	uint8_t currentTime = (uint8_t)systick_millis_count;
    2eca:	b2c9      	uxtb	r1, r1
	int8_t compare = (int8_t)(currentTime - LED_control_timer) & 0x7F;
    2ecc:	1a08      	subs	r0, r1, r0
	if ( compare < 30 )
    2ece:	f000 007f 	and.w	r0, r0, #127	; 0x7f
    2ed2:	281d      	cmp	r0, #29
    2ed4:	dd23      	ble.n	2f1e <LED_control_capability+0x7e>
	{
		return;
	}
	LED_control_timer = currentTime;
    2ed6:	7011      	strb	r1, [r2, #0]
	uint8_t send_packet = 0;
	uint8_t ignore_node = 0;

	// By default send to the *next* node, which will determine where to go next
	extern uint8_t Connect_id; // connect_scan.c
	uint8_t addr = Connect_id + 1;
    2ed8:	4a15      	ldr	r2, [pc, #84]	; (2f30 <LED_control_capability+0x90>)
    2eda:	7810      	ldrb	r0, [r2, #0]

	switch ( control->mode )
    2edc:	7822      	ldrb	r2, [r4, #0]
    2ede:	2a05      	cmp	r2, #5
    2ee0:	d817      	bhi.n	2f12 <LED_control_capability+0x72>
    2ee2:	e8df f002 	tbb	[pc, r2]
    2ee6:	0303      	.short	0x0303
    2ee8:	0a0a0a03 	.word	0x0a0a0a03
	// Otherwise, ignore
	case LedControlMode_brightness_decrease:
	case LedControlMode_brightness_increase:
	case LedControlMode_brightness_set:
		// Ignore if led is on this node
		if ( control->index < LED_TotalChannels )
    2eec:	8862      	ldrh	r2, [r4, #2]
    2eee:	2a8f      	cmp	r2, #143	; 0x8f
    2ef0:	d90f      	bls.n	2f12 <LED_control_capability+0x72>
			break;

		// Calculate new led index
		control->index -= LED_TotalChannels;
    2ef2:	3a90      	subs	r2, #144	; 0x90
    2ef4:	8062      	strh	r2, [r4, #2]

		ignore_node = 1;
    2ef6:	2601      	movs	r6, #1
		send_packet = 1;
		break;
    2ef8:	e000      	b.n	2efc <LED_control_capability+0x5c>
	LedControl *control = (LedControl*)args;

	// Interconnect broadcasting
#if defined(ConnectEnabled_define)
	uint8_t send_packet = 0;
	uint8_t ignore_node = 0;
    2efa:	2600      	movs	r6, #0
	{
		// generatedKeymap.h
		extern const Capability CapabilitiesList[];

		// Broadcast layerStackExact remote capability (0xFF is the broadcast id)
		Connect_send_RemoteCapability(
    2efc:	4a0d      	ldr	r2, [pc, #52]	; (2f34 <LED_control_capability+0x94>)
    2efe:	7d12      	ldrb	r2, [r2, #20]
	uint8_t send_packet = 0;
	uint8_t ignore_node = 0;

	// By default send to the *next* node, which will determine where to go next
	extern uint8_t Connect_id; // connect_scan.c
	uint8_t addr = Connect_id + 1;
    2f00:	3001      	adds	r0, #1
	{
		// generatedKeymap.h
		extern const Capability CapabilitiesList[];

		// Broadcast layerStackExact remote capability (0xFF is the broadcast id)
		Connect_send_RemoteCapability(
    2f02:	e88d 0014 	stmia.w	sp, {r2, r4}
    2f06:	b2c0      	uxtb	r0, r0
    2f08:	2102      	movs	r1, #2
    2f0a:	462a      	mov	r2, r5
    2f0c:	f001 fa36 	bl	437c <Connect_send_RemoteCapability>
			args
		);
	}

	// If there is nothing to do on this node, ignore
	if ( ignore_node )
    2f10:	b92e      	cbnz	r6, 2f1e <LED_control_capability+0x7e>
		return;
#endif

	// Modify led state of this node
	LED_control( control );
    2f12:	4620      	mov	r0, r4
}
    2f14:	b002      	add	sp, #8
    2f16:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	if ( ignore_node )
		return;
#endif

	// Modify led state of this node
	LED_control( control );
    2f1a:	f7ff bf49 	b.w	2db0 <LED_control>
}
    2f1e:	b002      	add	sp, #8
    2f20:	bd70      	pop	{r4, r5, r6, pc}
    2f22:	bf00      	nop
    2f24:	00007d73 	.word	0x00007d73
    2f28:	1fff92a4 	.word	0x1fff92a4
    2f2c:	1fff92a8 	.word	0x1fff92a8
    2f30:	1fff89c5 	.word	0x1fff89c5
    2f34:	0000a1f8 	.word	0x0000a1f8

00002f38 <cliFunc_matrixState>:
	info_msg("Matrix Debug Mode: ");
	printInt8( matrixDebugMode );
}

void cliFunc_matrixState ( char* args )
{
    2f38:	b513      	push	{r0, r1, r4, lr}
	char* arg1Ptr;
	char* arg2Ptr;
	CLI_argumentIsolation( args, &arg1Ptr, &arg2Ptr );

	// Default to 1 if no argument is given
	matrixDebugStateCounter = 1;
    2f3a:	4c07      	ldr	r4, [pc, #28]	; (2f58 <cliFunc_matrixState+0x20>)
{
	// Parse number from argument
	//  NOTE: Only first argument is used
	char* arg1Ptr;
	char* arg2Ptr;
	CLI_argumentIsolation( args, &arg1Ptr, &arg2Ptr );
    2f3c:	4669      	mov	r1, sp
    2f3e:	aa01      	add	r2, sp, #4
    2f40:	f004 f9ae 	bl	72a0 <CLI_argumentIsolation>

	// Default to 1 if no argument is given
	matrixDebugStateCounter = 1;
    2f44:	2301      	movs	r3, #1

	if ( arg1Ptr[0] != '\0' )
    2f46:	9800      	ldr	r0, [sp, #0]
	char* arg1Ptr;
	char* arg2Ptr;
	CLI_argumentIsolation( args, &arg1Ptr, &arg2Ptr );

	// Default to 1 if no argument is given
	matrixDebugStateCounter = 1;
    2f48:	8023      	strh	r3, [r4, #0]

	if ( arg1Ptr[0] != '\0' )
    2f4a:	7803      	ldrb	r3, [r0, #0]
    2f4c:	b113      	cbz	r3, 2f54 <cliFunc_matrixState+0x1c>
	{
		matrixDebugStateCounter = (uint16_t)numToInt( arg1Ptr );
    2f4e:	f004 fd37 	bl	79c0 <numToInt>
    2f52:	8020      	strh	r0, [r4, #0]
	}
}
    2f54:	b002      	add	sp, #8
    2f56:	bd10      	pop	{r4, pc}
    2f58:	1fff92b2 	.word	0x1fff92b2

00002f5c <cliFunc_matrixDebug>:


// ----- CLI Command Functions -----

void cliFunc_matrixDebug ( char* args )
{
    2f5c:	b507      	push	{r0, r1, r2, lr}
	// Parse number from argument
	//  NOTE: Only first argument is used
	char* arg1Ptr;
	char* arg2Ptr;
	CLI_argumentIsolation( args, &arg1Ptr, &arg2Ptr );
    2f5e:	4669      	mov	r1, sp
    2f60:	aa01      	add	r2, sp, #4
    2f62:	f004 f99d 	bl	72a0 <CLI_argumentIsolation>

	// Set the matrix debug flag depending on the argument
	// If no argument, set to scan code only
	// If set to T, set to state transition
	switch ( arg1Ptr[0] )
    2f66:	9b00      	ldr	r3, [sp, #0]
    2f68:	781b      	ldrb	r3, [r3, #0]
    2f6a:	2b54      	cmp	r3, #84	; 0x54
    2f6c:	d009      	beq.n	2f82 <cliFunc_matrixDebug+0x26>
    2f6e:	2b74      	cmp	r3, #116	; 0x74
    2f70:	d007      	beq.n	2f82 <cliFunc_matrixDebug+0x26>
    2f72:	b9bb      	cbnz	r3, 2fa4 <cliFunc_matrixDebug+0x48>
		matrixDebugMode = matrixDebugMode != 2 ? 2 : 0;
		break;

	// No argument
	case '\0':
		matrixDebugMode = matrixDebugMode != 1 ? 1 : 0;
    2f74:	4b0d      	ldr	r3, [pc, #52]	; (2fac <cliFunc_matrixDebug+0x50>)
    2f76:	781a      	ldrb	r2, [r3, #0]
    2f78:	f112 32ff 	adds.w	r2, r2, #4294967295	; 0xffffffff
    2f7c:	bf18      	it	ne
    2f7e:	2201      	movne	r2, #1
    2f80:	e005      	b.n	2f8e <cliFunc_matrixDebug+0x32>
	switch ( arg1Ptr[0] )
	{
	// T as argument
	case 'T':
	case 't':
		matrixDebugMode = matrixDebugMode != 2 ? 2 : 0;
    2f82:	4b0a      	ldr	r3, [pc, #40]	; (2fac <cliFunc_matrixDebug+0x50>)
    2f84:	781a      	ldrb	r2, [r3, #0]
    2f86:	2a02      	cmp	r2, #2
    2f88:	bf14      	ite	ne
    2f8a:	2202      	movne	r2, #2
    2f8c:	2200      	moveq	r2, #0
	// Invalid argument
	default:
		return;
	}

	print( NL );
    2f8e:	4808      	ldr	r0, [pc, #32]	; (2fb0 <cliFunc_matrixDebug+0x54>)
		matrixDebugMode = matrixDebugMode != 2 ? 2 : 0;
		break;

	// No argument
	case '\0':
		matrixDebugMode = matrixDebugMode != 1 ? 1 : 0;
    2f90:	701a      	strb	r2, [r3, #0]
	// Invalid argument
	default:
		return;
	}

	print( NL );
    2f92:	f004 fc37 	bl	7804 <_print>
	info_msg("Matrix Debug Mode: ");
    2f96:	4807      	ldr	r0, [pc, #28]	; (2fb4 <cliFunc_matrixDebug+0x58>)
    2f98:	f004 fc34 	bl	7804 <_print>
	printInt8( matrixDebugMode );
    2f9c:	4b03      	ldr	r3, [pc, #12]	; (2fac <cliFunc_matrixDebug+0x50>)
    2f9e:	7818      	ldrb	r0, [r3, #0]
    2fa0:	f004 fc62 	bl	7868 <printInt8>
}
    2fa4:	b003      	add	sp, #12
    2fa6:	f85d fb04 	ldr.w	pc, [sp], #4
    2faa:	bf00      	nop
    2fac:	1fff92b0 	.word	0x1fff92b0
    2fb0:	0000bafb 	.word	0x0000bafb
    2fb4:	00008046 	.word	0x00008046

00002fb8 <Matrix_pin>:

// Pin action (Strobe, Sense, Strobe Setup, Sense Setup)
// NOTE: This function is highly dependent upon the organization of the register map
//       Only guaranteed to work with Freescale MK20 series uCs
uint8_t Matrix_pin( GPIO_Pin gpio, Type type )
{
    2fb8:	b537      	push	{r0, r1, r2, r4, r5, lr}
    2fba:	b2c2      	uxtb	r2, r0
    2fbc:	f8ad 0004 	strh.w	r0, [sp, #4]
    2fc0:	f3c0 2007 	ubfx	r0, r0, #8, #8
	// Register width is defined as size of a pointer
	unsigned int gpio_offset = gpio.port * 0x40   / sizeof(unsigned int*);
    2fc4:	0113      	lsls	r3, r2, #4
	unsigned int port_offset = gpio.port * 0x1000 / sizeof(unsigned int*) + gpio.pin;
    2fc6:	eb00 2282 	add.w	r2, r0, r2, lsl #10
	// See Lib/mk20dx.h
	volatile unsigned int *GPIO_PDDR = (unsigned int*)(&GPIOA_PDDR) + gpio_offset;
	volatile unsigned int *GPIO_PSOR = (unsigned int*)(&GPIOA_PSOR) + gpio_offset;
	volatile unsigned int *GPIO_PCOR = (unsigned int*)(&GPIOA_PCOR) + gpio_offset;
	volatile unsigned int *GPIO_PDIR = (unsigned int*)(&GPIOA_PDIR) + gpio_offset;
	volatile unsigned int *PORT_PCR  = (unsigned int*)(&PORTA_PCR0) + port_offset;
    2fca:	0092      	lsls	r2, r2, #2
    2fcc:	f102 4280 	add.w	r2, r2, #1073741824	; 0x40000000
	unsigned int gpio_offset = gpio.port * 0x40   / sizeof(unsigned int*);
	unsigned int port_offset = gpio.port * 0x1000 / sizeof(unsigned int*) + gpio.pin;

	// Assumes 0x40 between GPIO Port registers and 0x1000 between PORT pin registers
	// See Lib/mk20dx.h
	volatile unsigned int *GPIO_PDDR = (unsigned int*)(&GPIOA_PDDR) + gpio_offset;
    2fd0:	4c28      	ldr	r4, [pc, #160]	; (3074 <Matrix_pin+0xbc>)
	volatile unsigned int *GPIO_PSOR = (unsigned int*)(&GPIOA_PSOR) + gpio_offset;
	volatile unsigned int *GPIO_PCOR = (unsigned int*)(&GPIOA_PCOR) + gpio_offset;
	volatile unsigned int *GPIO_PDIR = (unsigned int*)(&GPIOA_PDIR) + gpio_offset;
	volatile unsigned int *PORT_PCR  = (unsigned int*)(&PORTA_PCR0) + port_offset;
    2fd2:	f502 2292 	add.w	r2, r2, #299008	; 0x49000

	// Operation depends on Type
	switch ( type )
    2fd6:	2904      	cmp	r1, #4
    2fd8:	d849      	bhi.n	306e <Matrix_pin+0xb6>
    2fda:	e8df f001 	tbb	[pc, r1]
    2fde:	0503      	.short	0x0503
    2fe0:	220f      	.short	0x220f
    2fe2:	2d          	.byte	0x2d
    2fe3:	00          	.byte	0x00
	unsigned int port_offset = gpio.port * 0x1000 / sizeof(unsigned int*) + gpio.pin;

	// Assumes 0x40 between GPIO Port registers and 0x1000 between PORT pin registers
	// See Lib/mk20dx.h
	volatile unsigned int *GPIO_PDDR = (unsigned int*)(&GPIOA_PDDR) + gpio_offset;
	volatile unsigned int *GPIO_PSOR = (unsigned int*)(&GPIOA_PSOR) + gpio_offset;
    2fe4:	4a24      	ldr	r2, [pc, #144]	; (3078 <Matrix_pin+0xc0>)
    2fe6:	e000      	b.n	2fea <Matrix_pin+0x32>
	volatile unsigned int *GPIO_PCOR = (unsigned int*)(&GPIOA_PCOR) + gpio_offset;
    2fe8:	4a24      	ldr	r2, [pc, #144]	; (307c <Matrix_pin+0xc4>)
	case Type_StrobeOn:
		*GPIO_PSOR |= (1 << gpio.pin);
		break;

	case Type_StrobeOff:
		*GPIO_PCOR |= (1 << gpio.pin);
    2fea:	f852 1023 	ldr.w	r1, [r2, r3, lsl #2]
    2fee:	2401      	movs	r4, #1
    2ff0:	fa04 f000 	lsl.w	r0, r4, r0
    2ff4:	4308      	orrs	r0, r1
    2ff6:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
    2ffa:	e038      	b.n	306e <Matrix_pin+0xb6>
		break;

	case Type_StrobeSetup:
		// Set as output pin
		*GPIO_PDDR |= (1 << gpio.pin);
    2ffc:	f854 1023 	ldr.w	r1, [r4, r3, lsl #2]
    3000:	2501      	movs	r5, #1
    3002:	fa05 f000 	lsl.w	r0, r5, r0
    3006:	4308      	orrs	r0, r1
    3008:	f844 0023 	str.w	r0, [r4, r3, lsl #2]

		// Configure pin with slow slew, high drive strength and GPIO mux
		*PORT_PCR = PORT_PCR_SRE | PORT_PCR_DSE | PORT_PCR_MUX(1);
    300c:	f44f 73a2 	mov.w	r3, #324	; 0x144
    3010:	6013      	str	r3, [r2, #0]

		// Enabling open-drain if specified
		switch ( Matrix_type )
    3012:	4b1b      	ldr	r3, [pc, #108]	; (3080 <Matrix_pin+0xc8>)
    3014:	781b      	ldrb	r3, [r3, #0]
    3016:	2b02      	cmp	r3, #2
    3018:	d129      	bne.n	306e <Matrix_pin+0xb6>
		{
		case Config_Opendrain:
			*PORT_PCR |= PORT_PCR_ODE;
    301a:	6813      	ldr	r3, [r2, #0]
    301c:	f043 0320 	orr.w	r3, r3, #32
    3020:	e024      	b.n	306c <Matrix_pin+0xb4>
	// Assumes 0x40 between GPIO Port registers and 0x1000 between PORT pin registers
	// See Lib/mk20dx.h
	volatile unsigned int *GPIO_PDDR = (unsigned int*)(&GPIOA_PDDR) + gpio_offset;
	volatile unsigned int *GPIO_PSOR = (unsigned int*)(&GPIOA_PSOR) + gpio_offset;
	volatile unsigned int *GPIO_PCOR = (unsigned int*)(&GPIOA_PCOR) + gpio_offset;
	volatile unsigned int *GPIO_PDIR = (unsigned int*)(&GPIOA_PDIR) + gpio_offset;
    3022:	4a18      	ldr	r2, [pc, #96]	; (3084 <Matrix_pin+0xcc>)
			break;
		}
		break;

	case Type_Sense:
		return *GPIO_PDIR & (1 << gpio.pin) ? 1 : 0;
    3024:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    3028:	2201      	movs	r2, #1
    302a:	fa02 f000 	lsl.w	r0, r2, r0
    302e:	4203      	tst	r3, r0
    3030:	bf0c      	ite	eq
    3032:	2000      	moveq	r0, #0
    3034:	2001      	movne	r0, #1
    3036:	e01b      	b.n	3070 <Matrix_pin+0xb8>

	case Type_SenseSetup:
		// Set as input pin
		*GPIO_PDDR &= ~(1 << gpio.pin);
    3038:	f854 1023 	ldr.w	r1, [r4, r3, lsl #2]
    303c:	2501      	movs	r5, #1
    303e:	fa05 f000 	lsl.w	r0, r5, r0
    3042:	ea21 0000 	bic.w	r0, r1, r0
    3046:	f844 0023 	str.w	r0, [r4, r3, lsl #2]

		// Configure pin with passive filter and GPIO mux
		*PORT_PCR = PORT_PCR_PFE | PORT_PCR_MUX(1);
    304a:	f44f 7388 	mov.w	r3, #272	; 0x110
    304e:	6013      	str	r3, [r2, #0]

		// Pull resistor config
		switch ( Matrix_type )
    3050:	4b0b      	ldr	r3, [pc, #44]	; (3080 <Matrix_pin+0xc8>)
    3052:	7818      	ldrb	r0, [r3, #0]
    3054:	b128      	cbz	r0, 3062 <Matrix_pin+0xaa>
    3056:	42a8      	cmp	r0, r5
    3058:	d109      	bne.n	306e <Matrix_pin+0xb6>
		case Config_Pullup:
			*PORT_PCR |= PORT_PCR_PE | PORT_PCR_PS;
			break;

		case Config_Pulldown:
			*PORT_PCR |= PORT_PCR_PE;
    305a:	6813      	ldr	r3, [r2, #0]
    305c:	f043 0302 	orr.w	r3, r3, #2
    3060:	e004      	b.n	306c <Matrix_pin+0xb4>

		// Pull resistor config
		switch ( Matrix_type )
		{
		case Config_Pullup:
			*PORT_PCR |= PORT_PCR_PE | PORT_PCR_PS;
    3062:	6813      	ldr	r3, [r2, #0]
    3064:	f043 0303 	orr.w	r3, r3, #3
    3068:	6013      	str	r3, [r2, #0]
			break;
    306a:	e001      	b.n	3070 <Matrix_pin+0xb8>

		case Config_Pulldown:
			*PORT_PCR |= PORT_PCR_PE;
    306c:	6013      	str	r3, [r2, #0]
			break;
		}
		break;
	}

	return 0;
    306e:	2000      	movs	r0, #0
}
    3070:	b003      	add	sp, #12
    3072:	bd30      	pop	{r4, r5, pc}
    3074:	400ff014 	.word	0x400ff014
    3078:	400ff004 	.word	0x400ff004
    307c:	400ff008 	.word	0x400ff008
    3080:	1fff89c4 	.word	0x1fff89c4
    3084:	400ff010 	.word	0x400ff010

00003088 <Matrix_setup>:

// Setup GPIO pins for matrix scanning
void Matrix_setup()
{
    3088:	b570      	push	{r4, r5, r6, lr}
	// Register Matrix CLI dictionary
	CLI_registerDictionary( matrixCLIDict, matrixCLIDictName );
    308a:	492d      	ldr	r1, [pc, #180]	; (3140 <Matrix_setup+0xb8>)
    308c:	482d      	ldr	r0, [pc, #180]	; (3144 <Matrix_setup+0xbc>)
    308e:	f004 f97b 	bl	7388 <CLI_registerDictionary>

	info_msg("Columns:  ");
    3092:	482d      	ldr	r0, [pc, #180]	; (3148 <Matrix_setup+0xc0>)
    3094:	f004 fbb6 	bl	7804 <_print>
	printHex( Matrix_colsNum );
    3098:	2009      	movs	r0, #9
    309a:	2101      	movs	r1, #1
    309c:	f004 fc3b 	bl	7916 <printHex_op>
    30a0:	2400      	movs	r4, #0

	// Setup Strobe Pins
	for ( uint8_t pin = 0; pin < Matrix_colsNum; pin++ )
	{
		Matrix_pin( Matrix_cols[ pin ], Type_StrobeSetup );
    30a2:	4b2a      	ldr	r3, [pc, #168]	; (314c <Matrix_setup+0xc4>)
    30a4:	f813 2014 	ldrb.w	r2, [r3, r4, lsl #1]
    30a8:	eb03 0344 	add.w	r3, r3, r4, lsl #1
    30ac:	2102      	movs	r1, #2
    30ae:	7858      	ldrb	r0, [r3, #1]
    30b0:	3401      	adds	r4, #1
    30b2:	ea42 2000 	orr.w	r0, r2, r0, lsl #8
    30b6:	f7ff ff7f 	bl	2fb8 <Matrix_pin>

	info_msg("Columns:  ");
	printHex( Matrix_colsNum );

	// Setup Strobe Pins
	for ( uint8_t pin = 0; pin < Matrix_colsNum; pin++ )
    30ba:	2c09      	cmp	r4, #9
    30bc:	d1f1      	bne.n	30a2 <Matrix_setup+0x1a>
	{
		Matrix_pin( Matrix_cols[ pin ], Type_StrobeSetup );
	}

	print( NL );
    30be:	4824      	ldr	r0, [pc, #144]	; (3150 <Matrix_setup+0xc8>)
    30c0:	f004 fba0 	bl	7804 <_print>
	info_msg("Rows:     ");
    30c4:	4823      	ldr	r0, [pc, #140]	; (3154 <Matrix_setup+0xcc>)
    30c6:	f004 fb9d 	bl	7804 <_print>
	printHex( Matrix_rowsNum );
    30ca:	2005      	movs	r0, #5
    30cc:	2101      	movs	r1, #1
    30ce:	f004 fc22 	bl	7916 <printHex_op>
    30d2:	2400      	movs	r4, #0

	// Setup Sense Pins
	for ( uint8_t pin = 0; pin < Matrix_rowsNum; pin++ )
	{
		Matrix_pin( Matrix_rows[ pin ], Type_SenseSetup );
    30d4:	4b20      	ldr	r3, [pc, #128]	; (3158 <Matrix_setup+0xd0>)
    30d6:	f813 2014 	ldrb.w	r2, [r3, r4, lsl #1]
    30da:	eb03 0344 	add.w	r3, r3, r4, lsl #1
    30de:	2104      	movs	r1, #4
    30e0:	7858      	ldrb	r0, [r3, #1]
    30e2:	3401      	adds	r4, #1
    30e4:	ea42 2000 	orr.w	r0, r2, r0, lsl #8
    30e8:	f7ff ff66 	bl	2fb8 <Matrix_pin>
	print( NL );
	info_msg("Rows:     ");
	printHex( Matrix_rowsNum );

	// Setup Sense Pins
	for ( uint8_t pin = 0; pin < Matrix_rowsNum; pin++ )
    30ec:	2c05      	cmp	r4, #5
    30ee:	d1f1      	bne.n	30d4 <Matrix_setup+0x4c>
	{
		Matrix_pin( Matrix_rows[ pin ], Type_SenseSetup );
	}

	print( NL );
    30f0:	4817      	ldr	r0, [pc, #92]	; (3150 <Matrix_setup+0xc8>)
    30f2:	f004 fb87 	bl	7804 <_print>
	info_msg("Max Keys: ");
    30f6:	4819      	ldr	r0, [pc, #100]	; (315c <Matrix_setup+0xd4>)
    30f8:	f004 fb84 	bl	7804 <_print>
	printHex( Matrix_maxKeys );
    30fc:	2101      	movs	r1, #1
    30fe:	202d      	movs	r0, #45	; 0x2d
    3100:	f004 fc09 	bl	7916 <printHex_op>
	print( NL );
    3104:	4812      	ldr	r0, [pc, #72]	; (3150 <Matrix_setup+0xc8>)
    3106:	f004 fb7d 	bl	7804 <_print>
    310a:	2100      	movs	r1, #0
    310c:	460a      	mov	r2, r1
    310e:	4d14      	ldr	r5, [pc, #80]	; (3160 <Matrix_setup+0xd8>)
	// Clear out Debounce Array
	for ( uint8_t item = 0; item < Matrix_maxKeys; item++ )
	{
		Matrix_scanArray[ item ].prevState        = KeyState_Off;
		Matrix_scanArray[ item ].curState         = KeyState_Off;
		Matrix_scanArray[ item ].activeCount      = 0;
    3110:	2607      	movs	r6, #7
    3112:	1948      	adds	r0, r1, r5
    3114:	4356      	muls	r6, r2
	print( NL );

	// Clear out Debounce Array
	for ( uint8_t item = 0; item < Matrix_maxKeys; item++ )
	{
		Matrix_scanArray[ item ].prevState        = KeyState_Off;
    3116:	2300      	movs	r3, #0
		Matrix_scanArray[ item ].curState         = KeyState_Off;
		Matrix_scanArray[ item ].activeCount      = 0;
    3118:	19ac      	adds	r4, r5, r6
    311a:	3201      	adds	r2, #1
	print( NL );

	// Clear out Debounce Array
	for ( uint8_t item = 0; item < Matrix_maxKeys; item++ )
	{
		Matrix_scanArray[ item ].prevState        = KeyState_Off;
    311c:	7103      	strb	r3, [r0, #4]
		Matrix_scanArray[ item ].curState         = KeyState_Off;
    311e:	7143      	strb	r3, [r0, #5]
	info_msg("Max Keys: ");
	printHex( Matrix_maxKeys );
	print( NL );

	// Clear out Debounce Array
	for ( uint8_t item = 0; item < Matrix_maxKeys; item++ )
    3120:	2a2d      	cmp	r2, #45	; 0x2d
	{
		Matrix_scanArray[ item ].prevState        = KeyState_Off;
		Matrix_scanArray[ item ].curState         = KeyState_Off;
		Matrix_scanArray[ item ].activeCount      = 0;
    3122:	55ab      	strb	r3, [r5, r6]
		Matrix_scanArray[ item ].inactiveCount    = DebounceDivThreshold_define; // Start at 'off' steady state
    3124:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
	// Clear out Debounce Array
	for ( uint8_t item = 0; item < Matrix_maxKeys; item++ )
	{
		Matrix_scanArray[ item ].prevState        = KeyState_Off;
		Matrix_scanArray[ item ].curState         = KeyState_Off;
		Matrix_scanArray[ item ].activeCount      = 0;
    3128:	7063      	strb	r3, [r4, #1]
		Matrix_scanArray[ item ].inactiveCount    = DebounceDivThreshold_define; // Start at 'off' steady state
    312a:	70a5      	strb	r5, [r4, #2]
    312c:	70e5      	strb	r5, [r4, #3]
    312e:	f101 0107 	add.w	r1, r1, #7
		Matrix_scanArray[ item ].prevDecisionTime = 0;
    3132:	7183      	strb	r3, [r0, #6]
	info_msg("Max Keys: ");
	printHex( Matrix_maxKeys );
	print( NL );

	// Clear out Debounce Array
	for ( uint8_t item = 0; item < Matrix_maxKeys; item++ )
    3134:	d1eb      	bne.n	310e <Matrix_setup+0x86>
		Matrix_scanArray[ item ].inactiveCount    = DebounceDivThreshold_define; // Start at 'off' steady state
		Matrix_scanArray[ item ].prevDecisionTime = 0;
	}

	// Clear scan stats counters
	matrixMaxScans  = 0;
    3136:	4a0b      	ldr	r2, [pc, #44]	; (3164 <Matrix_setup+0xdc>)
    3138:	8013      	strh	r3, [r2, #0]
	matrixPrevScans = 0;
    313a:	4a0b      	ldr	r2, [pc, #44]	; (3168 <Matrix_setup+0xe0>)
    313c:	8013      	strh	r3, [r2, #0]
    313e:	bd70      	pop	{r4, r5, r6, pc}
    3140:	000082a3 	.word	0x000082a3
    3144:	000082bc 	.word	0x000082bc
    3148:	0000806c 	.word	0x0000806c
    314c:	1fff89a8 	.word	0x1fff89a8
    3150:	0000bafb 	.word	0x0000bafb
    3154:	00008089 	.word	0x00008089
    3158:	1fff89ba 	.word	0x1fff89ba
    315c:	000080a6 	.word	0x000080a6
    3160:	1fff9dc7 	.word	0x1fff9dc7
    3164:	1fff92ae 	.word	0x1fff92ae
    3168:	1fff92ac 	.word	0x1fff92ac

0000316c <Matrix_keyPositionDebug>:
}

void Matrix_keyPositionDebug( KeyPosition pos )
{
	// Depending on the state, use a different flag + color
	switch ( pos )
    316c:	2803      	cmp	r0, #3
    316e:	d80b      	bhi.n	3188 <Matrix_keyPositionDebug+0x1c>
    3170:	e8df f000 	tbb	[pc, r0]
    3174:	08060402 	.word	0x08060402
	{
	case KeyState_Off:
		print("\033[1mO\033[0m");
    3178:	4805      	ldr	r0, [pc, #20]	; (3190 <Matrix_keyPositionDebug+0x24>)
    317a:	e006      	b.n	318a <Matrix_keyPositionDebug+0x1e>
		break;

	case KeyState_Press:
		print("\033[1;33mP\033[0m");
    317c:	4805      	ldr	r0, [pc, #20]	; (3194 <Matrix_keyPositionDebug+0x28>)
    317e:	e004      	b.n	318a <Matrix_keyPositionDebug+0x1e>
		break;

	case KeyState_Hold:
		print("\033[1;32mH\033[0m");
    3180:	4805      	ldr	r0, [pc, #20]	; (3198 <Matrix_keyPositionDebug+0x2c>)
    3182:	e002      	b.n	318a <Matrix_keyPositionDebug+0x1e>
		break;

	case KeyState_Release:
		print("\033[1;35mR\033[0m");
    3184:	4805      	ldr	r0, [pc, #20]	; (319c <Matrix_keyPositionDebug+0x30>)
    3186:	e000      	b.n	318a <Matrix_keyPositionDebug+0x1e>
		break;

	case KeyState_Invalid:
	default:
		print("\033[1;31mI\033[0m");
    3188:	4805      	ldr	r0, [pc, #20]	; (31a0 <Matrix_keyPositionDebug+0x34>)
    318a:	f004 bb3b 	b.w	7804 <_print>
    318e:	bf00      	nop
    3190:	000080c3 	.word	0x000080c3
    3194:	000080cd 	.word	0x000080cd
    3198:	000080da 	.word	0x000080da
    319c:	000080e7 	.word	0x000080e7
    31a0:	000080f4 	.word	0x000080f4

000031a4 <Matrix_scan>:
	if ( !( Matrix_divCounter++ & (1 << ( DebounceThrottleDiv_define - 1 )) ) )
		return;
#endif

	// Increment stats counters
	if ( scanNum > matrixMaxScans ) matrixMaxScans = scanNum;
    31a4:	4b8f      	ldr	r3, [pc, #572]	; (33e4 <Matrix_scan+0x240>)


// Scan the matrix for keypresses
// NOTE: scanNum should be reset to 0 after a USB send (to reset all the counters)
void Matrix_scan( uint16_t scanNum )
{
    31a6:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if ( !( Matrix_divCounter++ & (1 << ( DebounceThrottleDiv_define - 1 )) ) )
		return;
#endif

	// Increment stats counters
	if ( scanNum > matrixMaxScans ) matrixMaxScans = scanNum;
    31aa:	881a      	ldrh	r2, [r3, #0]
    31ac:	4282      	cmp	r2, r0
    31ae:	bf38      	it	cc
    31b0:	8018      	strhcc	r0, [r3, #0]


// Scan the matrix for keypresses
// NOTE: scanNum should be reset to 0 after a USB send (to reset all the counters)
void Matrix_scan( uint16_t scanNum )
{
    31b2:	4606      	mov	r6, r0
    31b4:	4b8c      	ldr	r3, [pc, #560]	; (33e8 <Matrix_scan+0x244>)
		return;
#endif

	// Increment stats counters
	if ( scanNum > matrixMaxScans ) matrixMaxScans = scanNum;
	if ( scanNum == 0 )
    31b6:	b920      	cbnz	r0, 31c2 <Matrix_scan+0x1e>
	{
		matrixPrevScans = matrixCurScans;
    31b8:	8819      	ldrh	r1, [r3, #0]
    31ba:	4a8c      	ldr	r2, [pc, #560]	; (33ec <Matrix_scan+0x248>)
		matrixCurScans = 0;
    31bc:	8018      	strh	r0, [r3, #0]

	// Increment stats counters
	if ( scanNum > matrixMaxScans ) matrixMaxScans = scanNum;
	if ( scanNum == 0 )
	{
		matrixPrevScans = matrixCurScans;
    31be:	8011      	strh	r1, [r2, #0]
    31c0:	e002      	b.n	31c8 <Matrix_scan+0x24>
		matrixCurScans = 0;
	}
	else
	{
		matrixCurScans++;
    31c2:	881a      	ldrh	r2, [r3, #0]
    31c4:	3201      	adds	r2, #1
    31c6:	801a      	strh	r2, [r3, #0]
	}

	// Read systick for event scheduling
	uint8_t currentTime = (uint8_t)systick_millis_count;
    31c8:	4b89      	ldr	r3, [pc, #548]	; (33f0 <Matrix_scan+0x24c>)
    31ca:	681b      	ldr	r3, [r3, #0]
    31cc:	2500      	movs	r5, #0
    31ce:	fa5f fb83 	uxtb.w	fp, r3

	// For each strobe, scan each of the sense pins
	for ( uint8_t strobe = 0; strobe < Matrix_colsNum; strobe++ )
	{
		// Strobe Pin
		Matrix_pin( Matrix_cols[ strobe ], Type_StrobeOn );
    31d2:	f8df 9234 	ldr.w	r9, [pc, #564]	; 3408 <Matrix_scan+0x264>
    31d6:	ea4f 0a45 	mov.w	sl, r5, lsl #1
    31da:	eb09 020a 	add.w	r2, r9, sl
    31de:	f819 3015 	ldrb.w	r3, [r9, r5, lsl #1]
    31e2:	7850      	ldrb	r0, [r2, #1]
    31e4:	2100      	movs	r1, #0
    31e6:	ea43 2000 	orr.w	r0, r3, r0, lsl #8
    31ea:	f7ff fee5 	bl	2fb8 <Matrix_pin>
    31ee:	b2ef      	uxtb	r7, r5
    31f0:	f04f 0800 	mov.w	r8, #0
		// Scan each of the sense pins
		for ( uint8_t sense = 0; sense < Matrix_rowsNum; sense++ )
		{
			// Key position
			uint8_t key = Matrix_colsNum * sense + strobe;
			KeyState *state = &Matrix_scanArray[ key ];
    31f4:	2207      	movs	r2, #7
    31f6:	4b7f      	ldr	r3, [pc, #508]	; (33f4 <Matrix_scan+0x250>)
    31f8:	437a      	muls	r2, r7
    31fa:	18d4      	adds	r4, r2, r3

			// If first scan, reset state
			if ( scanNum == 0 )
    31fc:	b91e      	cbnz	r6, 3206 <Matrix_scan+0x62>
			{
				// Set previous state, and reset current state
				state->prevState = state->curState;
    31fe:	7961      	ldrb	r1, [r4, #5]
    3200:	7121      	strb	r1, [r4, #4]
				state->curState  = KeyState_Invalid;
    3202:	2104      	movs	r1, #4
    3204:	7161      	strb	r1, [r4, #5]
			// This means there is a maximum of scan 13 cycles on a perfect off to on transition
			//  (coming from a steady state 0xFFFF off scans)
			// Somewhat longer with switch bounciness
			// The advantage of this is that the count is ongoing and never needs to be reset
			// State still needs to be kept track of to deal with what to send to the Macro module
			if ( Matrix_pin( Matrix_rows[ sense ], Type_Sense ) )
    3206:	497c      	ldr	r1, [pc, #496]	; (33f8 <Matrix_scan+0x254>)
    3208:	f811 0018 	ldrb.w	r0, [r1, r8, lsl #1]
    320c:	eb01 0148 	add.w	r1, r1, r8, lsl #1
    3210:	7849      	ldrb	r1, [r1, #1]
    3212:	9201      	str	r2, [sp, #4]
    3214:	ea40 2001 	orr.w	r0, r0, r1, lsl #8
    3218:	2103      	movs	r1, #3
    321a:	9300      	str	r3, [sp, #0]
    321c:	f7ff fecc 	bl	2fb8 <Matrix_pin>
    3220:	8821      	ldrh	r1, [r4, #0]
    3222:	f8b4 c002 	ldrh.w	ip, [r4, #2]
    3226:	9a01      	ldr	r2, [sp, #4]
    3228:	9b00      	ldr	r3, [sp, #0]
    322a:	f64f 7eff 	movw	lr, #65535	; 0xffff
    322e:	b148      	cbz	r0, 3244 <Matrix_scan+0xa0>
			{
				// Only update if not going to wrap around
				if ( state->activeCount < DebounceDivThreshold_define ) state->activeCount += 1;
    3230:	4571      	cmp	r1, lr
    3232:	bf18      	it	ne
    3234:	3101      	addne	r1, #1
				state->inactiveCount >>= 1;
    3236:	ea4f 0c5c 	mov.w	ip, ip, lsr #1
			// The advantage of this is that the count is ongoing and never needs to be reset
			// State still needs to be kept track of to deal with what to send to the Macro module
			if ( Matrix_pin( Matrix_rows[ sense ], Type_Sense ) )
			{
				// Only update if not going to wrap around
				if ( state->activeCount < DebounceDivThreshold_define ) state->activeCount += 1;
    323a:	bf18      	it	ne
    323c:	5299      	strhne	r1, [r3, r2]
				state->inactiveCount >>= 1;
    323e:	f8a4 c002 	strh.w	ip, [r4, #2]
    3242:	e009      	b.n	3258 <Matrix_scan+0xb4>
			}
			// Signal Not Detected
			else
			{
				// Only update if not going to wrap around
				if ( state->inactiveCount < DebounceDivThreshold_define ) state->inactiveCount += 1;
    3244:	45f4      	cmp	ip, lr
    3246:	bf18      	it	ne
    3248:	f10c 0c01 	addne.w	ip, ip, #1
				state->activeCount >>= 1;
    324c:	ea4f 0151 	mov.w	r1, r1, lsr #1
			}
			// Signal Not Detected
			else
			{
				// Only update if not going to wrap around
				if ( state->inactiveCount < DebounceDivThreshold_define ) state->inactiveCount += 1;
    3250:	bf18      	it	ne
    3252:	f8a4 c002 	strhne.w	ip, [r4, #2]
				state->activeCount >>= 1;
    3256:	52d1      	strh	r1, [r2, r3]
			// Check for state change if it hasn't been set
			// But only if enough time has passed since last state change
			// Only check if the minimum number of scans has been met
			//   the current state is invalid
			//   and either active or inactive count is over the debounce threshold
			if ( state->curState == KeyState_Invalid )
    3258:	7963      	ldrb	r3, [r4, #5]
    325a:	2b04      	cmp	r3, #4
    325c:	d145      	bne.n	32ea <Matrix_scan+0x146>
			{
				// Determine time since last decision
				uint8_t lastTransition = currentTime - state->prevDecisionTime;
    325e:	79a2      	ldrb	r2, [r4, #6]

				// Attempt state transition
				switch ( state->prevState )
    3260:	7923      	ldrb	r3, [r4, #4]
			//   the current state is invalid
			//   and either active or inactive count is over the debounce threshold
			if ( state->curState == KeyState_Invalid )
			{
				// Determine time since last decision
				uint8_t lastTransition = currentTime - state->prevDecisionTime;
    3262:	ebc2 020b 	rsb	r2, r2, fp
    3266:	b2d2      	uxtb	r2, r2

				// Attempt state transition
				switch ( state->prevState )
    3268:	2b03      	cmp	r3, #3
    326a:	d81a      	bhi.n	32a2 <Matrix_scan+0xfe>
    326c:	e8df f003 	tbb	[pc, r3]
    3270:	0c02020c 	.word	0x0c02020c
				{
				case KeyState_Press:
				case KeyState_Hold:
					if ( state->activeCount > state->inactiveCount )
    3274:	8820      	ldrh	r0, [r4, #0]
    3276:	8861      	ldrh	r1, [r4, #2]
    3278:	4288      	cmp	r0, r1
    327a:	d901      	bls.n	3280 <Matrix_scan+0xdc>
					{
						state->curState = KeyState_Hold;
    327c:	2302      	movs	r3, #2
    327e:	e00c      	b.n	329a <Matrix_scan+0xf6>
					}
					else
					{
						// If not enough time has passed since Hold
						// Keep previous state
						if ( lastTransition < MinDebounceTime_define )
    3280:	2a04      	cmp	r2, #4
    3282:	d907      	bls.n	3294 <Matrix_scan+0xf0>
							//warn_print("FAST Release stopped");
							state->curState = state->prevState;
							continue;
						}

						state->curState = KeyState_Release;
    3284:	2303      	movs	r3, #3
    3286:	e008      	b.n	329a <Matrix_scan+0xf6>
					}
					break;

				case KeyState_Release:
				case KeyState_Off:
					if ( state->activeCount > state->inactiveCount )
    3288:	8820      	ldrh	r0, [r4, #0]
    328a:	8861      	ldrh	r1, [r4, #2]
    328c:	4288      	cmp	r0, r1
    328e:	d906      	bls.n	329e <Matrix_scan+0xfa>
					{
						// If not enough time has passed since Hold
						// Keep previous state
						if ( lastTransition < MinDebounceTime_define )
    3290:	2a04      	cmp	r2, #4
    3292:	d801      	bhi.n	3298 <Matrix_scan+0xf4>
						{
							//warn_print("FAST Press stopped");
							state->curState = state->prevState;
    3294:	7163      	strb	r3, [r4, #5]
							continue;
    3296:	e028      	b.n	32ea <Matrix_scan+0x146>
						}

						state->curState = KeyState_Press;
    3298:	2301      	movs	r3, #1
    329a:	7163      	strb	r3, [r4, #5]
    329c:	e004      	b.n	32a8 <Matrix_scan+0x104>
					}
					else
					{
						state->curState = KeyState_Off;
    329e:	2300      	movs	r3, #0
    32a0:	e7fb      	b.n	329a <Matrix_scan+0xf6>
					}
					break;

				case KeyState_Invalid:
				default:
					erro_print("Matrix scan bug!! Report me!");
    32a2:	4856      	ldr	r0, [pc, #344]	; (33fc <Matrix_scan+0x258>)
    32a4:	f004 faae 	bl	7804 <_print>
					break;
				}

				// Update decision time
				state->prevDecisionTime = currentTime;
    32a8:	f884 b006 	strb.w	fp, [r4, #6]

				// Send keystate to macro module
				Macro_keyState( key, state->curState );
    32ac:	4638      	mov	r0, r7
    32ae:	7961      	ldrb	r1, [r4, #5]
    32b0:	f002 f834 	bl	531c <Macro_keyState>

				// Matrix Debug, only if there is a state change
				if ( matrixDebugMode && state->curState != state->prevState )
    32b4:	4b52      	ldr	r3, [pc, #328]	; (3400 <Matrix_scan+0x25c>)
    32b6:	781b      	ldrb	r3, [r3, #0]
    32b8:	b1bb      	cbz	r3, 32ea <Matrix_scan+0x146>
    32ba:	7961      	ldrb	r1, [r4, #5]
    32bc:	7922      	ldrb	r2, [r4, #4]
    32be:	428a      	cmp	r2, r1
    32c0:	d013      	beq.n	32ea <Matrix_scan+0x146>
				{
					// Basic debug output
					if ( matrixDebugMode == 1 && state->curState == KeyState_Press )
    32c2:	2b01      	cmp	r3, #1
    32c4:	d105      	bne.n	32d2 <Matrix_scan+0x12e>
    32c6:	2901      	cmp	r1, #1
    32c8:	d10f      	bne.n	32ea <Matrix_scan+0x146>
					{
						printHex( key );
    32ca:	4638      	mov	r0, r7
    32cc:	f004 fb23 	bl	7916 <printHex_op>
    32d0:	e008      	b.n	32e4 <Matrix_scan+0x140>
						print(" ");
					}
					// State transition debug output
					else if ( matrixDebugMode == 2 )
    32d2:	2b02      	cmp	r3, #2
    32d4:	d109      	bne.n	32ea <Matrix_scan+0x146>
					{
						printHex( key );
    32d6:	4638      	mov	r0, r7
    32d8:	2101      	movs	r1, #1
    32da:	f004 fb1c 	bl	7916 <printHex_op>
						Matrix_keyPositionDebug( state->curState );
    32de:	7960      	ldrb	r0, [r4, #5]
    32e0:	f7ff ff44 	bl	316c <Matrix_keyPositionDebug>
						print(" ");
    32e4:	4847      	ldr	r0, [pc, #284]	; (3404 <Matrix_scan+0x260>)
    32e6:	f004 fa8d 	bl	7804 <_print>
    32ea:	f108 0801 	add.w	r8, r8, #1
    32ee:	3709      	adds	r7, #9
	{
		// Strobe Pin
		Matrix_pin( Matrix_cols[ strobe ], Type_StrobeOn );

		// Scan each of the sense pins
		for ( uint8_t sense = 0; sense < Matrix_rowsNum; sense++ )
    32f0:	f1b8 0f05 	cmp.w	r8, #5
    32f4:	b2ff      	uxtb	r7, r7
    32f6:	f47f af7d 	bne.w	31f4 <Matrix_scan+0x50>
				}
			}
		}

		// Unstrobe Pin
		Matrix_pin( Matrix_cols[ strobe ], Type_StrobeOff );
    32fa:	4a43      	ldr	r2, [pc, #268]	; (3408 <Matrix_scan+0x264>)
    32fc:	f819 3015 	ldrb.w	r3, [r9, r5, lsl #1]
    3300:	4452      	add	r2, sl
    3302:	2101      	movs	r1, #1
    3304:	7850      	ldrb	r0, [r2, #1]
    3306:	3501      	adds	r5, #1
    3308:	ea43 2000 	orr.w	r0, r3, r0, lsl #8
    330c:	f7ff fe54 	bl	2fb8 <Matrix_pin>

	// Read systick for event scheduling
	uint8_t currentTime = (uint8_t)systick_millis_count;

	// For each strobe, scan each of the sense pins
	for ( uint8_t strobe = 0; strobe < Matrix_colsNum; strobe++ )
    3310:	2d09      	cmp	r5, #9
    3312:	f47f af5e 	bne.w	31d2 <Matrix_scan+0x2e>
		// Unstrobe Pin
		Matrix_pin( Matrix_cols[ strobe ], Type_StrobeOff );
	}

	// State Table Output Debug
	if ( matrixDebugStateCounter > 0 )
    3316:	4b3d      	ldr	r3, [pc, #244]	; (340c <Matrix_scan+0x268>)
    3318:	881a      	ldrh	r2, [r3, #0]
    331a:	2a00      	cmp	r2, #0
    331c:	d05e      	beq.n	33dc <Matrix_scan+0x238>
	{
		// Decrement counter
		matrixDebugStateCounter--;
    331e:	3a01      	subs	r2, #1

		// Output stats on number of scans being done per USB send
		print( NL );
    3320:	483b      	ldr	r0, [pc, #236]	; (3410 <Matrix_scan+0x26c>)

	// State Table Output Debug
	if ( matrixDebugStateCounter > 0 )
	{
		// Decrement counter
		matrixDebugStateCounter--;
    3322:	801a      	strh	r2, [r3, #0]

		// Output stats on number of scans being done per USB send
		print( NL );
    3324:	f004 fa6e 	bl	7804 <_print>
		info_msg("Max scans:      ");
    3328:	483a      	ldr	r0, [pc, #232]	; (3414 <Matrix_scan+0x270>)
    332a:	f004 fa6b 	bl	7804 <_print>
		printHex( matrixMaxScans );
    332e:	4b2d      	ldr	r3, [pc, #180]	; (33e4 <Matrix_scan+0x240>)
    3330:	2101      	movs	r1, #1
    3332:	8818      	ldrh	r0, [r3, #0]
    3334:	f004 faef 	bl	7916 <printHex_op>
		print( NL );
    3338:	4835      	ldr	r0, [pc, #212]	; (3410 <Matrix_scan+0x26c>)
    333a:	f004 fa63 	bl	7804 <_print>
		info_msg("Previous scans: ");
    333e:	4836      	ldr	r0, [pc, #216]	; (3418 <Matrix_scan+0x274>)
    3340:	f004 fa60 	bl	7804 <_print>
		printHex( matrixPrevScans );
    3344:	4b29      	ldr	r3, [pc, #164]	; (33ec <Matrix_scan+0x248>)
    3346:	2101      	movs	r1, #1
    3348:	8818      	ldrh	r0, [r3, #0]
    334a:	f004 fae4 	bl	7916 <printHex_op>
		print( NL );
    334e:	4830      	ldr	r0, [pc, #192]	; (3410 <Matrix_scan+0x26c>)
    3350:	f004 fa58 	bl	7804 <_print>

		// Output current scan number
		info_msg("Scan Number:    ");
    3354:	4831      	ldr	r0, [pc, #196]	; (341c <Matrix_scan+0x278>)
    3356:	f004 fa55 	bl	7804 <_print>
		printHex( scanNum );
    335a:	2101      	movs	r1, #1
    335c:	4630      	mov	r0, r6
    335e:	f004 fada 	bl	7916 <printHex_op>
		print( NL );
    3362:	482b      	ldr	r0, [pc, #172]	; (3410 <Matrix_scan+0x26c>)
    3364:	f004 fa4e 	bl	7804 <_print>

		// Display the state info for each key
		print("<key>:<previous state><current state> <active count> <inactive count>");
    3368:	482d      	ldr	r0, [pc, #180]	; (3420 <Matrix_scan+0x27c>)
    336a:	f004 fa4b 	bl	7804 <_print>
    336e:	2400      	movs	r4, #0
		for ( uint8_t key = 0; key < Matrix_maxKeys; key++ )
		{
			// Every 4 keys, put a newline
			if ( key % 4 == 0 )
    3370:	07a3      	lsls	r3, r4, #30
    3372:	d102      	bne.n	337a <Matrix_scan+0x1d6>
				print( NL );
    3374:	4826      	ldr	r0, [pc, #152]	; (3410 <Matrix_scan+0x26c>)
    3376:	f004 fa45 	bl	7804 <_print>

			print("\033[1m0x");
    337a:	482a      	ldr	r0, [pc, #168]	; (3424 <Matrix_scan+0x280>)
    337c:	f004 fa42 	bl	7804 <_print>
			printHex_op( key, 2 );
    3380:	2102      	movs	r1, #2
    3382:	b2a0      	uxth	r0, r4
    3384:	f004 fac7 	bl	7916 <printHex_op>
			print("\033[0m");
    3388:	4827      	ldr	r0, [pc, #156]	; (3428 <Matrix_scan+0x284>)
    338a:	f004 fa3b 	bl	7804 <_print>
			print(":");
    338e:	4827      	ldr	r0, [pc, #156]	; (342c <Matrix_scan+0x288>)
    3390:	f004 fa38 	bl	7804 <_print>
    3394:	4917      	ldr	r1, [pc, #92]	; (33f4 <Matrix_scan+0x250>)
    3396:	2507      	movs	r5, #7
    3398:	fb05 1504 	mla	r5, r5, r4, r1
    339c:	3401      	adds	r4, #1
			Matrix_keyPositionDebug( Matrix_scanArray[ key ].prevState );
    339e:	7928      	ldrb	r0, [r5, #4]
    33a0:	f7ff fee4 	bl	316c <Matrix_keyPositionDebug>
			Matrix_keyPositionDebug( Matrix_scanArray[ key ].curState );
    33a4:	7968      	ldrb	r0, [r5, #5]
    33a6:	f7ff fee1 	bl	316c <Matrix_keyPositionDebug>
			print(" 0x");
    33aa:	4821      	ldr	r0, [pc, #132]	; (3430 <Matrix_scan+0x28c>)
    33ac:	f004 fa2a 	bl	7804 <_print>
			printHex_op( Matrix_scanArray[ key ].activeCount, 4 );
    33b0:	2104      	movs	r1, #4
    33b2:	8828      	ldrh	r0, [r5, #0]
    33b4:	f004 faaf 	bl	7916 <printHex_op>
			print(" 0x");
    33b8:	481d      	ldr	r0, [pc, #116]	; (3430 <Matrix_scan+0x28c>)
    33ba:	f004 fa23 	bl	7804 <_print>
			printHex_op( Matrix_scanArray[ key ].inactiveCount, 4 );
    33be:	8868      	ldrh	r0, [r5, #2]
    33c0:	2104      	movs	r1, #4
    33c2:	f004 faa8 	bl	7916 <printHex_op>
			print(" ");
    33c6:	480f      	ldr	r0, [pc, #60]	; (3404 <Matrix_scan+0x260>)
    33c8:	f004 fa1c 	bl	7804 <_print>
		printHex( scanNum );
		print( NL );

		// Display the state info for each key
		print("<key>:<previous state><current state> <active count> <inactive count>");
		for ( uint8_t key = 0; key < Matrix_maxKeys; key++ )
    33cc:	2c2d      	cmp	r4, #45	; 0x2d
    33ce:	d1cf      	bne.n	3370 <Matrix_scan+0x1cc>
			print(" 0x");
			printHex_op( Matrix_scanArray[ key ].inactiveCount, 4 );
			print(" ");
		}

		print( NL );
    33d0:	480f      	ldr	r0, [pc, #60]	; (3410 <Matrix_scan+0x26c>)
	}
}
    33d2:	b003      	add	sp, #12
    33d4:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
			print(" 0x");
			printHex_op( Matrix_scanArray[ key ].inactiveCount, 4 );
			print(" ");
		}

		print( NL );
    33d8:	f004 ba14 	b.w	7804 <_print>
	}
}
    33dc:	b003      	add	sp, #12
    33de:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    33e2:	bf00      	nop
    33e4:	1fff92ae 	.word	0x1fff92ae
    33e8:	1fff92aa 	.word	0x1fff92aa
    33ec:	1fff92ac 	.word	0x1fff92ac
    33f0:	1fff92a4 	.word	0x1fff92a4
    33f4:	1fff9dc7 	.word	0x1fff9dc7
    33f8:	1fff89ba 	.word	0x1fff89ba
    33fc:	00008101 	.word	0x00008101
    3400:	1fff92b0 	.word	0x1fff92b0
    3404:	00008156 	.word	0x00008156
    3408:	1fff89a8 	.word	0x1fff89a8
    340c:	1fff92b2 	.word	0x1fff92b2
    3410:	0000bafb 	.word	0x0000bafb
    3414:	00008135 	.word	0x00008135
    3418:	00008158 	.word	0x00008158
    341c:	0000817b 	.word	0x0000817b
    3420:	0000819e 	.word	0x0000819e
    3424:	000081e4 	.word	0x000081e4
    3428:	000095df 	.word	0x000095df
    342c:	000081eb 	.word	0x000081eb
    3430:	000081ed 	.word	0x000081ed

00003434 <cliFunc_lcdColor>:
	print( NL );
	LCD_writeControlReg( cmd );
}

void cliFunc_lcdColor( char* args )
{
    3434:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	char* curArgs;
	char* arg1Ptr;
	char* arg2Ptr = args;
    3436:	2400      	movs	r4, #0
    3438:	9001      	str	r0, [sp, #4]

	// Parse integers from 3 arguments
	for ( uint8_t color = 0; color < 3; color++ )
	{
		curArgs = arg2Ptr;
		CLI_argumentIsolation( curArgs, &arg1Ptr, &arg2Ptr );
    343a:	9801      	ldr	r0, [sp, #4]
    343c:	4669      	mov	r1, sp
    343e:	aa01      	add	r2, sp, #4
    3440:	f003 ff2e 	bl	72a0 <CLI_argumentIsolation>

		// Give up if not enough args given
		if ( *arg1Ptr == '\0' )
    3444:	9800      	ldr	r0, [sp, #0]
    3446:	7803      	ldrb	r3, [r0, #0]
    3448:	b183      	cbz	r3, 346c <cliFunc_lcdColor+0x38>
			return;

		// Convert argument to integer
		rgb[ color ] = numToInt( arg1Ptr );
    344a:	f004 fab9 	bl	79c0 <numToInt>
    344e:	ab02      	add	r3, sp, #8
    3450:	5318      	strh	r0, [r3, r4]
    3452:	3402      	adds	r4, #2

	// Colors
	uint16_t rgb[3]; // Red, Green, Blue

	// Parse integers from 3 arguments
	for ( uint8_t color = 0; color < 3; color++ )
    3454:	2c06      	cmp	r4, #6
    3456:	d1f0      	bne.n	343a <cliFunc_lcdColor+0x6>
		// Convert argument to integer
		rgb[ color ] = numToInt( arg1Ptr );
	}

	// Set PWM channels
	FTM0_C0V = rgb[0];
    3458:	f8bd 2008 	ldrh.w	r2, [sp, #8]
    345c:	4b04      	ldr	r3, [pc, #16]	; (3470 <cliFunc_lcdColor+0x3c>)
    345e:	601a      	str	r2, [r3, #0]
	FTM0_C1V = rgb[1];
    3460:	f8bd 200a 	ldrh.w	r2, [sp, #10]
    3464:	609a      	str	r2, [r3, #8]
	FTM0_C2V = rgb[2];
    3466:	f8bd 200c 	ldrh.w	r2, [sp, #12]
    346a:	611a      	str	r2, [r3, #16]
}
    346c:	b004      	add	sp, #16
    346e:	bd10      	pop	{r4, pc}
    3470:	40038010 	.word	0x40038010

00003474 <SPI_write>:
		| SPI_CTAR_PBR(0) | SPI_CTAR_BR(7);
}

// Write buffer to SPI FIFO
void SPI_write( uint8_t *buffer, uint8_t len )
{
    3474:	b530      	push	{r4, r5, lr}

	for ( uint8_t byte = 0; byte < len; byte++ )
    3476:	2300      	movs	r3, #0
    3478:	b2da      	uxtb	r2, r3
    347a:	428a      	cmp	r2, r1
    347c:	d218      	bcs.n	34b0 <L_107_delayMicroseconds+0x22>
	{
		// Wait for SPI TxFIFO to have 4 or fewer entries
		while ( !( SPI0_SR & SPI_SR_TFFF ) )
    347e:	4a0d      	ldr	r2, [pc, #52]	; (34b4 <L_107_delayMicroseconds+0x26>)
    3480:	6814      	ldr	r4, [r2, #0]
    3482:	f014 7f00 	tst.w	r4, #33554432	; 0x2000000
    3486:	4615      	mov	r5, r2
    3488:	d104      	bne.n	3494 <L_107_delayMicroseconds+0x6>
    348a:	f44f 72a0 	mov.w	r2, #320	; 0x140

0000348e <L_107_delayMicroseconds>:
    348e:	3a01      	subs	r2, #1
    3490:	d1fd      	bne.n	348e <L_107_delayMicroseconds>
    3492:	e7f4      	b.n	347e <SPI_write+0xa>
			delayMicroseconds(10);

		// Write byte to TxFIFO
		// CS0, CTAR0
		SPI0_PUSHR = ( buffer[ byte ] & 0xff ) | SPI_PUSHR_PCS(1);
    3494:	5cc4      	ldrb	r4, [r0, r3]
    3496:	f444 3480 	orr.w	r4, r4, #65536	; 0x10000
    349a:	6094      	str	r4, [r2, #8]

		// Indicate transfer has completed
		while ( !( SPI0_SR & SPI_SR_TCF ) );
    349c:	682c      	ldr	r4, [r5, #0]
    349e:	4a05      	ldr	r2, [pc, #20]	; (34b4 <L_107_delayMicroseconds+0x26>)
    34a0:	2c00      	cmp	r4, #0
    34a2:	dafb      	bge.n	349c <L_107_delayMicroseconds+0xe>
		SPI0_SR |= SPI_SR_TCF;
    34a4:	6814      	ldr	r4, [r2, #0]
    34a6:	f044 4400 	orr.w	r4, r4, #2147483648	; 0x80000000
    34aa:	6014      	str	r4, [r2, #0]
    34ac:	3301      	adds	r3, #1
    34ae:	e7e3      	b.n	3478 <SPI_write+0x4>
	}
}
    34b0:	bd30      	pop	{r4, r5, pc}
    34b2:	bf00      	nop
    34b4:	4002c02c 	.word	0x4002c02c

000034b8 <LCD_writeControlReg>:

// Write to a control register
void LCD_writeControlReg( uint8_t byte )
{
    34b8:	b507      	push	{r0, r1, r2, lr}
    34ba:	f88d 0007 	strb.w	r0, [sp, #7]
	// Wait for TxFIFO to be empt
	while ( SPI0_TxFIFO_CNT != 0 );
    34be:	4b10      	ldr	r3, [pc, #64]	; (3500 <L_197_delayMicroseconds+0x16>)
    34c0:	681b      	ldr	r3, [r3, #0]
    34c2:	f413 4f70 	tst.w	r3, #61440	; 0xf000
    34c6:	d1fa      	bne.n	34be <LCD_writeControlReg+0x6>

	// Set A0 low to enter control register mode
	GPIOC_PCOR |= (1<<7);
    34c8:	4b0e      	ldr	r3, [pc, #56]	; (3504 <L_197_delayMicroseconds+0x1a>)
    34ca:	681a      	ldr	r2, [r3, #0]
    34cc:	f042 0280 	orr.w	r2, r2, #128	; 0x80
    34d0:	601a      	str	r2, [r3, #0]

	// Write byte to SPI FIFO
	SPI_write( &byte, 1 );
    34d2:	f10d 0007 	add.w	r0, sp, #7
    34d6:	2101      	movs	r1, #1
    34d8:	f7ff ffcc 	bl	3474 <SPI_write>

	// Wait for TxFIFO to be empty
	while ( SPI0_TxFIFO_CNT != 0 );
    34dc:	4b08      	ldr	r3, [pc, #32]	; (3500 <L_197_delayMicroseconds+0x16>)
    34de:	681b      	ldr	r3, [r3, #0]
    34e0:	f413 4f70 	tst.w	r3, #61440	; 0xf000
    34e4:	d1fa      	bne.n	34dc <LCD_writeControlReg+0x24>
    34e6:	f44f 73a0 	mov.w	r3, #320	; 0x140

000034ea <L_197_delayMicroseconds>:
    34ea:	3b01      	subs	r3, #1
    34ec:	d1fd      	bne.n	34ea <L_197_delayMicroseconds>

	// Make sure data has transferred
	delayMicroseconds(10); // XXX Adjust if SPI speed changes

	// Set A0 high to go back to display register mode
	GPIOC_PSOR |= (1<<7);
    34ee:	4b06      	ldr	r3, [pc, #24]	; (3508 <L_197_delayMicroseconds+0x1e>)
    34f0:	681a      	ldr	r2, [r3, #0]
    34f2:	f042 0280 	orr.w	r2, r2, #128	; 0x80
    34f6:	601a      	str	r2, [r3, #0]
}
    34f8:	b003      	add	sp, #12
    34fa:	f85d fb04 	ldr.w	pc, [sp], #4
    34fe:	bf00      	nop
    3500:	4002c02c 	.word	0x4002c02c
    3504:	400ff088 	.word	0x400ff088
    3508:	400ff084 	.word	0x400ff084

0000350c <cliFunc_lcdCmd>:
	for ( uint8_t page = 0; page < LCD_TOTAL_VISIBLE_PAGES; page++ )
		LCD_writeDisplayReg( page, (uint8_t *)&STLcdDefaultImage[page * LCD_PAGE_LEN], LCD_PAGE_LEN );
}

void cliFunc_lcdCmd( char* args )
{
    350c:	b513      	push	{r0, r1, r4, lr}
	char* curArgs;
	char* arg1Ptr;
	char* arg2Ptr = args;
    350e:	9001      	str	r0, [sp, #4]

	print( NL ); // No \r\n by default after the command is entered
    3510:	4810      	ldr	r0, [pc, #64]	; (3554 <cliFunc_lcdCmd+0x48>)
    3512:	f004 f977 	bl	7804 <_print>

	curArgs = arg2Ptr; // Use the previous 2nd arg pointer to separate the next arg from the list
	CLI_argumentIsolation( curArgs, &arg1Ptr, &arg2Ptr );
    3516:	9801      	ldr	r0, [sp, #4]
    3518:	4669      	mov	r1, sp
    351a:	aa01      	add	r2, sp, #4
    351c:	f003 fec0 	bl	72a0 <CLI_argumentIsolation>

	// No args
	if ( *arg1Ptr == '\0' )
    3520:	9800      	ldr	r0, [sp, #0]
    3522:	7803      	ldrb	r3, [r0, #0]
    3524:	b1a3      	cbz	r3, 3550 <cliFunc_lcdCmd+0x44>
		return;

	// SPI Command
	uint8_t cmd = (uint8_t)numToInt( arg1Ptr );
    3526:	f004 fa4b 	bl	79c0 <numToInt>

	curArgs = arg2Ptr; // Use the previous 2nd arg pointer to separate the next arg from the list
	CLI_argumentIsolation( curArgs, &arg1Ptr, &arg2Ptr );
    352a:	aa01      	add	r2, sp, #4
	// No args
	if ( *arg1Ptr == '\0' )
		return;

	// SPI Command
	uint8_t cmd = (uint8_t)numToInt( arg1Ptr );
    352c:	b2c4      	uxtb	r4, r0

	curArgs = arg2Ptr; // Use the previous 2nd arg pointer to separate the next arg from the list
	CLI_argumentIsolation( curArgs, &arg1Ptr, &arg2Ptr );
    352e:	4669      	mov	r1, sp
    3530:	9801      	ldr	r0, [sp, #4]
    3532:	f003 feb5 	bl	72a0 <CLI_argumentIsolation>
	if ( *arg1Ptr == '\0' )
		goto cmd;

	// TODO Deal with a0
cmd:
	info_msg("Sending - ");
    3536:	4808      	ldr	r0, [pc, #32]	; (3558 <cliFunc_lcdCmd+0x4c>)
    3538:	f004 f964 	bl	7804 <_print>
	printHex( cmd );
    353c:	4620      	mov	r0, r4
    353e:	2101      	movs	r1, #1
    3540:	f004 f9e9 	bl	7916 <printHex_op>
	print( NL );
    3544:	4803      	ldr	r0, [pc, #12]	; (3554 <cliFunc_lcdCmd+0x48>)
    3546:	f004 f95d 	bl	7804 <_print>
	LCD_writeControlReg( cmd );
    354a:	4620      	mov	r0, r4
    354c:	f7ff ffb4 	bl	34b8 <LCD_writeControlReg>
}
    3550:	b002      	add	sp, #8
    3552:	bd10      	pop	{r4, pc}
    3554:	0000bafb 	.word	0x0000bafb
    3558:	00008898 	.word	0x00008898

0000355c <cliFunc_lcdDisp>:
	FTM0_C1V = rgb[1];
	FTM0_C2V = rgb[2];
}

void cliFunc_lcdDisp( char* args )
{
    355c:	b530      	push	{r4, r5, lr}
    355e:	b085      	sub	sp, #20
	char* arg1Ptr;
	char* arg2Ptr = args;

	// First process page and starting address
	curArgs = arg2Ptr;
	CLI_argumentIsolation( curArgs, &arg1Ptr, &arg2Ptr );
    3560:	a902      	add	r1, sp, #8
    3562:	aa03      	add	r2, sp, #12

void cliFunc_lcdDisp( char* args )
{
	char* curArgs;
	char* arg1Ptr;
	char* arg2Ptr = args;
    3564:	9003      	str	r0, [sp, #12]

	// First process page and starting address
	curArgs = arg2Ptr;
	CLI_argumentIsolation( curArgs, &arg1Ptr, &arg2Ptr );
    3566:	f003 fe9b 	bl	72a0 <CLI_argumentIsolation>

	// Stop processing args if no more are found
	if ( *arg1Ptr == '\0' )
    356a:	9802      	ldr	r0, [sp, #8]
    356c:	7803      	ldrb	r3, [r0, #0]
    356e:	b373      	cbz	r3, 35ce <cliFunc_lcdDisp+0x72>
		return;
	uint8_t page = numToInt( arg1Ptr );
    3570:	f004 fa26 	bl	79c0 <numToInt>

	curArgs = arg2Ptr;
	CLI_argumentIsolation( curArgs, &arg1Ptr, &arg2Ptr );
    3574:	aa03      	add	r2, sp, #12
	CLI_argumentIsolation( curArgs, &arg1Ptr, &arg2Ptr );

	// Stop processing args if no more are found
	if ( *arg1Ptr == '\0' )
		return;
	uint8_t page = numToInt( arg1Ptr );
    3576:	4605      	mov	r5, r0

	curArgs = arg2Ptr;
	CLI_argumentIsolation( curArgs, &arg1Ptr, &arg2Ptr );
    3578:	a902      	add	r1, sp, #8
    357a:	9803      	ldr	r0, [sp, #12]
    357c:	f003 fe90 	bl	72a0 <CLI_argumentIsolation>

	// Stop processing args if no more are found
	if ( *arg1Ptr == '\0' )
    3580:	9802      	ldr	r0, [sp, #8]
    3582:	7802      	ldrb	r2, [r0, #0]
    3584:	b31a      	cbz	r2, 35ce <cliFunc_lcdDisp+0x72>
		return;
	uint8_t address = numToInt( arg1Ptr );
    3586:	f004 fa1b 	bl	79c0 <numToInt>
    358a:	b2c4      	uxtb	r4, r0

	// Set the register page
	LCD_writeControlReg( 0xB0 | ( 0x0F & page ) );
    358c:	f005 000f 	and.w	r0, r5, #15
    3590:	f040 00b0 	orr.w	r0, r0, #176	; 0xb0
    3594:	f7ff ff90 	bl	34b8 <LCD_writeControlReg>

	// Set starting address
	LCD_writeControlReg( 0x10 | ( ( 0xF0 & address ) >> 4 ) );
    3598:	0920      	lsrs	r0, r4, #4
    359a:	f040 0010 	orr.w	r0, r0, #16
    359e:	f7ff ff8b 	bl	34b8 <LCD_writeControlReg>
	LCD_writeControlReg( 0x00 | ( 0x0F & address ));
    35a2:	f004 000f 	and.w	r0, r4, #15
    35a6:	f7ff ff87 	bl	34b8 <LCD_writeControlReg>

	// Process all args
	for ( ;; )
	{
		curArgs = arg2Ptr;
		CLI_argumentIsolation( curArgs, &arg1Ptr, &arg2Ptr );
    35aa:	9803      	ldr	r0, [sp, #12]
    35ac:	a902      	add	r1, sp, #8
    35ae:	aa03      	add	r2, sp, #12
    35b0:	f003 fe76 	bl	72a0 <CLI_argumentIsolation>

		// Stop processing args if no more are found
		if ( *arg1Ptr == '\0' )
    35b4:	9802      	ldr	r0, [sp, #8]
    35b6:	7803      	ldrb	r3, [r0, #0]
    35b8:	b14b      	cbz	r3, 35ce <cliFunc_lcdDisp+0x72>
			break;

		uint8_t value = numToInt( arg1Ptr );
    35ba:	f004 fa01 	bl	79c0 <numToInt>
    35be:	ab04      	add	r3, sp, #16

		// Write buffer to SPI
		SPI_write( &value, 1 );
    35c0:	2101      	movs	r1, #1

		// Stop processing args if no more are found
		if ( *arg1Ptr == '\0' )
			break;

		uint8_t value = numToInt( arg1Ptr );
    35c2:	f803 0d09 	strb.w	r0, [r3, #-9]!

		// Write buffer to SPI
		SPI_write( &value, 1 );
    35c6:	4618      	mov	r0, r3
    35c8:	f7ff ff54 	bl	3474 <SPI_write>
	}
    35cc:	e7ed      	b.n	35aa <cliFunc_lcdDisp+0x4e>
}
    35ce:	b005      	add	sp, #20
    35d0:	bd30      	pop	{r4, r5, pc}

000035d2 <LCD_writeDisplayReg>:

// Write to display register
// Pages 0-7 normal display
// Page  8   icon buffer
void LCD_writeDisplayReg( uint8_t page, uint8_t *buffer, uint8_t len )
{
    35d2:	b538      	push	{r3, r4, r5, lr}
	// Set the register page
	LCD_writeControlReg( 0xB0 | ( 0x0F & page ) );
    35d4:	f000 000f 	and.w	r0, r0, #15
    35d8:	f040 00b0 	orr.w	r0, r0, #176	; 0xb0

// Write to display register
// Pages 0-7 normal display
// Page  8   icon buffer
void LCD_writeDisplayReg( uint8_t page, uint8_t *buffer, uint8_t len )
{
    35dc:	460c      	mov	r4, r1
    35de:	4615      	mov	r5, r2
	// Set the register page
	LCD_writeControlReg( 0xB0 | ( 0x0F & page ) );
    35e0:	f7ff ff6a 	bl	34b8 <LCD_writeControlReg>

	// Set display start line
	LCD_writeControlReg( 0x40 );
    35e4:	2040      	movs	r0, #64	; 0x40
    35e6:	f7ff ff67 	bl	34b8 <LCD_writeControlReg>

	// Reset Column Address
	LCD_writeControlReg( 0x10 );
    35ea:	2010      	movs	r0, #16
    35ec:	f7ff ff64 	bl	34b8 <LCD_writeControlReg>
	LCD_writeControlReg( 0x00 );
    35f0:	2000      	movs	r0, #0
    35f2:	f7ff ff61 	bl	34b8 <LCD_writeControlReg>

	// Write buffer to SPI
	SPI_write( buffer, len );
    35f6:	4620      	mov	r0, r4
    35f8:	4629      	mov	r1, r5
}
    35fa:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	// Reset Column Address
	LCD_writeControlReg( 0x10 );
	LCD_writeControlReg( 0x00 );

	// Write buffer to SPI
	SPI_write( buffer, len );
    35fe:	f7ff bf39 	b.w	3474 <SPI_write>
    3602:	0000      	movs	r0, r0

00003604 <cliFunc_lcdTest>:
{
	LCD_initialize();
}

void cliFunc_lcdTest( char* args )
{
    3604:	b510      	push	{r4, lr}
    3606:	2400      	movs	r4, #0
	// Write default image
	for ( uint8_t page = 0; page < LCD_TOTAL_VISIBLE_PAGES; page++ )
		LCD_writeDisplayReg( page, (uint8_t *)&STLcdDefaultImage[page * LCD_PAGE_LEN], LCD_PAGE_LEN );
    3608:	4905      	ldr	r1, [pc, #20]	; (3620 <cliFunc_lcdTest+0x1c>)
    360a:	b2e0      	uxtb	r0, r4
    360c:	eb01 11c4 	add.w	r1, r1, r4, lsl #7
    3610:	2280      	movs	r2, #128	; 0x80
    3612:	3401      	adds	r4, #1
    3614:	f7ff ffdd 	bl	35d2 <LCD_writeDisplayReg>
}

void cliFunc_lcdTest( char* args )
{
	// Write default image
	for ( uint8_t page = 0; page < LCD_TOTAL_VISIBLE_PAGES; page++ )
    3618:	2c04      	cmp	r4, #4
    361a:	d1f5      	bne.n	3608 <cliFunc_lcdTest+0x4>
		LCD_writeDisplayReg( page, (uint8_t *)&STLcdDefaultImage[page * LCD_PAGE_LEN], LCD_PAGE_LEN );
}
    361c:	bd10      	pop	{r4, pc}
    361e:	bf00      	nop
    3620:	0000897d 	.word	0x0000897d

00003624 <LCD_clear>:
	while ( SPI0_TxFIFO_CNT != 0 );
}

// Clear Display
void LCD_clear()
{
    3624:	b537      	push	{r0, r1, r2, r4, r5, lr}
	// Setup each page
	for ( uint8_t page = 0; page < LCD_TOTAL_PAGES; page++ )
    3626:	2400      	movs	r4, #0
}

inline void LCD_clearPage( uint8_t page )
{
	// Set the register page
	LCD_writeControlReg( 0xB0 | ( 0x0F & page ) );
    3628:	f044 00b0 	orr.w	r0, r4, #176	; 0xb0
    362c:	f7ff ff44 	bl	34b8 <LCD_writeControlReg>

	// Set display start line
	LCD_writeControlReg( 0x40 );
    3630:	2040      	movs	r0, #64	; 0x40
    3632:	f7ff ff41 	bl	34b8 <LCD_writeControlReg>

	// Reset Column Address
	LCD_writeControlReg( 0x10 );
    3636:	2010      	movs	r0, #16
    3638:	f7ff ff3e 	bl	34b8 <LCD_writeControlReg>
	LCD_writeControlReg( 0x00 );
    363c:	2000      	movs	r0, #0
    363e:	f7ff ff3b 	bl	34b8 <LCD_writeControlReg>
    3642:	2581      	movs	r5, #129	; 0x81

	for ( uint8_t page_reg = 0; page_reg < LCD_PAGE_LEN; page_reg++ )
    3644:	3d01      	subs	r5, #1
    3646:	d007      	beq.n	3658 <LCD_clear+0x34>
	{
		uint8_t byte = 0;
    3648:	a802      	add	r0, sp, #8
    364a:	2300      	movs	r3, #0
    364c:	f800 3d01 	strb.w	r3, [r0, #-1]!

		// Write buffer to SPI
		SPI_write( &byte, 1 );
    3650:	2101      	movs	r1, #1
    3652:	f7ff ff0f 	bl	3474 <SPI_write>
    3656:	e7f5      	b.n	3644 <LCD_clear+0x20>
	}

	// Wait for TxFIFO to be empty
	while ( SPI0_TxFIFO_CNT != 0 );
    3658:	4b0b      	ldr	r3, [pc, #44]	; (3688 <LCD_clear+0x64>)
    365a:	681d      	ldr	r5, [r3, #0]
    365c:	f3c5 3503 	ubfx	r5, r5, #12, #4
    3660:	2d00      	cmp	r5, #0
    3662:	d1f9      	bne.n	3658 <LCD_clear+0x34>

// Clear Display
void LCD_clear()
{
	// Setup each page
	for ( uint8_t page = 0; page < LCD_TOTAL_PAGES; page++ )
    3664:	3401      	adds	r4, #1
    3666:	b2e4      	uxtb	r4, r4
    3668:	2c09      	cmp	r4, #9
    366a:	d1dd      	bne.n	3628 <LCD_clear+0x4>
		LCD_clearPage( page );
	}

	// Reset Page, Start Line, and Column Address
	// Page
	LCD_writeControlReg( 0xB0 );
    366c:	20b0      	movs	r0, #176	; 0xb0
    366e:	f7ff ff23 	bl	34b8 <LCD_writeControlReg>

	// Start Line
	LCD_writeControlReg( 0x40 );
    3672:	2040      	movs	r0, #64	; 0x40
    3674:	f7ff ff20 	bl	34b8 <LCD_writeControlReg>

	// Reset Column Address
	LCD_writeControlReg( 0x10 );
    3678:	2010      	movs	r0, #16
    367a:	f7ff ff1d 	bl	34b8 <LCD_writeControlReg>
	LCD_writeControlReg( 0x00 );
    367e:	4628      	mov	r0, r5
    3680:	f7ff ff1a 	bl	34b8 <LCD_writeControlReg>
}
    3684:	b003      	add	sp, #12
    3686:	bd30      	pop	{r4, r5, pc}
    3688:	4002c02c 	.word	0x4002c02c

0000368c <LCD_initialize>:

// Intialize display
void LCD_initialize()
{
    368c:	b508      	push	{r3, lr}
	// ADC Select (Normal)
	LCD_writeControlReg( 0xA0 );
    368e:	20a0      	movs	r0, #160	; 0xa0
    3690:	f7ff ff12 	bl	34b8 <LCD_writeControlReg>

	// LCD Off
	LCD_writeControlReg( 0xAE );
    3694:	20ae      	movs	r0, #174	; 0xae
    3696:	f7ff ff0f 	bl	34b8 <LCD_writeControlReg>

	// COM Scan Output Direction
	LCD_writeControlReg( 0xC0 );
    369a:	20c0      	movs	r0, #192	; 0xc0
    369c:	f7ff ff0c 	bl	34b8 <LCD_writeControlReg>

	// LCD Bias (1/6 bias)
	LCD_writeControlReg( 0xA2 );
    36a0:	20a2      	movs	r0, #162	; 0xa2
    36a2:	f7ff ff09 	bl	34b8 <LCD_writeControlReg>

	// Power Supply Operating Mode (Internal Only)
	LCD_writeControlReg( 0x2F );
    36a6:	202f      	movs	r0, #47	; 0x2f
    36a8:	f7ff ff06 	bl	34b8 <LCD_writeControlReg>

	// Internal Rb/Ra Ratio
	LCD_writeControlReg( 0x26 );
    36ac:	2026      	movs	r0, #38	; 0x26
    36ae:	f7ff ff03 	bl	34b8 <LCD_writeControlReg>

	// Reset
	LCD_writeControlReg( 0xE2 );
    36b2:	20e2      	movs	r0, #226	; 0xe2
    36b4:	f7ff ff00 	bl	34b8 <LCD_writeControlReg>

	// Electric volume mode set, and value
	LCD_writeControlReg( 0x81 );
    36b8:	2081      	movs	r0, #129	; 0x81
    36ba:	f7ff fefd 	bl	34b8 <LCD_writeControlReg>
	LCD_writeControlReg( 0x00 );
    36be:	2000      	movs	r0, #0
    36c0:	f7ff fefa 	bl	34b8 <LCD_writeControlReg>

	// LCD On
	LCD_writeControlReg( 0xAF );
    36c4:	20af      	movs	r0, #175	; 0xaf
    36c6:	f7ff fef7 	bl	34b8 <LCD_writeControlReg>

	// Clear Display RAM
	LCD_clear();
}
    36ca:	e8bd 4008 	ldmia.w	sp!, {r3, lr}

	// LCD On
	LCD_writeControlReg( 0xAF );

	// Clear Display RAM
	LCD_clear();
    36ce:	f7ff bfa9 	b.w	3624 <LCD_clear>

000036d2 <cliFunc_lcdInit>:

// ----- CLI Command Functions -----

void cliFunc_lcdInit( char* args )
{
	LCD_initialize();
    36d2:	f7ff bfdb 	b.w	368c <LCD_initialize>
    36d6:	0000      	movs	r0, r0

000036d8 <LCD_setup>:
	LCD_clear();
}

// Setup
inline void LCD_setup()
{
    36d8:	b510      	push	{r4, lr}
	// Register Scan CLI dictionary
	CLI_registerDictionary( lcdCLIDict, lcdCLIDictName );
    36da:	482f      	ldr	r0, [pc, #188]	; (3798 <LCD_setup+0xc0>)
    36dc:	492f      	ldr	r1, [pc, #188]	; (379c <LCD_setup+0xc4>)
    36de:	f003 fe53 	bl	7388 <CLI_registerDictionary>
// ----- Functions -----

inline void SPI_setup()
{
	// Enable SPI internal clock
	SIM_SCGC6 |= SIM_SCGC6_SPI0;
    36e2:	4b2f      	ldr	r3, [pc, #188]	; (37a0 <LCD_setup+0xc8>)
    36e4:	681a      	ldr	r2, [r3, #0]
    36e6:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
    36ea:	601a      	str	r2, [r3, #0]

	// Setup MOSI (SOUT) and SCLK (SCK)
	PORTC_PCR6 = PORT_PCR_DSE | PORT_PCR_MUX(2);
    36ec:	4a2d      	ldr	r2, [pc, #180]	; (37a4 <LCD_setup+0xcc>)
    36ee:	f44f 7310 	mov.w	r3, #576	; 0x240
    36f2:	6013      	str	r3, [r2, #0]
	PORTC_PCR5 = PORT_PCR_DSE | PORT_PCR_MUX(2);
    36f4:	f842 3c04 	str.w	r3, [r2, #-4]

	// Setup SS (PCS)
	PORTC_PCR4 = PORT_PCR_DSE | PORT_PCR_MUX(2);
    36f8:	f842 3c08 	str.w	r3, [r2, #-8]

	// Master Mode, CS0
	SPI0_MCR = SPI_MCR_MSTR | SPI_MCR_PCSIS(1);
    36fc:	4b2a      	ldr	r3, [pc, #168]	; (37a8 <LCD_setup+0xd0>)
    36fe:	4a2b      	ldr	r2, [pc, #172]	; (37ac <LCD_setup+0xd4>)
    3700:	601a      	str	r2, [r3, #0]

	// DSPI Clock and Transfer Attributes
	// Frame Size: 8 bits
	// MSB First
	// CLK Low by default
	SPI0_CTAR0 = SPI_CTAR_FMSZ(7)
    3702:	4a2b      	ldr	r2, [pc, #172]	; (37b0 <LCD_setup+0xd8>)
    3704:	60da      	str	r2, [r3, #12]
	// Initialize SPI
	SPI_setup();

	// Setup Register Control Signal (A0)
	// Start in display register mode (1)
	GPIOC_PDDR |= (1<<7);
    3706:	4a2b      	ldr	r2, [pc, #172]	; (37b4 <LCD_setup+0xdc>)
    3708:	6813      	ldr	r3, [r2, #0]
    370a:	f043 0380 	orr.w	r3, r3, #128	; 0x80
    370e:	6013      	str	r3, [r2, #0]
	PORTC_PCR7 = PORT_PCR_SRE | PORT_PCR_DSE | PORT_PCR_MUX(1);
    3710:	4b29      	ldr	r3, [pc, #164]	; (37b8 <LCD_setup+0xe0>)
    3712:	f44f 71a2 	mov.w	r1, #324	; 0x144
    3716:	6019      	str	r1, [r3, #0]
	GPIOC_PSOR |= (1<<7);
    3718:	4b28      	ldr	r3, [pc, #160]	; (37bc <LCD_setup+0xe4>)
    371a:	6818      	ldr	r0, [r3, #0]
    371c:	f040 0080 	orr.w	r0, r0, #128	; 0x80
    3720:	6018      	str	r0, [r3, #0]

	// Setup LCD Reset pin (RST)
	// 0 - Reset, 1 - Normal Operation
	// Start in normal mode (1)
	GPIOC_PDDR |= (1<<8);
    3722:	6810      	ldr	r0, [r2, #0]
    3724:	f440 7080 	orr.w	r0, r0, #256	; 0x100
    3728:	6010      	str	r0, [r2, #0]
	PORTC_PCR8 = PORT_PCR_SRE | PORT_PCR_DSE | PORT_PCR_MUX(1);
    372a:	4a25      	ldr	r2, [pc, #148]	; (37c0 <LCD_setup+0xe8>)
    372c:	6011      	str	r1, [r2, #0]
	GPIOC_PSOR |= (1<<8);
    372e:	681a      	ldr	r2, [r3, #0]
    3730:	f442 7280 	orr.w	r2, r2, #256	; 0x100
    3734:	601a      	str	r2, [r3, #0]

	// Run LCD intialization sequence
	LCD_initialize();
    3736:	f7ff ffa9 	bl	368c <LCD_initialize>
    373a:	2400      	movs	r4, #0

	// Write default image to LCD
	for ( uint8_t page = 0; page < LCD_TOTAL_VISIBLE_PAGES; page++ )
		LCD_writeDisplayReg( page, (uint8_t*)&STLcdDefaultImage[page * LCD_PAGE_LEN], LCD_PAGE_LEN );
    373c:	4921      	ldr	r1, [pc, #132]	; (37c4 <LCD_setup+0xec>)
    373e:	b2e0      	uxtb	r0, r4
    3740:	eb01 11c4 	add.w	r1, r1, r4, lsl #7
    3744:	2280      	movs	r2, #128	; 0x80
    3746:	3401      	adds	r4, #1
    3748:	f7ff ff43 	bl	35d2 <LCD_writeDisplayReg>

	// Run LCD intialization sequence
	LCD_initialize();

	// Write default image to LCD
	for ( uint8_t page = 0; page < LCD_TOTAL_VISIBLE_PAGES; page++ )
    374c:	2c04      	cmp	r4, #4
    374e:	d1f5      	bne.n	373c <LCD_setup+0x64>
		LCD_writeDisplayReg( page, (uint8_t*)&STLcdDefaultImage[page * LCD_PAGE_LEN], LCD_PAGE_LEN );

	// Setup Backlight
	SIM_SCGC6 |= SIM_SCGC6_FTM0;
    3750:	4b13      	ldr	r3, [pc, #76]	; (37a0 <LCD_setup+0xc8>)
	// System clock, /w prescalar setting
	FTM0_SC = FTM_SC_CLKS(1) | FTM_SC_PS( STLcdBacklightPrescalar_define );

	// Red
	FTM0_C0V = STLcdBacklightRed_define;
	PORTC_PCR1 = PORT_PCR_SRE | PORT_PCR_DSE | PORT_PCR_MUX(4);
    3752:	491d      	ldr	r1, [pc, #116]	; (37c8 <LCD_setup+0xf0>)
	// Write default image to LCD
	for ( uint8_t page = 0; page < LCD_TOTAL_VISIBLE_PAGES; page++ )
		LCD_writeDisplayReg( page, (uint8_t*)&STLcdDefaultImage[page * LCD_PAGE_LEN], LCD_PAGE_LEN );

	// Setup Backlight
	SIM_SCGC6 |= SIM_SCGC6_FTM0;
    3754:	681a      	ldr	r2, [r3, #0]
    3756:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
    375a:	601a      	str	r2, [r3, #0]
	FTM0_CNT = 0; // Reset counter
    375c:	4b1b      	ldr	r3, [pc, #108]	; (37cc <LCD_setup+0xf4>)
    375e:	2200      	movs	r2, #0
    3760:	601a      	str	r2, [r3, #0]

	// PWM Period
	// 16-bit maximum
	FTM0_MOD = 0xFFFF;
    3762:	f64f 72ff 	movw	r2, #65535	; 0xffff
    3766:	605a      	str	r2, [r3, #4]

	// Set FTM to PWM output - Edge Aligned, Low-true pulses
	FTM0_C0SC = 0x24; // MSnB:MSnA = 10, ELSnB:ELSnA = 01
    3768:	4a19      	ldr	r2, [pc, #100]	; (37d0 <LCD_setup+0xf8>)
    376a:	2324      	movs	r3, #36	; 0x24
    376c:	6013      	str	r3, [r2, #0]
	FTM0_C1SC = 0x24;
    376e:	6093      	str	r3, [r2, #8]
	FTM0_C2SC = 0x24;
    3770:	6113      	str	r3, [r2, #16]
	// 7 - 562 500  Hz ->   4 Hz
	// Using a higher pre-scalar without flicker is possible but FTM0_MOD will need to be reduced
	// Which will reduce the brightness range

	// System clock, /w prescalar setting
	FTM0_SC = FTM_SC_CLKS(1) | FTM_SC_PS( STLcdBacklightPrescalar_define );
    3772:	4b18      	ldr	r3, [pc, #96]	; (37d4 <LCD_setup+0xfc>)
    3774:	2208      	movs	r2, #8
    3776:	601a      	str	r2, [r3, #0]

	// Red
	FTM0_C0V = STLcdBacklightRed_define;
    3778:	f640 72ff 	movw	r2, #4095	; 0xfff
    377c:	611a      	str	r2, [r3, #16]
	PORTC_PCR1 = PORT_PCR_SRE | PORT_PCR_DSE | PORT_PCR_MUX(4);
    377e:	f240 4344 	movw	r3, #1092	; 0x444
    3782:	600b      	str	r3, [r1, #0]

	// Green
	FTM0_C1V = STLcdBacklightGreen_define;
    3784:	4914      	ldr	r1, [pc, #80]	; (37d8 <LCD_setup+0x100>)
    3786:	600a      	str	r2, [r1, #0]
	PORTC_PCR2 = PORT_PCR_SRE | PORT_PCR_DSE | PORT_PCR_MUX(4);
    3788:	4914      	ldr	r1, [pc, #80]	; (37dc <LCD_setup+0x104>)
    378a:	600b      	str	r3, [r1, #0]

	// Blue
	FTM0_C2V = STLcdBacklightBlue_define;
    378c:	4914      	ldr	r1, [pc, #80]	; (37e0 <LCD_setup+0x108>)
    378e:	600a      	str	r2, [r1, #0]
	PORTC_PCR3 = PORT_PCR_SRE | PORT_PCR_DSE | PORT_PCR_MUX(4);
    3790:	4a14      	ldr	r2, [pc, #80]	; (37e4 <LCD_setup+0x10c>)
    3792:	6013      	str	r3, [r2, #0]
    3794:	bd10      	pop	{r4, pc}
    3796:	bf00      	nop
    3798:	00008850 	.word	0x00008850
    379c:	00008836 	.word	0x00008836
    37a0:	4004803c 	.word	0x4004803c
    37a4:	4004b018 	.word	0x4004b018
    37a8:	4002c000 	.word	0x4002c000
    37ac:	80010000 	.word	0x80010000
    37b0:	38007777 	.word	0x38007777
    37b4:	400ff094 	.word	0x400ff094
    37b8:	4004b01c 	.word	0x4004b01c
    37bc:	400ff084 	.word	0x400ff084
    37c0:	4004b020 	.word	0x4004b020
    37c4:	0000897d 	.word	0x0000897d
    37c8:	4004b004 	.word	0x4004b004
    37cc:	40038004 	.word	0x40038004
    37d0:	4003800c 	.word	0x4003800c
    37d4:	40038000 	.word	0x40038000
    37d8:	40038018 	.word	0x40038018
    37dc:	4004b008 	.word	0x4004b008
    37e0:	40038020 	.word	0x40038020
    37e4:	4004b00c 	.word	0x4004b00c

000037e8 <LCD_scan>:

// LCD State processing loop
inline uint8_t LCD_scan()
{
	return 0;
}
    37e8:	2000      	movs	r0, #0
    37ea:	4770      	bx	lr

000037ec <LCD_layerStackExact_capability>:
typedef struct LCD_layerStackExact_args {
	uint8_t numArgs;
	uint16_t layers[4];
} LCD_layerStackExact_args;
void LCD_layerStackExact_capability( uint8_t state, uint8_t stateType, uint8_t *args )
{
    37ec:	b5f0      	push	{r4, r5, r6, r7, lr}
	// Display capability name
	if ( stateType == 0xFF && state == 0xFF )
    37ee:	29ff      	cmp	r1, #255	; 0xff
typedef struct LCD_layerStackExact_args {
	uint8_t numArgs;
	uint16_t layers[4];
} LCD_layerStackExact_args;
void LCD_layerStackExact_capability( uint8_t state, uint8_t stateType, uint8_t *args )
{
    37f0:	f2ad 5d44 	subw	sp, sp, #1348	; 0x544
    37f4:	4614      	mov	r4, r2
	// Display capability name
	if ( stateType == 0xFF && state == 0xFF )
    37f6:	d105      	bne.n	3804 <LCD_layerStackExact_capability+0x18>
    37f8:	28ff      	cmp	r0, #255	; 0xff
    37fa:	d103      	bne.n	3804 <LCD_layerStackExact_capability+0x18>
	{
		print("LCD_layerStackExact_capability(num,layer1,layer2,layer3,layer4)");
    37fc:	483b      	ldr	r0, [pc, #236]	; (38ec <LCD_layerStackExact_capability+0x100>)
    37fe:	f004 f801 	bl	7804 <_print>
    3802:	e06f      	b.n	38e4 <LCD_layerStackExact_capability+0xf8>

	// Read arguments
	LCD_layerStackExact_args *stack_args = (LCD_layerStackExact_args*)args;

	// Number data for LCD
	const uint8_t numbers[10][128] = {
    3804:	f44f 62a0 	mov.w	r2, #1280	; 0x500
    3808:	a810      	add	r0, sp, #64	; 0x40
    380a:	4939      	ldr	r1, [pc, #228]	; (38f0 <LCD_layerStackExact_capability+0x104>)
    380c:	f7fe feb6 	bl	257c <memcpy>
		{ STLcdNumber8_define },
		{ STLcdNumber9_define },
	};

	// Color data for numbers
	const uint16_t colors[10][3] = {
    3810:	4b38      	ldr	r3, [pc, #224]	; (38f4 <LCD_layerStackExact_capability+0x108>)
    3812:	ae01      	add	r6, sp, #4
    3814:	4632      	mov	r2, r6
    3816:	f103 0738 	add.w	r7, r3, #56	; 0x38
    381a:	6818      	ldr	r0, [r3, #0]
    381c:	6859      	ldr	r1, [r3, #4]
    381e:	4615      	mov	r5, r2
    3820:	c503      	stmia	r5!, {r0, r1}
    3822:	3308      	adds	r3, #8
    3824:	42bb      	cmp	r3, r7
    3826:	462a      	mov	r2, r5
    3828:	d1f7      	bne.n	381a <LCD_layerStackExact_capability+0x2e>
    382a:	6818      	ldr	r0, [r3, #0]
    382c:	4932      	ldr	r1, [pc, #200]	; (38f8 <LCD_layerStackExact_capability+0x10c>)
    382e:	6028      	str	r0, [r5, #0]
		{ STLcdNumber8Color_define },
		{ STLcdNumber9Color_define },
	};

	// Only display if there are layers active
	if ( stack_args->numArgs > 0 )
    3830:	7822      	ldrb	r2, [r4, #0]
    3832:	2a00      	cmp	r2, #0
    3834:	d045      	beq.n	38c2 <LCD_layerStackExact_capability+0xd6>
	{
		// Set the color according to the "top-of-stack" layer
		uint16_t layerIndex = stack_args->layers[0];
		FTM0_C0V = colors[ layerIndex ][0];
    3836:	8863      	ldrh	r3, [r4, #2]
    3838:	2206      	movs	r2, #6
    383a:	435a      	muls	r2, r3
    383c:	18b3      	adds	r3, r6, r2
    383e:	5ab2      	ldrh	r2, [r6, r2]
    3840:	600a      	str	r2, [r1, #0]
		FTM0_C1V = colors[ layerIndex ][1];
    3842:	8859      	ldrh	r1, [r3, #2]
    3844:	4a2d      	ldr	r2, [pc, #180]	; (38fc <LCD_layerStackExact_capability+0x110>)
    3846:	6011      	str	r1, [r2, #0]
		FTM0_C2V = colors[ layerIndex ][2];
    3848:	889a      	ldrh	r2, [r3, #4]
    384a:	4b2d      	ldr	r3, [pc, #180]	; (3900 <LCD_layerStackExact_capability+0x114>)
    384c:	2500      	movs	r5, #0
    384e:	601a      	str	r2, [r3, #0]
		// XXX Many of the values here are hard-coded
		//     Eventually a proper font rendering engine should take care of things like this... -HaaTa
		for ( uint8_t page = 0; page < LCD_TOTAL_VISIBLE_PAGES; page++ )
		{
			// Set the register page
			LCD_writeControlReg( 0xB0 | ( 0x0F & page ) );
    3850:	f065 004f 	orn	r0, r5, #79	; 0x4f
    3854:	b2c0      	uxtb	r0, r0
    3856:	f7ff fe2f 	bl	34b8 <LCD_writeControlReg>

			// Set starting address
			LCD_writeControlReg( 0x10 );
    385a:	2010      	movs	r0, #16
    385c:	f7ff fe2c 	bl	34b8 <LCD_writeControlReg>
			LCD_writeControlReg( 0x00 );
    3860:	2000      	movs	r0, #0
    3862:	f7ff fe29 	bl	34b8 <LCD_writeControlReg>
    3866:	016f      	lsls	r7, r5, #5

			// Write data
			for ( uint16_t layer = 0; layer < stack_args->numArgs; layer++ )
    3868:	2600      	movs	r6, #0
    386a:	7823      	ldrb	r3, [r4, #0]
    386c:	42b3      	cmp	r3, r6
    386e:	d90f      	bls.n	3890 <LCD_layerStackExact_capability+0xa4>
			{
				layerIndex = stack_args->layers[ layer ];
    3870:	eb04 0346 	add.w	r3, r4, r6, lsl #1
				{
					layerIndex = 0;
				}

				// Write page of number to display
				SPI_write( (uint8_t*)&numbers[ layerIndex ][ page * 32 ], 32 );
    3874:	2120      	movs	r1, #32
			LCD_writeControlReg( 0x00 );

			// Write data
			for ( uint16_t layer = 0; layer < stack_args->numArgs; layer++ )
			{
				layerIndex = stack_args->layers[ layer ];
    3876:	8858      	ldrh	r0, [r3, #2]

				// Default to 0, if over 9
				if ( layerIndex > 9 )
				{
					layerIndex = 0;
    3878:	2809      	cmp	r0, #9
    387a:	bf88      	it	hi
    387c:	2000      	movhi	r0, #0
				}

				// Write page of number to display
				SPI_write( (uint8_t*)&numbers[ layerIndex ][ page * 32 ], 32 );
    387e:	ab10      	add	r3, sp, #64	; 0x40
    3880:	eb07 10c0 	add.w	r0, r7, r0, lsl #7
    3884:	4418      	add	r0, r3
			// Set starting address
			LCD_writeControlReg( 0x10 );
			LCD_writeControlReg( 0x00 );

			// Write data
			for ( uint16_t layer = 0; layer < stack_args->numArgs; layer++ )
    3886:	3601      	adds	r6, #1
				{
					layerIndex = 0;
				}

				// Write page of number to display
				SPI_write( (uint8_t*)&numbers[ layerIndex ][ page * 32 ], 32 );
    3888:	f7ff fdf4 	bl	3474 <SPI_write>
			// Set starting address
			LCD_writeControlReg( 0x10 );
			LCD_writeControlReg( 0x00 );

			// Write data
			for ( uint16_t layer = 0; layer < stack_args->numArgs; layer++ )
    388c:	b2b6      	uxth	r6, r6
    388e:	e7ec      	b.n	386a <LCD_layerStackExact_capability+0x7e>
				// Write page of number to display
				SPI_write( (uint8_t*)&numbers[ layerIndex ][ page * 32 ], 32 );
			}

			// Blank out rest of display
			uint8_t data = 0;
    3890:	2600      	movs	r6, #0
    3892:	f88d 6003 	strb.w	r6, [sp, #3]
			for ( uint8_t c = 0; c < 4 - stack_args->numArgs; c++ )
    3896:	7823      	ldrb	r3, [r4, #0]
    3898:	f1c3 0304 	rsb	r3, r3, #4
    389c:	429e      	cmp	r6, r3
    389e:	da0c      	bge.n	38ba <LCD_layerStackExact_capability+0xce>
    38a0:	2720      	movs	r7, #32
			{
				for ( uint8_t byte = 0; byte < 32; byte++ )
				{
					SPI_write( &data, 1 );
    38a2:	f10d 0003 	add.w	r0, sp, #3
    38a6:	2101      	movs	r1, #1
    38a8:	3f01      	subs	r7, #1
    38aa:	f7ff fde3 	bl	3474 <SPI_write>

			// Blank out rest of display
			uint8_t data = 0;
			for ( uint8_t c = 0; c < 4 - stack_args->numArgs; c++ )
			{
				for ( uint8_t byte = 0; byte < 32; byte++ )
    38ae:	f017 07ff 	ands.w	r7, r7, #255	; 0xff
    38b2:	d1f6      	bne.n	38a2 <LCD_layerStackExact_capability+0xb6>
				SPI_write( (uint8_t*)&numbers[ layerIndex ][ page * 32 ], 32 );
			}

			// Blank out rest of display
			uint8_t data = 0;
			for ( uint8_t c = 0; c < 4 - stack_args->numArgs; c++ )
    38b4:	3601      	adds	r6, #1
    38b6:	b2f6      	uxtb	r6, r6
    38b8:	e7ed      	b.n	3896 <LCD_layerStackExact_capability+0xaa>
    38ba:	3501      	adds	r5, #1
		FTM0_C2V = colors[ layerIndex ][2];

		// Iterate through each of the pages
		// XXX Many of the values here are hard-coded
		//     Eventually a proper font rendering engine should take care of things like this... -HaaTa
		for ( uint8_t page = 0; page < LCD_TOTAL_VISIBLE_PAGES; page++ )
    38bc:	2d04      	cmp	r5, #4
    38be:	d1c7      	bne.n	3850 <LCD_layerStackExact_capability+0x64>
    38c0:	e010      	b.n	38e4 <LCD_layerStackExact_capability+0xf8>
		}
	}
	else
	{
		// Set default backlight
		FTM0_C0V = STLcdBacklightRed_define;
    38c2:	f640 73ff 	movw	r3, #4095	; 0xfff
    38c6:	600b      	str	r3, [r1, #0]
		FTM0_C1V = STLcdBacklightGreen_define;
    38c8:	490c      	ldr	r1, [pc, #48]	; (38fc <LCD_layerStackExact_capability+0x110>)
		FTM0_C2V = STLcdBacklightBlue_define;
    38ca:	4614      	mov	r4, r2
	}
	else
	{
		// Set default backlight
		FTM0_C0V = STLcdBacklightRed_define;
		FTM0_C1V = STLcdBacklightGreen_define;
    38cc:	600b      	str	r3, [r1, #0]
		FTM0_C2V = STLcdBacklightBlue_define;
    38ce:	608b      	str	r3, [r1, #8]

		// Write default image
		for ( uint8_t page = 0; page < LCD_TOTAL_VISIBLE_PAGES; page++ )
			LCD_writeDisplayReg( page, (uint8_t *)&STLcdDefaultImage[page * LCD_PAGE_LEN], LCD_PAGE_LEN );
    38d0:	490c      	ldr	r1, [pc, #48]	; (3904 <LCD_layerStackExact_capability+0x118>)
    38d2:	b2e0      	uxtb	r0, r4
    38d4:	eb01 11c4 	add.w	r1, r1, r4, lsl #7
    38d8:	2280      	movs	r2, #128	; 0x80
    38da:	3401      	adds	r4, #1
    38dc:	f7ff fe79 	bl	35d2 <LCD_writeDisplayReg>
		FTM0_C0V = STLcdBacklightRed_define;
		FTM0_C1V = STLcdBacklightGreen_define;
		FTM0_C2V = STLcdBacklightBlue_define;

		// Write default image
		for ( uint8_t page = 0; page < LCD_TOTAL_VISIBLE_PAGES; page++ )
    38e0:	2c04      	cmp	r4, #4
    38e2:	d1f5      	bne.n	38d0 <LCD_layerStackExact_capability+0xe4>
			LCD_writeDisplayReg( page, (uint8_t *)&STLcdDefaultImage[page * LCD_PAGE_LEN], LCD_PAGE_LEN );
	}
}
    38e4:	f20d 5d44 	addw	sp, sp, #1348	; 0x544
    38e8:	bdf0      	pop	{r4, r5, r6, r7, pc}
    38ea:	bf00      	nop
    38ec:	000088b5 	.word	0x000088b5
    38f0:	000082e0 	.word	0x000082e0
    38f4:	000087e0 	.word	0x000087e0
    38f8:	40038010 	.word	0x40038010
    38fc:	40038018 	.word	0x40038018
    3900:	40038020 	.word	0x40038020
    3904:	0000897d 	.word	0x0000897d

00003908 <LCD_layerStack_capability>:
// Determines the current layer stack, and sets the LCD output accordingly
// Will only work on a master node when using the interconnect (use LCD_layerStackExact_capability instead)
uint16_t LCD_layerStack_prevSize = 0;
uint16_t LCD_layerStack_prevTop  = 0;
void LCD_layerStack_capability( uint8_t state, uint8_t stateType, uint8_t *args )
{
    3908:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	// Display capability name
	if ( stateType == 0xFF && state == 0xFF )
    390c:	29ff      	cmp	r1, #255	; 0xff
// Determines the current layer stack, and sets the LCD output accordingly
// Will only work on a master node when using the interconnect (use LCD_layerStackExact_capability instead)
uint16_t LCD_layerStack_prevSize = 0;
uint16_t LCD_layerStack_prevTop  = 0;
void LCD_layerStack_capability( uint8_t state, uint8_t stateType, uint8_t *args )
{
    390e:	b086      	sub	sp, #24
    3910:	4607      	mov	r7, r0
    3912:	460e      	mov	r6, r1
	// Display capability name
	if ( stateType == 0xFF && state == 0xFF )
    3914:	d105      	bne.n	3922 <LCD_layerStack_capability+0x1a>
    3916:	28ff      	cmp	r0, #255	; 0xff
    3918:	d103      	bne.n	3922 <LCD_layerStack_capability+0x1a>
	{
		print("LCD_layerStack_capability()");
    391a:	4823      	ldr	r0, [pc, #140]	; (39a8 <LCD_layerStack_capability+0xa0>)
    391c:	f003 ff72 	bl	7804 <_print>
		return;
    3920:	e03e      	b.n	39a0 <LCD_layerStack_capability+0x98>
	// Parse the layer stack, top to bottom
	extern uint16_t macroLayerIndexStack[];
	extern uint16_t macroLayerIndexStackSize;

	// Ignore if the stack size hasn't changed and the top of the stack is the same
	if ( macroLayerIndexStackSize == LCD_layerStack_prevSize
    3922:	4922      	ldr	r1, [pc, #136]	; (39ac <LCD_layerStack_capability+0xa4>)
    3924:	4a22      	ldr	r2, [pc, #136]	; (39b0 <LCD_layerStack_capability+0xa8>)
    3926:	880b      	ldrh	r3, [r1, #0]
    3928:	8810      	ldrh	r0, [r2, #0]
    392a:	f8df 8094 	ldr.w	r8, [pc, #148]	; 39c0 <LCD_layerStack_capability+0xb8>
    392e:	4298      	cmp	r0, r3
    3930:	460c      	mov	r4, r1
    3932:	4610      	mov	r0, r2
    3934:	f103 31ff 	add.w	r1, r3, #4294967295	; 0xffffffff
    3938:	4a1e      	ldr	r2, [pc, #120]	; (39b4 <LCD_layerStack_capability+0xac>)
    393a:	d104      	bne.n	3946 <LCD_layerStack_capability+0x3e>
		&& macroLayerIndexStack[macroLayerIndexStackSize - 1] == LCD_layerStack_prevTop )
    393c:	f838 c011 	ldrh.w	ip, [r8, r1, lsl #1]
    3940:	8815      	ldrh	r5, [r2, #0]
    3942:	45ac      	cmp	ip, r5
    3944:	d02c      	beq.n	39a0 <LCD_layerStack_capability+0x98>
	{
		return;
	}
	LCD_layerStack_prevSize = macroLayerIndexStackSize;
    3946:	8003      	strh	r3, [r0, #0]
	LCD_layerStack_prevTop  = macroLayerIndexStack[macroLayerIndexStackSize - 1];
    3948:	f838 3011 	ldrh.w	r3, [r8, r1, lsl #1]

	LCD_layerStackExact_args stack_args;
	memset( stack_args.layers, 0, sizeof( stack_args.layers ) );
    394c:	ad03      	add	r5, sp, #12
		&& macroLayerIndexStack[macroLayerIndexStackSize - 1] == LCD_layerStack_prevTop )
	{
		return;
	}
	LCD_layerStack_prevSize = macroLayerIndexStackSize;
	LCD_layerStack_prevTop  = macroLayerIndexStack[macroLayerIndexStackSize - 1];
    394e:	8013      	strh	r3, [r2, #0]

	LCD_layerStackExact_args stack_args;
	memset( stack_args.layers, 0, sizeof( stack_args.layers ) );
    3950:	1ca8      	adds	r0, r5, #2
    3952:	2100      	movs	r1, #0
    3954:	2208      	movs	r2, #8
    3956:	f7fe fe09 	bl	256c <memset>

	// Use the LCD_layerStackExact_capability to set the LCD using the determined stack
	// Construct argument set for capability
	stack_args.numArgs = macroLayerIndexStackSize;
    395a:	8823      	ldrh	r3, [r4, #0]
	for ( uint16_t layer = 1; layer <= macroLayerIndexStackSize; layer++ )
    395c:	2401      	movs	r4, #1
	LCD_layerStackExact_args stack_args;
	memset( stack_args.layers, 0, sizeof( stack_args.layers ) );

	// Use the LCD_layerStackExact_capability to set the LCD using the determined stack
	// Construct argument set for capability
	stack_args.numArgs = macroLayerIndexStackSize;
    395e:	f88d 300c 	strb.w	r3, [sp, #12]
	for ( uint16_t layer = 1; layer <= macroLayerIndexStackSize; layer++ )
    3962:	429c      	cmp	r4, r3
    3964:	d80a      	bhi.n	397c <LCD_layerStack_capability+0x74>
	{
		stack_args.layers[ layer - 1 ] = macroLayerIndexStack[ macroLayerIndexStackSize - layer ];
    3966:	a906      	add	r1, sp, #24
    3968:	eb01 0244 	add.w	r2, r1, r4, lsl #1
    396c:	1b19      	subs	r1, r3, r4
	memset( stack_args.layers, 0, sizeof( stack_args.layers ) );

	// Use the LCD_layerStackExact_capability to set the LCD using the determined stack
	// Construct argument set for capability
	stack_args.numArgs = macroLayerIndexStackSize;
	for ( uint16_t layer = 1; layer <= macroLayerIndexStackSize; layer++ )
    396e:	3401      	adds	r4, #1
	{
		stack_args.layers[ layer - 1 ] = macroLayerIndexStack[ macroLayerIndexStackSize - layer ];
    3970:	f838 1011 	ldrh.w	r1, [r8, r1, lsl #1]
	memset( stack_args.layers, 0, sizeof( stack_args.layers ) );

	// Use the LCD_layerStackExact_capability to set the LCD using the determined stack
	// Construct argument set for capability
	stack_args.numArgs = macroLayerIndexStackSize;
	for ( uint16_t layer = 1; layer <= macroLayerIndexStackSize; layer++ )
    3974:	b2a4      	uxth	r4, r4
	{
		stack_args.layers[ layer - 1 ] = macroLayerIndexStack[ macroLayerIndexStackSize - layer ];
    3976:	f822 1c0c 	strh.w	r1, [r2, #-12]
    397a:	e7f2      	b.n	3962 <LCD_layerStack_capability+0x5a>
	}

	// Only deal with the interconnect if it has been compiled in
#if defined(ConnectEnabled_define)
	if ( Connect_master )
    397c:	4b0e      	ldr	r3, [pc, #56]	; (39b8 <LCD_layerStack_capability+0xb0>)
    397e:	781b      	ldrb	r3, [r3, #0]
    3980:	b14b      	cbz	r3, 3996 <LCD_layerStack_capability+0x8e>
	{
		// generatedKeymap.h
		extern const Capability CapabilitiesList[];

		// Broadcast layerStackExact remote capability (0xFF is the broadcast id)
		Connect_send_RemoteCapability(
    3982:	4b0e      	ldr	r3, [pc, #56]	; (39bc <LCD_layerStack_capability+0xb4>)
    3984:	791b      	ldrb	r3, [r3, #4]
    3986:	20ff      	movs	r0, #255	; 0xff
    3988:	e88d 0028 	stmia.w	sp, {r3, r5}
    398c:	2100      	movs	r1, #0
    398e:	463a      	mov	r2, r7
    3990:	4633      	mov	r3, r6
    3992:	f000 fcf3 	bl	437c <Connect_send_RemoteCapability>
			(uint8_t*)&stack_args
		);
	}
#endif
	// Call LCD_layerStackExact directly
	LCD_layerStackExact_capability( state, stateType, (uint8_t*)&stack_args );
    3996:	4638      	mov	r0, r7
    3998:	4631      	mov	r1, r6
    399a:	462a      	mov	r2, r5
    399c:	f7ff ff26 	bl	37ec <LCD_layerStackExact_capability>
}
    39a0:	b006      	add	sp, #24
    39a2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    39a6:	bf00      	nop
    39a8:	000088f5 	.word	0x000088f5
    39ac:	1fff92dc 	.word	0x1fff92dc
    39b0:	1fff92b4 	.word	0x1fff92b4
    39b4:	1fff92b6 	.word	0x1fff92b6
    39b8:	1fff92d6 	.word	0x1fff92d6
    39bc:	0000a1f8 	.word	0x0000a1f8
    39c0:	1fff93fa 	.word	0x1fff93fa

000039c4 <Connect_receive_Animation>:
	// Check whether the scan codes have finished sending
	return *pending_bytes == 0 ? 1 : 0;
}

uint8_t Connect_receive_Animation( uint8_t byte, uint16_t *pending_bytes, uint8_t uart_num )
{
    39c4:	b508      	push	{r3, lr}
	dbug_print("Animation");
    39c6:	4802      	ldr	r0, [pc, #8]	; (39d0 <Connect_receive_Animation+0xc>)
    39c8:	f003 ff1c 	bl	7804 <_print>
	return 1;
}
    39cc:	2001      	movs	r0, #1
    39ce:	bd08      	pop	{r3, pc}
    39d0:	00008cf3 	.word	0x00008cf3

000039d4 <cliFunc_connectDbg>:
		break;
	}
}

void cliFunc_connectDbg( char* args )
{
    39d4:	b508      	push	{r3, lr}
	print( NL );
    39d6:	4807      	ldr	r0, [pc, #28]	; (39f4 <cliFunc_connectDbg+0x20>)
    39d8:	f003 ff14 	bl	7804 <_print>
	info_msg("Connect Debug Mode Toggle");
    39dc:	4806      	ldr	r0, [pc, #24]	; (39f8 <cliFunc_connectDbg+0x24>)
    39de:	f003 ff11 	bl	7804 <_print>
	Connect_debug = !Connect_debug;
    39e2:	4b06      	ldr	r3, [pc, #24]	; (39fc <cliFunc_connectDbg+0x28>)
    39e4:	781a      	ldrb	r2, [r3, #0]
    39e6:	f1d2 0201 	rsbs	r2, r2, #1
    39ea:	bf38      	it	cc
    39ec:	2200      	movcc	r2, #0
    39ee:	701a      	strb	r2, [r3, #0]
    39f0:	bd08      	pop	{r3, pc}
    39f2:	bf00      	nop
    39f4:	0000bafb 	.word	0x0000bafb
    39f8:	00008d12 	.word	0x00008d12
    39fc:	1fff92cd 	.word	0x1fff92cd

00003a00 <Connect_receive_CableCheck>:
uint8_t  Connect_cableOkSlave  = 0;

uint8_t Connect_receive_CableCheck( uint8_t byte, uint16_t *pending_bytes, uint8_t uart_num )
{
	// Check if this is the first byte
	if ( *pending_bytes == 0xFFFF )
    3a00:	880b      	ldrh	r3, [r1, #0]
uint32_t Connect_cableChecksSlave  = 0;
uint8_t  Connect_cableOkMaster = 0;
uint8_t  Connect_cableOkSlave  = 0;

uint8_t Connect_receive_CableCheck( uint8_t byte, uint16_t *pending_bytes, uint8_t uart_num )
{
    3a02:	b570      	push	{r4, r5, r6, lr}
    3a04:	4616      	mov	r6, r2
	// Check if this is the first byte
	if ( *pending_bytes == 0xFFFF )
    3a06:	f64f 72ff 	movw	r2, #65535	; 0xffff
    3a0a:	4293      	cmp	r3, r2
uint32_t Connect_cableChecksSlave  = 0;
uint8_t  Connect_cableOkMaster = 0;
uint8_t  Connect_cableOkSlave  = 0;

uint8_t Connect_receive_CableCheck( uint8_t byte, uint16_t *pending_bytes, uint8_t uart_num )
{
    3a0c:	4605      	mov	r5, r0
    3a0e:	460c      	mov	r4, r1
	// Check if this is the first byte
	if ( *pending_bytes == 0xFFFF )
    3a10:	d116      	bne.n	3a40 <Connect_receive_CableCheck+0x40>
	{
		*pending_bytes = byte;

		if ( Connect_debug )
    3a12:	4b31      	ldr	r3, [pc, #196]	; (3ad8 <Connect_receive_CableCheck+0xd8>)
uint8_t Connect_receive_CableCheck( uint8_t byte, uint16_t *pending_bytes, uint8_t uart_num )
{
	// Check if this is the first byte
	if ( *pending_bytes == 0xFFFF )
	{
		*pending_bytes = byte;
    3a14:	8020      	strh	r0, [r4, #0]

		if ( Connect_debug )
    3a16:	781b      	ldrb	r3, [r3, #0]
    3a18:	2b00      	cmp	r3, #0
    3a1a:	d03b      	beq.n	3a94 <Connect_receive_CableCheck+0x94>
		{
			dbug_msg("PENDING SET -> ");
    3a1c:	482f      	ldr	r0, [pc, #188]	; (3adc <Connect_receive_CableCheck+0xdc>)
    3a1e:	f003 fef1 	bl	7804 <_print>
			printHex( byte );
    3a22:	4628      	mov	r0, r5
    3a24:	2101      	movs	r1, #1
    3a26:	f003 ff76 	bl	7916 <printHex_op>
			print(" ");
    3a2a:	482d      	ldr	r0, [pc, #180]	; (3ae0 <Connect_receive_CableCheck+0xe0>)
    3a2c:	f003 feea 	bl	7804 <_print>
			printHex( *pending_bytes );
    3a30:	8820      	ldrh	r0, [r4, #0]
    3a32:	2101      	movs	r1, #1
    3a34:	f003 ff6f 	bl	7916 <printHex_op>
			print( NL );
    3a38:	482a      	ldr	r0, [pc, #168]	; (3ae4 <Connect_receive_CableCheck+0xe4>)
    3a3a:	f003 fee3 	bl	7804 <_print>
    3a3e:	e029      	b.n	3a94 <Connect_receive_CableCheck+0x94>
		}
	}
	// Verify byte
	else
	{
		(*pending_bytes)--;
    3a40:	3b01      	subs	r3, #1

		// The argument bytes are always 0xD2 (11010010)
		if ( byte != 0xD2 )
    3a42:	28d2      	cmp	r0, #210	; 0xd2
		}
	}
	// Verify byte
	else
	{
		(*pending_bytes)--;
    3a44:	800b      	strh	r3, [r1, #0]

		// The argument bytes are always 0xD2 (11010010)
		if ( byte != 0xD2 )
    3a46:	d01e      	beq.n	3a86 <Connect_receive_CableCheck+0x86>
		{
			warn_print("Cable Fault!");
    3a48:	4827      	ldr	r0, [pc, #156]	; (3ae8 <Connect_receive_CableCheck+0xe8>)
    3a4a:	f003 fedb 	bl	7804 <_print>

			// Check which side of the chain
			if ( uart_num == UART_Slave )
    3a4e:	b93e      	cbnz	r6, 3a60 <Connect_receive_CableCheck+0x60>
			{
				Connect_cableFaultsSlave++;
    3a50:	4b26      	ldr	r3, [pc, #152]	; (3aec <Connect_receive_CableCheck+0xec>)
				Connect_cableOkSlave = 0;
				print(" Slave ");
    3a52:	4827      	ldr	r0, [pc, #156]	; (3af0 <Connect_receive_CableCheck+0xf0>)
			warn_print("Cable Fault!");

			// Check which side of the chain
			if ( uart_num == UART_Slave )
			{
				Connect_cableFaultsSlave++;
    3a54:	681a      	ldr	r2, [r3, #0]
    3a56:	3201      	adds	r2, #1
    3a58:	601a      	str	r2, [r3, #0]
				Connect_cableOkSlave = 0;
    3a5a:	4b26      	ldr	r3, [pc, #152]	; (3af4 <Connect_receive_CableCheck+0xf4>)
    3a5c:	701e      	strb	r6, [r3, #0]
    3a5e:	e007      	b.n	3a70 <Connect_receive_CableCheck+0x70>
				print(" Slave ");
			}
			else
			{
				Connect_cableFaultsMaster++;
    3a60:	4b25      	ldr	r3, [pc, #148]	; (3af8 <Connect_receive_CableCheck+0xf8>)
				Connect_cableOkMaster = 0;
				print(" Master ");
    3a62:	4826      	ldr	r0, [pc, #152]	; (3afc <Connect_receive_CableCheck+0xfc>)
				Connect_cableOkSlave = 0;
				print(" Slave ");
			}
			else
			{
				Connect_cableFaultsMaster++;
    3a64:	681a      	ldr	r2, [r3, #0]
    3a66:	3201      	adds	r2, #1
    3a68:	601a      	str	r2, [r3, #0]
				Connect_cableOkMaster = 0;
    3a6a:	4b25      	ldr	r3, [pc, #148]	; (3b00 <Connect_receive_CableCheck+0x100>)
    3a6c:	2200      	movs	r2, #0
    3a6e:	701a      	strb	r2, [r3, #0]
				print(" Master ");
    3a70:	f003 fec8 	bl	7804 <_print>
			}
			printHex( byte );
    3a74:	4628      	mov	r0, r5
    3a76:	2101      	movs	r1, #1
    3a78:	f003 ff4d 	bl	7916 <printHex_op>
			print( NL );
    3a7c:	4819      	ldr	r0, [pc, #100]	; (3ae4 <Connect_receive_CableCheck+0xe4>)
    3a7e:	f003 fec1 	bl	7804 <_print>

			// Signal that the command should wait for a SYN again
			return 1;
    3a82:	2001      	movs	r0, #1
    3a84:	bd70      	pop	{r4, r5, r6, pc}
		}
		else
		{
			// Check which side of the chain
			if ( uart_num == UART_Slave )
    3a86:	b90e      	cbnz	r6, 3a8c <Connect_receive_CableCheck+0x8c>
			{
				Connect_cableChecksSlave++;
    3a88:	4b1e      	ldr	r3, [pc, #120]	; (3b04 <Connect_receive_CableCheck+0x104>)
    3a8a:	e000      	b.n	3a8e <Connect_receive_CableCheck+0x8e>
			}
			else
			{
				Connect_cableChecksMaster++;
    3a8c:	4b1e      	ldr	r3, [pc, #120]	; (3b08 <Connect_receive_CableCheck+0x108>)
    3a8e:	681a      	ldr	r2, [r3, #0]
    3a90:	3201      	adds	r2, #1
    3a92:	601a      	str	r2, [r3, #0]
			}
		}
	}

	// If cable check was successful, set cable ok
	if ( *pending_bytes == 0 )
    3a94:	8823      	ldrh	r3, [r4, #0]
    3a96:	b92b      	cbnz	r3, 3aa4 <Connect_receive_CableCheck+0xa4>
    3a98:	2301      	movs	r3, #1
	{
		if ( uart_num == UART_Slave )
    3a9a:	b90e      	cbnz	r6, 3aa0 <Connect_receive_CableCheck+0xa0>
		{
			Connect_cableOkSlave = 1;
    3a9c:	4a15      	ldr	r2, [pc, #84]	; (3af4 <Connect_receive_CableCheck+0xf4>)
    3a9e:	e000      	b.n	3aa2 <Connect_receive_CableCheck+0xa2>
		}
		else
		{
			Connect_cableOkMaster = 1;
    3aa0:	4a17      	ldr	r2, [pc, #92]	; (3b00 <Connect_receive_CableCheck+0x100>)
    3aa2:	7013      	strb	r3, [r2, #0]
		}
	}

	if ( Connect_debug )
    3aa4:	4b0c      	ldr	r3, [pc, #48]	; (3ad8 <Connect_receive_CableCheck+0xd8>)
    3aa6:	781b      	ldrb	r3, [r3, #0]
    3aa8:	b183      	cbz	r3, 3acc <Connect_receive_CableCheck+0xcc>
	{
		dbug_msg("CABLECHECK RECEIVE - ");
    3aaa:	4818      	ldr	r0, [pc, #96]	; (3b0c <Connect_receive_CableCheck+0x10c>)
    3aac:	f003 feaa 	bl	7804 <_print>
		printHex( byte );
    3ab0:	2101      	movs	r1, #1
    3ab2:	4628      	mov	r0, r5
    3ab4:	f003 ff2f 	bl	7916 <printHex_op>
		print(" ");
    3ab8:	4809      	ldr	r0, [pc, #36]	; (3ae0 <Connect_receive_CableCheck+0xe0>)
    3aba:	f003 fea3 	bl	7804 <_print>
		printHex( *pending_bytes );
    3abe:	8820      	ldrh	r0, [r4, #0]
    3ac0:	2101      	movs	r1, #1
    3ac2:	f003 ff28 	bl	7916 <printHex_op>
		print( NL );
    3ac6:	4807      	ldr	r0, [pc, #28]	; (3ae4 <Connect_receive_CableCheck+0xe4>)
    3ac8:	f003 fe9c 	bl	7804 <_print>
	}

	// Check whether the cable check has finished
	return *pending_bytes == 0 ? 1 : 0;
    3acc:	8820      	ldrh	r0, [r4, #0]
    3ace:	f1d0 0001 	rsbs	r0, r0, #1
    3ad2:	bf38      	it	cc
    3ad4:	2000      	movcc	r0, #0
}
    3ad6:	bd70      	pop	{r4, r5, r6, pc}
    3ad8:	1fff92cd 	.word	0x1fff92cd
    3adc:	00008d3e 	.word	0x00008d3e
    3ae0:	00008156 	.word	0x00008156
    3ae4:	0000bafb 	.word	0x0000bafb
    3ae8:	00008d61 	.word	0x00008d61
    3aec:	1fff92c0 	.word	0x1fff92c0
    3af0:	00008d85 	.word	0x00008d85
    3af4:	1fff92d4 	.word	0x1fff92d4
    3af8:	1fff92c8 	.word	0x1fff92c8
    3afc:	00008d8d 	.word	0x00008d8d
    3b00:	1fff92bc 	.word	0x1fff92bc
    3b04:	1fff92d0 	.word	0x1fff92d0
    3b08:	1fff92c4 	.word	0x1fff92c4
    3b0c:	00008d96 	.word	0x00008d96

00003b10 <cliFunc_connectLst>:

	Connect_send_Idle( count );
}

void cliFunc_connectLst( char* args )
{
    3b10:	b530      	push	{r4, r5, lr}
	const char *Command_strs[] = {
    3b12:	4d11      	ldr	r5, [pc, #68]	; (3b58 <cliFunc_connectLst+0x48>)
    3b14:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}

	Connect_send_Idle( count );
}

void cliFunc_connectLst( char* args )
{
    3b16:	b08b      	sub	sp, #44	; 0x2c
	const char *Command_strs[] = {
    3b18:	ac01      	add	r4, sp, #4
    3b1a:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    3b1c:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
    3b1e:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    3b20:	682b      	ldr	r3, [r5, #0]
		"RemoteCapability",
		"RemoteOutput",
		"RemoteInput",
	};

	print( NL );
    3b22:	480e      	ldr	r0, [pc, #56]	; (3b5c <cliFunc_connectLst+0x4c>)
	Connect_send_Idle( count );
}

void cliFunc_connectLst( char* args )
{
	const char *Command_strs[] = {
    3b24:	6023      	str	r3, [r4, #0]
		"RemoteCapability",
		"RemoteOutput",
		"RemoteInput",
	};

	print( NL );
    3b26:	f003 fe6d 	bl	7804 <_print>
	info_msg("List of UARTConnect commands");
    3b2a:	480d      	ldr	r0, [pc, #52]	; (3b60 <cliFunc_connectLst+0x50>)
    3b2c:	f003 fe6a 	bl	7804 <_print>
    3b30:	2400      	movs	r4, #0
    3b32:	ad01      	add	r5, sp, #4
	for ( uint8_t cmd = 0; cmd < Command_TOP; cmd++ )
	{
		print( NL );
    3b34:	4809      	ldr	r0, [pc, #36]	; (3b5c <cliFunc_connectLst+0x4c>)
    3b36:	f003 fe65 	bl	7804 <_print>
		printInt8( cmd );
    3b3a:	b2e0      	uxtb	r0, r4
    3b3c:	f003 fe94 	bl	7868 <printInt8>
		print(" - ");
    3b40:	4808      	ldr	r0, [pc, #32]	; (3b64 <cliFunc_connectLst+0x54>)
    3b42:	f003 fe5f 	bl	7804 <_print>
		dPrint( (char*)Command_strs[ cmd ] );
    3b46:	f855 0024 	ldr.w	r0, [r5, r4, lsl #2]
    3b4a:	3401      	adds	r4, #1
    3b4c:	f002 fb5c 	bl	6208 <Output_putstr>
		"RemoteInput",
	};

	print( NL );
	info_msg("List of UARTConnect commands");
	for ( uint8_t cmd = 0; cmd < Command_TOP; cmd++ )
    3b50:	2c09      	cmp	r4, #9
    3b52:	d1ef      	bne.n	3b34 <cliFunc_connectLst+0x24>
		print( NL );
		printInt8( cmd );
		print(" - ");
		dPrint( (char*)Command_strs[ cmd ] );
	}
}
    3b54:	b00b      	add	sp, #44	; 0x2c
    3b56:	bd30      	pop	{r4, r5, pc}
    3b58:	00008c30 	.word	0x00008c30
    3b5c:	0000bafb 	.word	0x0000bafb
    3b60:	00008dbf 	.word	0x00008dbf
    3b64:	000091d3 	.word	0x000091d3

00003b68 <cliFunc_connectSts>:
	// Reset node id
	Connect_id = 0xFF;
}

void cliFunc_connectSts( char* args )
{
    3b68:	b538      	push	{r3, r4, r5, lr}
	print( NL );
    3b6a:	4839      	ldr	r0, [pc, #228]	; (3c50 <cliFunc_connectSts+0xe8>)
	print( NL "\tFaults:\t");
	printHex32( Connect_cableFaultsMaster );
	print("/");
	printHex32( Connect_cableChecksMaster );
	print( NL "\tRx:\t");
	printHex( uart_rx_status[UART_Master].status );
    3b6c:	4d39      	ldr	r5, [pc, #228]	; (3c54 <cliFunc_connectSts+0xec>)
	print( NL "\tTx:\t");
	printHex( uart_tx_status[UART_Master].status );
    3b6e:	4c3a      	ldr	r4, [pc, #232]	; (3c58 <cliFunc_connectSts+0xf0>)
	Connect_id = 0xFF;
}

void cliFunc_connectSts( char* args )
{
	print( NL );
    3b70:	f003 fe48 	bl	7804 <_print>
	info_msg("UARTConnect Status");
    3b74:	4839      	ldr	r0, [pc, #228]	; (3c5c <cliFunc_connectSts+0xf4>)
    3b76:	f003 fe45 	bl	7804 <_print>
	print( NL "Device Type:\t" );
    3b7a:	4839      	ldr	r0, [pc, #228]	; (3c60 <cliFunc_connectSts+0xf8>)
    3b7c:	f003 fe42 	bl	7804 <_print>
	print( Connect_master ? "Master" : "Slave" );
    3b80:	4b38      	ldr	r3, [pc, #224]	; (3c64 <cliFunc_connectSts+0xfc>)
    3b82:	4a39      	ldr	r2, [pc, #228]	; (3c68 <cliFunc_connectSts+0x100>)
    3b84:	7818      	ldrb	r0, [r3, #0]
    3b86:	4b39      	ldr	r3, [pc, #228]	; (3c6c <cliFunc_connectSts+0x104>)
    3b88:	2800      	cmp	r0, #0
    3b8a:	bf0c      	ite	eq
    3b8c:	4610      	moveq	r0, r2
    3b8e:	4618      	movne	r0, r3
    3b90:	f003 fe38 	bl	7804 <_print>
	print( NL "Device Id:\t" );
    3b94:	4836      	ldr	r0, [pc, #216]	; (3c70 <cliFunc_connectSts+0x108>)
    3b96:	f003 fe35 	bl	7804 <_print>
	printHex( Connect_id );
    3b9a:	4b36      	ldr	r3, [pc, #216]	; (3c74 <cliFunc_connectSts+0x10c>)
    3b9c:	2101      	movs	r1, #1
    3b9e:	7818      	ldrb	r0, [r3, #0]
    3ba0:	f003 feb9 	bl	7916 <printHex_op>
	print( NL "Max Id:\t" );
    3ba4:	4834      	ldr	r0, [pc, #208]	; (3c78 <cliFunc_connectSts+0x110>)
    3ba6:	f003 fe2d 	bl	7804 <_print>
	printHex( Connect_maxId );
    3baa:	4b34      	ldr	r3, [pc, #208]	; (3c7c <cliFunc_connectSts+0x114>)
    3bac:	2101      	movs	r1, #1
    3bae:	7818      	ldrb	r0, [r3, #0]
    3bb0:	f003 feb1 	bl	7916 <printHex_op>
	print( NL "Master <=" NL "\tStatus:\t");
    3bb4:	4832      	ldr	r0, [pc, #200]	; (3c80 <cliFunc_connectSts+0x118>)
    3bb6:	f003 fe25 	bl	7804 <_print>
	printHex( Connect_cableOkMaster );
    3bba:	4b32      	ldr	r3, [pc, #200]	; (3c84 <cliFunc_connectSts+0x11c>)
    3bbc:	2101      	movs	r1, #1
    3bbe:	7818      	ldrb	r0, [r3, #0]
    3bc0:	f003 fea9 	bl	7916 <printHex_op>
	print( NL "\tFaults:\t");
    3bc4:	4830      	ldr	r0, [pc, #192]	; (3c88 <cliFunc_connectSts+0x120>)
    3bc6:	f003 fe1d 	bl	7804 <_print>
	printHex32( Connect_cableFaultsMaster );
    3bca:	4b30      	ldr	r3, [pc, #192]	; (3c8c <cliFunc_connectSts+0x124>)
    3bcc:	2101      	movs	r1, #1
    3bce:	6818      	ldr	r0, [r3, #0]
    3bd0:	f003 fed6 	bl	7980 <printHex32_op>
	print("/");
    3bd4:	482e      	ldr	r0, [pc, #184]	; (3c90 <cliFunc_connectSts+0x128>)
    3bd6:	f003 fe15 	bl	7804 <_print>
	printHex32( Connect_cableChecksMaster );
    3bda:	4b2e      	ldr	r3, [pc, #184]	; (3c94 <cliFunc_connectSts+0x12c>)
    3bdc:	2101      	movs	r1, #1
    3bde:	6818      	ldr	r0, [r3, #0]
    3be0:	f003 fece 	bl	7980 <printHex32_op>
	print( NL "\tRx:\t");
    3be4:	482c      	ldr	r0, [pc, #176]	; (3c98 <cliFunc_connectSts+0x130>)
    3be6:	f003 fe0d 	bl	7804 <_print>
	printHex( uart_rx_status[UART_Master].status );
    3bea:	7928      	ldrb	r0, [r5, #4]
    3bec:	2101      	movs	r1, #1
    3bee:	f003 fe92 	bl	7916 <printHex_op>
	print( NL "\tTx:\t");
    3bf2:	482a      	ldr	r0, [pc, #168]	; (3c9c <cliFunc_connectSts+0x134>)
    3bf4:	f003 fe06 	bl	7804 <_print>
	printHex( uart_tx_status[UART_Master].status );
    3bf8:	78a0      	ldrb	r0, [r4, #2]
    3bfa:	2101      	movs	r1, #1
    3bfc:	f003 fe8b 	bl	7916 <printHex_op>
	print( NL "Slave <=" NL "\tStatus:\t");
    3c00:	4827      	ldr	r0, [pc, #156]	; (3ca0 <cliFunc_connectSts+0x138>)
    3c02:	f003 fdff 	bl	7804 <_print>
	printHex( Connect_cableOkSlave );
    3c06:	4b27      	ldr	r3, [pc, #156]	; (3ca4 <cliFunc_connectSts+0x13c>)
    3c08:	2101      	movs	r1, #1
    3c0a:	7818      	ldrb	r0, [r3, #0]
    3c0c:	f003 fe83 	bl	7916 <printHex_op>
	print( NL "\tFaults:\t");
    3c10:	481d      	ldr	r0, [pc, #116]	; (3c88 <cliFunc_connectSts+0x120>)
    3c12:	f003 fdf7 	bl	7804 <_print>
	printHex32( Connect_cableFaultsSlave );
    3c16:	4b24      	ldr	r3, [pc, #144]	; (3ca8 <cliFunc_connectSts+0x140>)
    3c18:	2101      	movs	r1, #1
    3c1a:	6818      	ldr	r0, [r3, #0]
    3c1c:	f003 feb0 	bl	7980 <printHex32_op>
	print("/");
    3c20:	481b      	ldr	r0, [pc, #108]	; (3c90 <cliFunc_connectSts+0x128>)
    3c22:	f003 fdef 	bl	7804 <_print>
	printHex32( Connect_cableChecksSlave );
    3c26:	4b21      	ldr	r3, [pc, #132]	; (3cac <cliFunc_connectSts+0x144>)
    3c28:	2101      	movs	r1, #1
    3c2a:	6818      	ldr	r0, [r3, #0]
    3c2c:	f003 fea8 	bl	7980 <printHex32_op>
	print( NL "\tRx:\t");
    3c30:	4819      	ldr	r0, [pc, #100]	; (3c98 <cliFunc_connectSts+0x130>)
    3c32:	f003 fde7 	bl	7804 <_print>
	printHex( uart_rx_status[UART_Slave].status );
    3c36:	7828      	ldrb	r0, [r5, #0]
    3c38:	2101      	movs	r1, #1
    3c3a:	f003 fe6c 	bl	7916 <printHex_op>
	print( NL "\tTx:\t");
    3c3e:	4817      	ldr	r0, [pc, #92]	; (3c9c <cliFunc_connectSts+0x134>)
    3c40:	f003 fde0 	bl	7804 <_print>
	printHex( uart_tx_status[UART_Slave].status );
    3c44:	7820      	ldrb	r0, [r4, #0]
    3c46:	2101      	movs	r1, #1
}
    3c48:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	print("/");
	printHex32( Connect_cableChecksSlave );
	print( NL "\tRx:\t");
	printHex( uart_rx_status[UART_Slave].status );
	print( NL "\tTx:\t");
	printHex( uart_tx_status[UART_Slave].status );
    3c4c:	f003 be63 	b.w	7916 <printHex_op>
    3c50:	0000bafb 	.word	0x0000bafb
    3c54:	1fffa02c 	.word	0x1fffa02c
    3c58:	1fffa00e 	.word	0x1fffa00e
    3c5c:	00008dfb 	.word	0x00008dfb
    3c60:	00008e20 	.word	0x00008e20
    3c64:	1fff92d6 	.word	0x1fff92d6
    3c68:	00008df5 	.word	0x00008df5
    3c6c:	00008dee 	.word	0x00008dee
    3c70:	00008e30 	.word	0x00008e30
    3c74:	1fff89c5 	.word	0x1fff89c5
    3c78:	00008e3e 	.word	0x00008e3e
    3c7c:	1fff92cc 	.word	0x1fff92cc
    3c80:	00008e49 	.word	0x00008e49
    3c84:	1fff92bc 	.word	0x1fff92bc
    3c88:	00008e60 	.word	0x00008e60
    3c8c:	1fff92c8 	.word	0x1fff92c8
    3c90:	00008e6c 	.word	0x00008e6c
    3c94:	1fff92c4 	.word	0x1fff92c4
    3c98:	00008e6e 	.word	0x00008e6e
    3c9c:	00008e76 	.word	0x00008e76
    3ca0:	00008e7e 	.word	0x00008e7e
    3ca4:	1fff92d4 	.word	0x1fff92d4
    3ca8:	1fff92c0 	.word	0x1fff92c0
    3cac:	1fff92d0 	.word	0x1fff92d0

00003cb0 <cliFunc_connectMst>:
		dPrint( (char*)Command_strs[ cmd ] );
	}
}

void cliFunc_connectMst( char* args )
{
    3cb0:	b537      	push	{r0, r1, r2, r4, r5, lr}
	// Parse number from argument
	//  NOTE: Only first argument is used
	char* arg1Ptr;
	char* arg2Ptr;
	CLI_argumentIsolation( args, &arg1Ptr, &arg2Ptr );
    3cb2:	aa01      	add	r2, sp, #4
    3cb4:	4669      	mov	r1, sp
    3cb6:	f003 faf3 	bl	72a0 <CLI_argumentIsolation>

	print( NL );
    3cba:	4813      	ldr	r0, [pc, #76]	; (3d08 <cliFunc_connectMst+0x58>)
    3cbc:	4d13      	ldr	r5, [pc, #76]	; (3d0c <cliFunc_connectMst+0x5c>)
    3cbe:	4c14      	ldr	r4, [pc, #80]	; (3d10 <cliFunc_connectMst+0x60>)
    3cc0:	f003 fda0 	bl	7804 <_print>

	// Set override
	Connect_override = 1;
    3cc4:	4a13      	ldr	r2, [pc, #76]	; (3d14 <cliFunc_connectMst+0x64>)
    3cc6:	2301      	movs	r3, #1
    3cc8:	7013      	strb	r3, [r2, #0]

	switch ( arg1Ptr[0] )
    3cca:	9b00      	ldr	r3, [sp, #0]
    3ccc:	781b      	ldrb	r3, [r3, #0]
    3cce:	2b53      	cmp	r3, #83	; 0x53
    3cd0:	d00a      	beq.n	3ce8 <cliFunc_connectMst+0x38>
    3cd2:	d802      	bhi.n	3cda <cliFunc_connectMst+0x2a>
    3cd4:	2b44      	cmp	r3, #68	; 0x44
    3cd6:	d005      	beq.n	3ce4 <cliFunc_connectMst+0x34>
    3cd8:	e00d      	b.n	3cf6 <cliFunc_connectMst+0x46>
    3cda:	2b64      	cmp	r3, #100	; 0x64
    3cdc:	d002      	beq.n	3ce4 <cliFunc_connectMst+0x34>
    3cde:	2b73      	cmp	r3, #115	; 0x73
    3ce0:	d002      	beq.n	3ce8 <cliFunc_connectMst+0x38>
    3ce2:	e008      	b.n	3cf6 <cliFunc_connectMst+0x46>
	{
	// Disable override
	case 'd':
	case 'D':
		Connect_override = 0;
    3ce4:	2300      	movs	r3, #0
    3ce6:	7013      	strb	r3, [r2, #0]
	case 's':
	case 'S':
		info_msg("Setting device as slave.");
    3ce8:	480b      	ldr	r0, [pc, #44]	; (3d18 <cliFunc_connectMst+0x68>)
    3cea:	f003 fd8b 	bl	7804 <_print>
		Connect_master = 0;
    3cee:	2300      	movs	r3, #0
    3cf0:	702b      	strb	r3, [r5, #0]
		Connect_id = 0xFF;
    3cf2:	23ff      	movs	r3, #255	; 0xff
    3cf4:	e005      	b.n	3d02 <cliFunc_connectMst+0x52>
		break;

	case 'm':
	case 'M':
	default:
		info_msg("Setting device as master.");
    3cf6:	4809      	ldr	r0, [pc, #36]	; (3d1c <cliFunc_connectMst+0x6c>)
    3cf8:	f003 fd84 	bl	7804 <_print>
		Connect_master = 1;
    3cfc:	2301      	movs	r3, #1
    3cfe:	702b      	strb	r3, [r5, #0]
		Connect_id = 0;
    3d00:	2300      	movs	r3, #0
    3d02:	7023      	strb	r3, [r4, #0]
		break;
	}
}
    3d04:	b003      	add	sp, #12
    3d06:	bd30      	pop	{r4, r5, pc}
    3d08:	0000bafb 	.word	0x0000bafb
    3d0c:	1fff92d6 	.word	0x1fff92d6
    3d10:	1fff89c5 	.word	0x1fff89c5
    3d14:	1fff92d5 	.word	0x1fff92d5
    3d18:	00008e94 	.word	0x00008e94
    3d1c:	00008ebf 	.word	0x00008ebf

00003d20 <Connect_addBytes.part.1>:
UARTStatusTx uart_tx_status[UART_Num_Interfaces];


// -- Ring Buffer Convenience Functions --

void Connect_addBytes( uint8_t *buffer, uint8_t count, uint8_t uart )
    3d20:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    3d24:	4680      	mov	r8, r0
    3d26:	460f      	mov	r7, r1
    3d28:	4614      	mov	r4, r2
		erro_print("Invalid UART to send from...");
		return;
	}

	// Delay UART copy until there's some space left
	while ( uart_tx_buf[ uart ].items + count > UART_Buffer_Size )
    3d2a:	4d28      	ldr	r5, [pc, #160]	; (3dcc <Connect_addBytes.part.1+0xac>)
    3d2c:	2383      	movs	r3, #131	; 0x83
    3d2e:	fb03 5304 	mla	r3, r3, r4, r5
    3d32:	789b      	ldrb	r3, [r3, #2]
    3d34:	443b      	add	r3, r7
    3d36:	2b80      	cmp	r3, #128	; 0x80
    3d38:	dd0c      	ble.n	3d54 <Connect_addBytes.part.1+0x34>
	{
		warn_msg("Too much data to send on UART");
    3d3a:	4825      	ldr	r0, [pc, #148]	; (3dd0 <Connect_addBytes.part.1+0xb0>)
    3d3c:	f003 fd62 	bl	7804 <_print>
		printInt8( uart );
    3d40:	4620      	mov	r0, r4
    3d42:	f003 fd91 	bl	7868 <printInt8>
		print( ", waiting..." NL );
    3d46:	4823      	ldr	r0, [pc, #140]	; (3dd4 <Connect_addBytes.part.1+0xb4>)
    3d48:	f003 fd5c 	bl	7804 <_print>
		delay( 1 );
    3d4c:	2001      	movs	r0, #1
    3d4e:	f7fe fc41 	bl	25d4 <delay>
    3d52:	e7ea      	b.n	3d2a <Connect_addBytes.part.1+0xa>
		erro_print("Invalid UART to send from...");
		return;
	}

	// Delay UART copy until there's some space left
	while ( uart_tx_buf[ uart ].items + count > UART_Buffer_Size )
    3d54:	2600      	movs	r6, #0
		print( ", waiting..." NL );
		delay( 1 );
	}

	// Append data to ring buffer
	for ( uint8_t c = 0; c < count; c++ )
    3d56:	b2f3      	uxtb	r3, r6
    3d58:	42bb      	cmp	r3, r7
    3d5a:	d235      	bcs.n	3dc8 <Connect_addBytes.part.1+0xa8>
	{
		if ( Connect_debug )
    3d5c:	4b1e      	ldr	r3, [pc, #120]	; (3dd8 <Connect_addBytes.part.1+0xb8>)
    3d5e:	781b      	ldrb	r3, [r3, #0]
    3d60:	b16b      	cbz	r3, 3d7e <Connect_addBytes.part.1+0x5e>
		{
			printHex( buffer[ c ] );
    3d62:	2101      	movs	r1, #1
    3d64:	f818 0006 	ldrb.w	r0, [r8, r6]
    3d68:	f003 fdd5 	bl	7916 <printHex_op>
			print(" +");
    3d6c:	481b      	ldr	r0, [pc, #108]	; (3ddc <Connect_addBytes.part.1+0xbc>)
    3d6e:	f003 fd49 	bl	7804 <_print>
			printInt8( uart );
    3d72:	4620      	mov	r0, r4
    3d74:	f003 fd78 	bl	7868 <printInt8>
			print( NL );
    3d78:	4819      	ldr	r0, [pc, #100]	; (3de0 <Connect_addBytes.part.1+0xc0>)
    3d7a:	f003 fd43 	bl	7804 <_print>
		}

		uart_tx_buf[ uart ].buffer[ uart_tx_buf[ uart ].tail++ ] = buffer[ c ];
    3d7e:	2283      	movs	r2, #131	; 0x83
    3d80:	fb02 5304 	mla	r3, r2, r4, r5
    3d84:	7859      	ldrb	r1, [r3, #1]
    3d86:	1c48      	adds	r0, r1, #1
    3d88:	7058      	strb	r0, [r3, #1]
    3d8a:	f818 0006 	ldrb.w	r0, [r8, r6]
    3d8e:	4419      	add	r1, r3
    3d90:	3601      	adds	r6, #1
    3d92:	70c8      	strb	r0, [r1, #3]
		uart_tx_buf[ uart ].items++;
    3d94:	7899      	ldrb	r1, [r3, #2]
    3d96:	3101      	adds	r1, #1
    3d98:	7099      	strb	r1, [r3, #2]
		if ( uart_tx_buf[ uart ].tail >= UART_Buffer_Size )
    3d9a:	f993 1001 	ldrsb.w	r1, [r3, #1]
    3d9e:	2900      	cmp	r1, #0
			uart_tx_buf[ uart ].tail = 0;
    3da0:	bfbc      	itt	lt
    3da2:	2100      	movlt	r1, #0
    3da4:	7059      	strblt	r1, [r3, #1]
		if ( uart_tx_buf[ uart ].head == uart_tx_buf[ uart ].tail )
    3da6:	fb02 f304 	mul.w	r3, r2, r4
    3daa:	18ea      	adds	r2, r5, r3
    3dac:	5ce9      	ldrb	r1, [r5, r3]
    3dae:	7852      	ldrb	r2, [r2, #1]
    3db0:	428a      	cmp	r2, r1
			uart_tx_buf[ uart ].head++;
    3db2:	bf04      	itt	eq
    3db4:	3201      	addeq	r2, #1
    3db6:	54ea      	strbeq	r2, [r5, r3]
		if ( uart_tx_buf[ uart ].head >= UART_Buffer_Size )
    3db8:	2383      	movs	r3, #131	; 0x83
    3dba:	4363      	muls	r3, r4
    3dbc:	56ea      	ldrsb	r2, [r5, r3]
    3dbe:	2a00      	cmp	r2, #0
			uart_tx_buf[ uart ].head = 0;
    3dc0:	bfbc      	itt	lt
    3dc2:	2200      	movlt	r2, #0
    3dc4:	54ea      	strblt	r2, [r5, r3]
    3dc6:	e7c6      	b.n	3d56 <Connect_addBytes.part.1+0x36>
	}
}
    3dc8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    3dcc:	1fff9f02 	.word	0x1fff9f02
    3dd0:	00008eeb 	.word	0x00008eeb
    3dd4:	00008f1e 	.word	0x00008f1e
    3dd8:	1fff92cd 	.word	0x1fff92cd
    3ddc:	00008f2d 	.word	0x00008f2d
    3de0:	0000bafb 	.word	0x0000bafb

00003de4 <Connect_receive_ScanCode>:
TriggerGuide Connect_receive_ScanCodeBuffer;
uint8_t Connect_receive_ScanCodeBufferPos;
uint8_t Connect_receive_ScanCodeDeviceId;

uint8_t Connect_receive_ScanCode( uint8_t byte, uint16_t *pending_bytes, uint8_t uart_num )
{
    3de4:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
	// Check the directionality
	if ( uart_num == UART_Master )
    3de6:	2a01      	cmp	r2, #1
TriggerGuide Connect_receive_ScanCodeBuffer;
uint8_t Connect_receive_ScanCodeBufferPos;
uint8_t Connect_receive_ScanCodeDeviceId;

uint8_t Connect_receive_ScanCode( uint8_t byte, uint16_t *pending_bytes, uint8_t uart_num )
{
    3de8:	460c      	mov	r4, r1
    3dea:	f88d 0007 	strb.w	r0, [sp, #7]
	// Check the directionality
	if ( uart_num == UART_Master )
    3dee:	d102      	bne.n	3df6 <Connect_receive_ScanCode+0x12>
	{
		erro_print("Invalid ScanCode direction...");
    3df0:	484e      	ldr	r0, [pc, #312]	; (3f2c <Connect_receive_ScanCode+0x148>)
    3df2:	f003 fd07 	bl	7804 <_print>
	}

	// Master node, trigger scan codes
	if ( Connect_master ) switch ( (*pending_bytes)-- )
    3df6:	4b4e      	ldr	r3, [pc, #312]	; (3f30 <Connect_receive_ScanCode+0x14c>)
    3df8:	781a      	ldrb	r2, [r3, #0]
    3dfa:	8823      	ldrh	r3, [r4, #0]
    3dfc:	f64f 71fe 	movw	r1, #65534	; 0xfffe
    3e00:	2a00      	cmp	r2, #0
    3e02:	d050      	beq.n	3ea6 <Connect_receive_ScanCode+0xc2>
    3e04:	1e5a      	subs	r2, r3, #1
    3e06:	428b      	cmp	r3, r1
    3e08:	8022      	strh	r2, [r4, #0]
    3e0a:	f89d 2007 	ldrb.w	r2, [sp, #7]
    3e0e:	d004      	beq.n	3e1a <Connect_receive_ScanCode+0x36>
    3e10:	3101      	adds	r1, #1
    3e12:	428b      	cmp	r3, r1
    3e14:	d108      	bne.n	3e28 <Connect_receive_ScanCode+0x44>
	{
	// Byte count always starts at 0xFFFF
	case 0xFFFF: // Device Id
		Connect_receive_ScanCodeDeviceId = byte;
    3e16:	4b47      	ldr	r3, [pc, #284]	; (3f34 <Connect_receive_ScanCode+0x150>)
    3e18:	e004      	b.n	3e24 <Connect_receive_ScanCode+0x40>
		break;

	case 0xFFFE: // Number of TriggerGuides in bytes (byte * 3)
		*pending_bytes = byte * sizeof( TriggerGuide );
    3e1a:	2303      	movs	r3, #3
    3e1c:	435a      	muls	r2, r3
		Connect_receive_ScanCodeBufferPos = 0;
    3e1e:	4b46      	ldr	r3, [pc, #280]	; (3f38 <Connect_receive_ScanCode+0x154>)
	case 0xFFFF: // Device Id
		Connect_receive_ScanCodeDeviceId = byte;
		break;

	case 0xFFFE: // Number of TriggerGuides in bytes (byte * 3)
		*pending_bytes = byte * sizeof( TriggerGuide );
    3e20:	8022      	strh	r2, [r4, #0]
		Connect_receive_ScanCodeBufferPos = 0;
    3e22:	2200      	movs	r2, #0
    3e24:	701a      	strb	r2, [r3, #0]
		break;
    3e26:	e079      	b.n	3f1c <Connect_receive_ScanCode+0x138>

	default:
		// Set the specific TriggerGuide entry
		((uint8_t*)&Connect_receive_ScanCodeBuffer)[ Connect_receive_ScanCodeBufferPos++ ] = byte;
    3e28:	4b43      	ldr	r3, [pc, #268]	; (3f38 <Connect_receive_ScanCode+0x154>)
    3e2a:	4d44      	ldr	r5, [pc, #272]	; (3f3c <Connect_receive_ScanCode+0x158>)
    3e2c:	7818      	ldrb	r0, [r3, #0]
    3e2e:	1c41      	adds	r1, r0, #1
    3e30:	b2c9      	uxtb	r1, r1

		// Reset the BufferPos if higher than sizeof TriggerGuide
		// And send the TriggerGuide to the Macro Module
		if ( Connect_receive_ScanCodeBufferPos >= sizeof( TriggerGuide ) )
    3e32:	2902      	cmp	r1, #2
		Connect_receive_ScanCodeBufferPos = 0;
		break;

	default:
		// Set the specific TriggerGuide entry
		((uint8_t*)&Connect_receive_ScanCodeBuffer)[ Connect_receive_ScanCodeBufferPos++ ] = byte;
    3e34:	7019      	strb	r1, [r3, #0]
    3e36:	5542      	strb	r2, [r0, r5]

		// Reset the BufferPos if higher than sizeof TriggerGuide
		// And send the TriggerGuide to the Macro Module
		if ( Connect_receive_ScanCodeBufferPos >= sizeof( TriggerGuide ) )
    3e38:	d970      	bls.n	3f1c <Connect_receive_ScanCode+0x138>
		{
			Connect_receive_ScanCodeBufferPos = 0;

			// Adjust ScanCode offset
			if ( Connect_receive_ScanCodeDeviceId > 0 )
    3e3a:	4e3e      	ldr	r6, [pc, #248]	; (3f34 <Connect_receive_ScanCode+0x150>)

		// Reset the BufferPos if higher than sizeof TriggerGuide
		// And send the TriggerGuide to the Macro Module
		if ( Connect_receive_ScanCodeBufferPos >= sizeof( TriggerGuide ) )
		{
			Connect_receive_ScanCodeBufferPos = 0;
    3e3c:	2200      	movs	r2, #0
    3e3e:	701a      	strb	r2, [r3, #0]

			// Adjust ScanCode offset
			if ( Connect_receive_ScanCodeDeviceId > 0 )
    3e40:	7833      	ldrb	r3, [r6, #0]
    3e42:	b18b      	cbz	r3, 3e68 <Connect_receive_ScanCode+0x84>
			{
				// Check if this node is too large
				if ( Connect_receive_ScanCodeDeviceId >= InterconnectNodeMax )
    3e44:	2b01      	cmp	r3, #1
    3e46:	d90a      	bls.n	3e5e <Connect_receive_ScanCode+0x7a>
				{
					warn_msg("Not enough interconnect layout nodes configured: ");
    3e48:	483d      	ldr	r0, [pc, #244]	; (3f40 <Connect_receive_ScanCode+0x15c>)
    3e4a:	f003 fcdb 	bl	7804 <_print>
					printHex( Connect_receive_ScanCodeDeviceId );
    3e4e:	7830      	ldrb	r0, [r6, #0]
    3e50:	2101      	movs	r1, #1
    3e52:	f003 fd60 	bl	7916 <printHex_op>
					print( NL );
    3e56:	483b      	ldr	r0, [pc, #236]	; (3f44 <Connect_receive_ScanCode+0x160>)
    3e58:	f003 fcd4 	bl	7804 <_print>
					break;
    3e5c:	e05e      	b.n	3f1c <Connect_receive_ScanCode+0x138>
				}

				// This variable is in generatedKeymaps.h
				extern uint8_t InterconnectOffsetList[];
				Connect_receive_ScanCodeBuffer.scanCode = Connect_receive_ScanCodeBuffer.scanCode + InterconnectOffsetList[ Connect_receive_ScanCodeDeviceId - 1 ];
    3e5e:	4b3a      	ldr	r3, [pc, #232]	; (3f48 <Connect_receive_ScanCode+0x164>)
    3e60:	781a      	ldrb	r2, [r3, #0]
    3e62:	78ab      	ldrb	r3, [r5, #2]
    3e64:	4413      	add	r3, r2
    3e66:	70ab      	strb	r3, [r5, #2]
			}

			// ScanCode receive debug
			if ( Connect_debug )
    3e68:	4b38      	ldr	r3, [pc, #224]	; (3f4c <Connect_receive_ScanCode+0x168>)
    3e6a:	781b      	ldrb	r3, [r3, #0]
    3e6c:	b1bb      	cbz	r3, 3e9e <Connect_receive_ScanCode+0xba>
			{
				dbug_msg("");
    3e6e:	4838      	ldr	r0, [pc, #224]	; (3f50 <Connect_receive_ScanCode+0x16c>)
    3e70:	f003 fcc8 	bl	7804 <_print>
				printHex( Connect_receive_ScanCodeBuffer.type );
    3e74:	2101      	movs	r1, #1
    3e76:	7828      	ldrb	r0, [r5, #0]
    3e78:	f003 fd4d 	bl	7916 <printHex_op>
				print(" ");
    3e7c:	4835      	ldr	r0, [pc, #212]	; (3f54 <Connect_receive_ScanCode+0x170>)
    3e7e:	f003 fcc1 	bl	7804 <_print>
				printHex( Connect_receive_ScanCodeBuffer.state );
    3e82:	2101      	movs	r1, #1
    3e84:	7868      	ldrb	r0, [r5, #1]
    3e86:	f003 fd46 	bl	7916 <printHex_op>
				print(" ");
    3e8a:	4832      	ldr	r0, [pc, #200]	; (3f54 <Connect_receive_ScanCode+0x170>)
    3e8c:	f003 fcba 	bl	7804 <_print>
				printHex( Connect_receive_ScanCodeBuffer.scanCode );
    3e90:	78a8      	ldrb	r0, [r5, #2]
    3e92:	2101      	movs	r1, #1
    3e94:	f003 fd3f 	bl	7916 <printHex_op>
				print( NL );
    3e98:	482a      	ldr	r0, [pc, #168]	; (3f44 <Connect_receive_ScanCode+0x160>)
    3e9a:	f003 fcb3 	bl	7804 <_print>
			}

			// Send ScanCode to macro module
			Macro_interconnectAdd( &Connect_receive_ScanCodeBuffer );
    3e9e:	4827      	ldr	r0, [pc, #156]	; (3f3c <Connect_receive_ScanCode+0x158>)
    3ea0:	f001 f9e2 	bl	5268 <Macro_interconnectAdd>
    3ea4:	e03a      	b.n	3f1c <Connect_receive_ScanCode+0x138>
		break;
	}
	// Propagate ScanCode packet
	// XXX It would be safer to buffer the scancodes first, before transmitting the packet -Jacob
	//     The current method is the more efficient/aggressive, but could cause issues if there were errors during transmission
	else switch ( (*pending_bytes)-- )
    3ea6:	1e58      	subs	r0, r3, #1
    3ea8:	428b      	cmp	r3, r1
    3eaa:	8020      	strh	r0, [r4, #0]
    3eac:	d01d      	beq.n	3eea <Connect_receive_ScanCode+0x106>
    3eae:	f64f 72ff 	movw	r2, #65535	; 0xffff
    3eb2:	4293      	cmp	r3, r2
    3eb4:	d126      	bne.n	3f04 <Connect_receive_ScanCode+0x120>
	{
	// Byte count always starts at 0xFFFF
	case 0xFFFF: // Device Id
	{
		Connect_receive_ScanCodeDeviceId = byte;
    3eb6:	4b1f      	ldr	r3, [pc, #124]	; (3f34 <Connect_receive_ScanCode+0x150>)
    3eb8:	f89d 0007 	ldrb.w	r0, [sp, #7]
    3ebc:	7018      	strb	r0, [r3, #0]

		// Lock the master Tx buffer
		uart_lockTx( UART_Master );
    3ebe:	4b26      	ldr	r3, [pc, #152]	; (3f58 <Connect_receive_ScanCode+0x174>)
    3ec0:	78dd      	ldrb	r5, [r3, #3]
    3ec2:	b105      	cbz	r5, 3ec6 <Connect_receive_ScanCode+0xe2>
    3ec4:	e7fe      	b.n	3ec4 <Connect_receive_ScanCode+0xe0>
    3ec6:	7899      	ldrb	r1, [r3, #2]
    3ec8:	2201      	movs	r2, #1
    3eca:	2904      	cmp	r1, #4
    3ecc:	70da      	strb	r2, [r3, #3]
    3ece:	d000      	beq.n	3ed2 <Connect_receive_ScanCode+0xee>
    3ed0:	e7fe      	b.n	3ed0 <Connect_receive_ScanCode+0xec>
    3ed2:	709d      	strb	r5, [r3, #2]

		// Send header + Id byte
		uint8_t header[] = { 0x16, 0x01, ScanCode, byte };
    3ed4:	2316      	movs	r3, #22
    3ed6:	f88d 000f 	strb.w	r0, [sp, #15]
    3eda:	f88d 300c 	strb.w	r3, [sp, #12]
    3ede:	f88d 200d 	strb.w	r2, [sp, #13]
    3ee2:	f88d 100e 	strb.w	r1, [sp, #14]
    3ee6:	a803      	add	r0, sp, #12
    3ee8:	e009      	b.n	3efe <Connect_receive_ScanCode+0x11a>
		Connect_addBytes( header, sizeof( header ), UART_Master );
		break;
	}
	case 0xFFFE: // Number of TriggerGuides in bytes
		*pending_bytes = byte * sizeof( TriggerGuide );
    3eea:	a804      	add	r0, sp, #16
    3eec:	2103      	movs	r1, #3
    3eee:	f810 3d09 	ldrb.w	r3, [r0, #-9]!
    3ef2:	434b      	muls	r3, r1
    3ef4:	8023      	strh	r3, [r4, #0]
		Connect_receive_ScanCodeBufferPos = 0;
    3ef6:	4b10      	ldr	r3, [pc, #64]	; (3f38 <Connect_receive_ScanCode+0x154>)
    3ef8:	2101      	movs	r1, #1
    3efa:	701a      	strb	r2, [r3, #0]
    3efc:	460a      	mov	r2, r1
    3efe:	f7ff ff0f 	bl	3d20 <Connect_addBytes.part.1>
    3f02:	e00b      	b.n	3f1c <Connect_receive_ScanCode+0x138>
    3f04:	2101      	movs	r1, #1
    3f06:	460a      	mov	r2, r1
    3f08:	f10d 0007 	add.w	r0, sp, #7
    3f0c:	f7ff ff08 	bl	3d20 <Connect_addBytes.part.1>
	default:
		// Pass through byte
		Connect_addBytes( &byte, 1, UART_Master );

		// Unlock Tx Buffer after sending last byte
		if ( *pending_bytes == 0 )
    3f10:	8822      	ldrh	r2, [r4, #0]
    3f12:	b91a      	cbnz	r2, 3f1c <Connect_receive_ScanCode+0x138>
			uart_unlockTx( UART_Master );
    3f14:	4b10      	ldr	r3, [pc, #64]	; (3f58 <Connect_receive_ScanCode+0x174>)
    3f16:	2104      	movs	r1, #4
    3f18:	7099      	strb	r1, [r3, #2]
    3f1a:	70da      	strb	r2, [r3, #3]
		break;
	}

	// Check whether the scan codes have finished sending
	return *pending_bytes == 0 ? 1 : 0;
    3f1c:	8820      	ldrh	r0, [r4, #0]
}
    3f1e:	f1d0 0001 	rsbs	r0, r0, #1
    3f22:	bf38      	it	cc
    3f24:	2000      	movcc	r0, #0
    3f26:	b004      	add	sp, #16
    3f28:	bd70      	pop	{r4, r5, r6, pc}
    3f2a:	bf00      	nop
    3f2c:	00008f30 	.word	0x00008f30
    3f30:	1fff92d6 	.word	0x1fff92d6
    3f34:	1fffa02b 	.word	0x1fffa02b
    3f38:	1fffa13b 	.word	0x1fffa13b
    3f3c:	1fffa138 	.word	0x1fffa138
    3f40:	00008f65 	.word	0x00008f65
    3f44:	0000bafb 	.word	0x0000bafb
    3f48:	00009d3e 	.word	0x00009d3e
    3f4c:	1fff92cd 	.word	0x1fff92cd
    3f50:	00008fac 	.word	0x00008fac
    3f54:	00008156 	.word	0x00008156
    3f58:	1fffa00e 	.word	0x1fffa00e

00003f5c <Connect_addBytes>:
// -- Ring Buffer Convenience Functions --

void Connect_addBytes( uint8_t *buffer, uint8_t count, uint8_t uart )
{
	// Too big to fit into buffer
	if ( count > UART_Buffer_Size )
    3f5c:	2980      	cmp	r1, #128	; 0x80
    3f5e:	d901      	bls.n	3f64 <Connect_addBytes+0x8>
	{
		erro_msg("Too big of a command to fit into the buffer...");
    3f60:	4804      	ldr	r0, [pc, #16]	; (3f74 <Connect_addBytes+0x18>)
    3f62:	e004      	b.n	3f6e <Connect_addBytes+0x12>
		return;
	}

	// Invalid UART
	if ( uart >= UART_Num_Interfaces )
    3f64:	2a01      	cmp	r2, #1
    3f66:	d801      	bhi.n	3f6c <Connect_addBytes+0x10>
    3f68:	f7ff beda 	b.w	3d20 <Connect_addBytes.part.1>
	{
		erro_print("Invalid UART to send from...");
    3f6c:	4802      	ldr	r0, [pc, #8]	; (3f78 <Connect_addBytes+0x1c>)
    3f6e:	f003 bc49 	b.w	7804 <_print>
    3f72:	bf00      	nop
    3f74:	00008fc0 	.word	0x00008fc0
    3f78:	00009004 	.word	0x00009004

00003f7c <Connect_receive_RemoteCapability>:
uint8_t Connect_receive_RemoteCapabilityArgs[Connect_receive_RemoteCapabilityMaxArgs];

uint8_t Connect_receive_RemoteCapability( uint8_t byte, uint16_t *pending_bytes, uint8_t uart_num )
{
	// Check which byte in the packet we are at
	switch ( (*pending_bytes)-- )
    3f7c:	880b      	ldrh	r3, [r1, #0]
#define Connect_receive_RemoteCapabilityMaxArgs 25 // XXX Calculate the max using kll
RemoteCapabilityCommand Connect_receive_RemoteCapabilityBuffer;
uint8_t Connect_receive_RemoteCapabilityArgs[Connect_receive_RemoteCapabilityMaxArgs];

uint8_t Connect_receive_RemoteCapability( uint8_t byte, uint16_t *pending_bytes, uint8_t uart_num )
{
    3f7e:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    3f80:	460f      	mov	r7, r1
	// Check which byte in the packet we are at
	switch ( (*pending_bytes)-- )
    3f82:	1e59      	subs	r1, r3, #1
    3f84:	f5a3 437f 	sub.w	r3, r3, #65280	; 0xff00
    3f88:	b289      	uxth	r1, r1
    3f8a:	3bfb      	subs	r3, #251	; 0xfb
#define Connect_receive_RemoteCapabilityMaxArgs 25 // XXX Calculate the max using kll
RemoteCapabilityCommand Connect_receive_RemoteCapabilityBuffer;
uint8_t Connect_receive_RemoteCapabilityArgs[Connect_receive_RemoteCapabilityMaxArgs];

uint8_t Connect_receive_RemoteCapability( uint8_t byte, uint16_t *pending_bytes, uint8_t uart_num )
{
    3f8c:	4616      	mov	r6, r2
	// Check which byte in the packet we are at
	switch ( (*pending_bytes)-- )
    3f8e:	8039      	strh	r1, [r7, #0]
    3f90:	4d38      	ldr	r5, [pc, #224]	; (4074 <Connect_receive_RemoteCapability+0xf8>)
    3f92:	2b04      	cmp	r3, #4
    3f94:	d80f      	bhi.n	3fb6 <Connect_receive_RemoteCapability+0x3a>
    3f96:	e8df f003 	tbb	[pc, r3]
    3f9a:	090b      	.short	0x090b
    3f9c:	0507      	.short	0x0507
    3f9e:	03          	.byte	0x03
    3f9f:	00          	.byte	0x00
	{
	// Byte count always starts at 0xFFFF
	case 0xFFFF: // Device Id
		Connect_receive_RemoteCapabilityBuffer.id = byte;
    3fa0:	7068      	strb	r0, [r5, #1]
		break;
    3fa2:	e060      	b.n	4066 <Connect_receive_RemoteCapability+0xea>

	case 0xFFFE: // Capability Index
		Connect_receive_RemoteCapabilityBuffer.capabilityIndex = byte;
    3fa4:	70a8      	strb	r0, [r5, #2]
		break;
    3fa6:	e05e      	b.n	4066 <Connect_receive_RemoteCapability+0xea>

	case 0xFFFD: // State
		Connect_receive_RemoteCapabilityBuffer.state = byte;
    3fa8:	70e8      	strb	r0, [r5, #3]
		break;
    3faa:	e05c      	b.n	4066 <Connect_receive_RemoteCapability+0xea>

	case 0xFFFC: // StateType
		Connect_receive_RemoteCapabilityBuffer.stateType = byte;
    3fac:	7128      	strb	r0, [r5, #4]
		break;
    3fae:	e05a      	b.n	4066 <Connect_receive_RemoteCapability+0xea>

	case 0xFFFB: // Number of args
		Connect_receive_RemoteCapabilityBuffer.numArgs = byte;
    3fb0:	7168      	strb	r0, [r5, #5]
		*pending_bytes = byte;
    3fb2:	8038      	strh	r0, [r7, #0]
		break;
    3fb4:	e057      	b.n	4066 <Connect_receive_RemoteCapability+0xea>

	default:     // Args (# defined by previous byte)
		Connect_receive_RemoteCapabilityArgs[
			Connect_receive_RemoteCapabilityBuffer.numArgs - *pending_bytes + 1
    3fb6:	796b      	ldrb	r3, [r5, #5]
    3fb8:	1a59      	subs	r1, r3, r1
		] = byte;
    3fba:	4b2f      	ldr	r3, [pc, #188]	; (4078 <Connect_receive_RemoteCapability+0xfc>)
    3fbc:	4419      	add	r1, r3
    3fbe:	7048      	strb	r0, [r1, #1]

		// If entire packet has been fully received
		if ( *pending_bytes == 0 )
    3fc0:	883b      	ldrh	r3, [r7, #0]
    3fc2:	2b00      	cmp	r3, #0
    3fc4:	d14f      	bne.n	4066 <Connect_receive_RemoteCapability+0xea>
		{
			// Determine if this is the node to run the capability on
			// Conditions: Matches or broadcast (0xFF)
			if ( Connect_receive_RemoteCapabilityBuffer.id == 0xFF
    3fc6:	4b2b      	ldr	r3, [pc, #172]	; (4074 <Connect_receive_RemoteCapability+0xf8>)
    3fc8:	785b      	ldrb	r3, [r3, #1]
    3fca:	2bff      	cmp	r3, #255	; 0xff
    3fcc:	d003      	beq.n	3fd6 <Connect_receive_RemoteCapability+0x5a>
				|| Connect_receive_RemoteCapabilityBuffer.id == Connect_id )
    3fce:	4a2b      	ldr	r2, [pc, #172]	; (407c <Connect_receive_RemoteCapability+0x100>)
    3fd0:	7812      	ldrb	r2, [r2, #0]
    3fd2:	429a      	cmp	r2, r3
    3fd4:	d107      	bne.n	3fe6 <Connect_receive_RemoteCapability+0x6a>
			{
				extern const Capability CapabilitiesList[]; // See generatedKeymap.h
				void (*capability)(uint8_t, uint8_t, uint8_t*) = (void(*)(uint8_t, uint8_t, uint8_t*))(
					CapabilitiesList[ Connect_receive_RemoteCapabilityBuffer.capabilityIndex ].func
    3fd6:	78aa      	ldrb	r2, [r5, #2]
				);
				capability(
    3fd8:	4b29      	ldr	r3, [pc, #164]	; (4080 <Connect_receive_RemoteCapability+0x104>)
    3fda:	78e8      	ldrb	r0, [r5, #3]
    3fdc:	f853 3032 	ldr.w	r3, [r3, r2, lsl #3]
    3fe0:	7929      	ldrb	r1, [r5, #4]
    3fe2:	4a28      	ldr	r2, [pc, #160]	; (4084 <Connect_receive_RemoteCapability+0x108>)
    3fe4:	4798      	blx	r3
				);
			}

			// If this is not the correct node, keep sending it in the same direction (doesn't matter if more nodes exist)
			// or if this is a broadcast
			if ( Connect_receive_RemoteCapabilityBuffer.id == 0xFF
    3fe6:	786b      	ldrb	r3, [r5, #1]
    3fe8:	2bff      	cmp	r3, #255	; 0xff
    3fea:	d003      	beq.n	3ff4 <Connect_receive_RemoteCapability+0x78>
				|| Connect_receive_RemoteCapabilityBuffer.id != Connect_id )
    3fec:	4a23      	ldr	r2, [pc, #140]	; (407c <Connect_receive_RemoteCapability+0x100>)
    3fee:	7812      	ldrb	r2, [r2, #0]
    3ff0:	429a      	cmp	r2, r3
    3ff2:	d038      	beq.n	4066 <Connect_receive_RemoteCapability+0xea>
			{
				// Prepare outgoing packet
				Connect_receive_RemoteCapabilityBuffer.command = RemoteCapability;

				// Send to the other UART (not the one receiving the packet from
				uint8_t uart_direction = uart_num == UART_Master ? UART_Slave : UART_Master;
    3ff4:	f116 36ff 	adds.w	r6, r6, #4294967295	; 0xffffffff
			// or if this is a broadcast
			if ( Connect_receive_RemoteCapabilityBuffer.id == 0xFF
				|| Connect_receive_RemoteCapabilityBuffer.id != Connect_id )
			{
				// Prepare outgoing packet
				Connect_receive_RemoteCapabilityBuffer.command = RemoteCapability;
    3ff8:	f04f 0306 	mov.w	r3, #6

				// Send to the other UART (not the one receiving the packet from
				uint8_t uart_direction = uart_num == UART_Master ? UART_Slave : UART_Master;
    3ffc:	bf18      	it	ne
    3ffe:	2601      	movne	r6, #1
			// or if this is a broadcast
			if ( Connect_receive_RemoteCapabilityBuffer.id == 0xFF
				|| Connect_receive_RemoteCapabilityBuffer.id != Connect_id )
			{
				// Prepare outgoing packet
				Connect_receive_RemoteCapabilityBuffer.command = RemoteCapability;
    4000:	702b      	strb	r3, [r5, #0]
    4002:	4c21      	ldr	r4, [pc, #132]	; (4088 <Connect_receive_RemoteCapability+0x10c>)

				// Send to the other UART (not the one receiving the packet from
				uint8_t uart_direction = uart_num == UART_Master ? UART_Slave : UART_Master;

				// Lock Tx UART
				switch ( uart_direction )
    4004:	b14e      	cbz	r6, 401a <Connect_receive_RemoteCapability+0x9e>
				{
				case UART_Master: uart_lockTx( UART_Master ); break;
    4006:	78e3      	ldrb	r3, [r4, #3]
    4008:	b103      	cbz	r3, 400c <Connect_receive_RemoteCapability+0x90>
    400a:	e7fe      	b.n	400a <Connect_receive_RemoteCapability+0x8e>
    400c:	78a2      	ldrb	r2, [r4, #2]
    400e:	70e6      	strb	r6, [r4, #3]
    4010:	2a04      	cmp	r2, #4
    4012:	bf08      	it	eq
    4014:	70a3      	strbeq	r3, [r4, #2]
    4016:	d00b      	beq.n	4030 <Connect_receive_RemoteCapability+0xb4>
    4018:	e7fe      	b.n	4018 <Connect_receive_RemoteCapability+0x9c>
				case UART_Slave:  uart_lockTx( UART_Slave );  break;
    401a:	7863      	ldrb	r3, [r4, #1]
    401c:	b103      	cbz	r3, 4020 <Connect_receive_RemoteCapability+0xa4>
    401e:	e7fe      	b.n	401e <Connect_receive_RemoteCapability+0xa2>
    4020:	2201      	movs	r2, #1
    4022:	7062      	strb	r2, [r4, #1]
    4024:	7822      	ldrb	r2, [r4, #0]
    4026:	2a04      	cmp	r2, #4
    4028:	bf08      	it	eq
    402a:	7023      	strbeq	r3, [r4, #0]
    402c:	d000      	beq.n	4030 <Connect_receive_RemoteCapability+0xb4>
    402e:	e7fe      	b.n	402e <Connect_receive_RemoteCapability+0xb2>
				}

				// Send header
				uint8_t header[] = { 0x16, 0x01 };
    4030:	4b16      	ldr	r3, [pc, #88]	; (408c <Connect_receive_RemoteCapability+0x110>)
    4032:	881b      	ldrh	r3, [r3, #0]
				Connect_addBytes( header, sizeof( header ), uart_direction );
    4034:	a801      	add	r0, sp, #4
    4036:	2102      	movs	r1, #2
    4038:	4632      	mov	r2, r6
				case UART_Master: uart_lockTx( UART_Master ); break;
				case UART_Slave:  uart_lockTx( UART_Slave );  break;
				}

				// Send header
				uint8_t header[] = { 0x16, 0x01 };
    403a:	f8ad 3004 	strh.w	r3, [sp, #4]
				Connect_addBytes( header, sizeof( header ), uart_direction );
    403e:	f7ff ff8d 	bl	3f5c <Connect_addBytes>

				// Send Remote Capability and arguments
				Connect_addBytes( (uint8_t*)&Connect_receive_RemoteCapabilityBuffer, sizeof( RemoteCapabilityCommand ), uart_direction );
    4042:	480c      	ldr	r0, [pc, #48]	; (4074 <Connect_receive_RemoteCapability+0xf8>)
    4044:	2106      	movs	r1, #6
    4046:	4632      	mov	r2, r6
    4048:	f7ff ff88 	bl	3f5c <Connect_addBytes>
				Connect_addBytes( Connect_receive_RemoteCapabilityArgs, Connect_receive_RemoteCapabilityBuffer.numArgs, uart_direction );
    404c:	4632      	mov	r2, r6
    404e:	480a      	ldr	r0, [pc, #40]	; (4078 <Connect_receive_RemoteCapability+0xfc>)
    4050:	7969      	ldrb	r1, [r5, #5]
    4052:	f7ff ff83 	bl	3f5c <Connect_addBytes>
    4056:	2204      	movs	r2, #4
    4058:	2300      	movs	r3, #0

				// Unlock Tx UART
				switch ( uart_direction )
    405a:	b116      	cbz	r6, 4062 <Connect_receive_RemoteCapability+0xe6>
				{
				case UART_Master: uart_unlockTx( UART_Master ); break;
    405c:	70a2      	strb	r2, [r4, #2]
    405e:	70e3      	strb	r3, [r4, #3]
    4060:	e001      	b.n	4066 <Connect_receive_RemoteCapability+0xea>
				case UART_Slave:  uart_unlockTx( UART_Slave );  break;
    4062:	7022      	strb	r2, [r4, #0]
    4064:	7063      	strb	r3, [r4, #1]
		}
		break;
	}

	// Check whether the scan codes have finished sending
	return *pending_bytes == 0 ? 1 : 0;
    4066:	8838      	ldrh	r0, [r7, #0]
}
    4068:	f1d0 0001 	rsbs	r0, r0, #1
    406c:	bf38      	it	cc
    406e:	2000      	movcc	r0, #0
    4070:	b003      	add	sp, #12
    4072:	bdf0      	pop	{r4, r5, r6, r7, pc}
    4074:	1fffa008 	.word	0x1fffa008
    4078:	1fffa012 	.word	0x1fffa012
    407c:	1fff89c5 	.word	0x1fff89c5
    4080:	0000a1f8 	.word	0x0000a1f8
    4084:	1fffa014 	.word	0x1fffa014
    4088:	1fffa00e 	.word	0x1fffa00e
    408c:	00008c54 	.word	0x00008c54

00004090 <Connect_send_CableCheck>:

// -- Connect send functions --

// patternLen defines how many bytes should the incrementing pattern have
void Connect_send_CableCheck( uint8_t patternLen )
{
    4090:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	// Wait until the Tx buffers are ready, then lock them
	uart_lockBothTx( UART_Master, UART_Slave );
    4092:	4c21      	ldr	r4, [pc, #132]	; (4118 <Connect_send_CableCheck+0x88>)
    4094:	78e2      	ldrb	r2, [r4, #3]
    4096:	7863      	ldrb	r3, [r4, #1]

// -- Connect send functions --

// patternLen defines how many bytes should the incrementing pattern have
void Connect_send_CableCheck( uint8_t patternLen )
{
    4098:	4607      	mov	r7, r0
	// Wait until the Tx buffers are ready, then lock them
	uart_lockBothTx( UART_Master, UART_Slave );
    409a:	2a00      	cmp	r2, #0
    409c:	d1fd      	bne.n	409a <Connect_send_CableCheck+0xa>
    409e:	2b00      	cmp	r3, #0
    40a0:	d1fd      	bne.n	409e <Connect_send_CableCheck+0xe>
    40a2:	2301      	movs	r3, #1
    40a4:	70e3      	strb	r3, [r4, #3]
    40a6:	7063      	strb	r3, [r4, #1]
    40a8:	7826      	ldrb	r6, [r4, #0]
    40aa:	78a3      	ldrb	r3, [r4, #2]
    40ac:	2b04      	cmp	r3, #4
    40ae:	d1fd      	bne.n	40ac <Connect_send_CableCheck+0x1c>
    40b0:	2e04      	cmp	r6, #4
    40b2:	d1fd      	bne.n	40b0 <Connect_send_CableCheck+0x20>
    40b4:	2500      	movs	r5, #0

	// Prepare header
	uint8_t header[] = { 0x16, 0x01, CableCheck, patternLen };
    40b6:	2316      	movs	r3, #22
    40b8:	2201      	movs	r2, #1
    40ba:	a801      	add	r0, sp, #4
    40bc:	4631      	mov	r1, r6
    40be:	f88d 3004 	strb.w	r3, [sp, #4]
    40c2:	f88d 2005 	strb.w	r2, [sp, #5]

// patternLen defines how many bytes should the incrementing pattern have
void Connect_send_CableCheck( uint8_t patternLen )
{
	// Wait until the Tx buffers are ready, then lock them
	uart_lockBothTx( UART_Master, UART_Slave );
    40c6:	70a5      	strb	r5, [r4, #2]
    40c8:	7025      	strb	r5, [r4, #0]

	// Prepare header
	uint8_t header[] = { 0x16, 0x01, CableCheck, patternLen };
    40ca:	f88d 5006 	strb.w	r5, [sp, #6]
    40ce:	f88d 7007 	strb.w	r7, [sp, #7]
    40d2:	f7ff fe25 	bl	3d20 <Connect_addBytes.part.1>
    40d6:	a801      	add	r0, sp, #4
    40d8:	4631      	mov	r1, r6
    40da:	462a      	mov	r2, r5
    40dc:	f7ff fe20 	bl	3d20 <Connect_addBytes.part.1>
	// Send header
	Connect_addBytes( header, sizeof( header ), UART_Master );
	Connect_addBytes( header, sizeof( header ), UART_Slave );

	// Send 0xD2 (11010010) for each argument
	uint8_t value = 0xD2;
    40e0:	23d2      	movs	r3, #210	; 0xd2
    40e2:	f88d 3003 	strb.w	r3, [sp, #3]
	for ( uint8_t c = 0; c < patternLen; c++ )
    40e6:	42bd      	cmp	r5, r7
    40e8:	d00e      	beq.n	4108 <Connect_send_CableCheck+0x78>
    40ea:	2101      	movs	r1, #1
    40ec:	460a      	mov	r2, r1
    40ee:	f10d 0003 	add.w	r0, sp, #3
    40f2:	f7ff fe15 	bl	3d20 <Connect_addBytes.part.1>
    40f6:	3501      	adds	r5, #1
    40f8:	f10d 0003 	add.w	r0, sp, #3
    40fc:	2101      	movs	r1, #1
    40fe:	2200      	movs	r2, #0
    4100:	f7ff fe0e 	bl	3d20 <Connect_addBytes.part.1>
    4104:	b2ed      	uxtb	r5, r5
    4106:	e7ee      	b.n	40e6 <Connect_send_CableCheck+0x56>
		Connect_addBytes( &value, 1, UART_Master );
		Connect_addBytes( &value, 1, UART_Slave );
	}

	// Release Tx buffers
	uart_unlockTx( UART_Master );
    4108:	2204      	movs	r2, #4
    410a:	2300      	movs	r3, #0
    410c:	70a2      	strb	r2, [r4, #2]
    410e:	70e3      	strb	r3, [r4, #3]
	uart_unlockTx( UART_Slave );
    4110:	7022      	strb	r2, [r4, #0]
    4112:	7063      	strb	r3, [r4, #1]
}
    4114:	b003      	add	sp, #12
    4116:	bdf0      	pop	{r4, r5, r6, r7, pc}
    4118:	1fffa00e 	.word	0x1fffa00e

0000411c <Connect_send_IdRequest>:

void Connect_send_IdRequest()
{
    411c:	b573      	push	{r0, r1, r4, r5, r6, lr}
	// Lock master bound Tx
	uart_lockTx( UART_Master );
    411e:	4c0d      	ldr	r4, [pc, #52]	; (4154 <Connect_send_IdRequest+0x38>)
    4120:	78e5      	ldrb	r5, [r4, #3]
    4122:	b105      	cbz	r5, 4126 <Connect_send_IdRequest+0xa>
    4124:	e7fe      	b.n	4124 <Connect_send_IdRequest+0x8>
    4126:	78a6      	ldrb	r6, [r4, #2]
    4128:	2201      	movs	r2, #1
    412a:	2e04      	cmp	r6, #4
    412c:	70e2      	strb	r2, [r4, #3]
    412e:	d000      	beq.n	4132 <Connect_send_IdRequest+0x16>
    4130:	e7fe      	b.n	4130 <Connect_send_IdRequest+0x14>

	// Prepare header
	uint8_t header[] = { 0x16, 0x01, IdRequest };
    4132:	4b09      	ldr	r3, [pc, #36]	; (4158 <Connect_send_IdRequest+0x3c>)
}

void Connect_send_IdRequest()
{
	// Lock master bound Tx
	uart_lockTx( UART_Master );
    4134:	70a5      	strb	r5, [r4, #2]

	// Prepare header
	uint8_t header[] = { 0x16, 0x01, IdRequest };
    4136:	8819      	ldrh	r1, [r3, #0]
    4138:	789b      	ldrb	r3, [r3, #2]
    413a:	f8ad 1004 	strh.w	r1, [sp, #4]
    413e:	a801      	add	r0, sp, #4
    4140:	2103      	movs	r1, #3
    4142:	f88d 3006 	strb.w	r3, [sp, #6]
    4146:	f7ff fdeb 	bl	3d20 <Connect_addBytes.part.1>

	// Send header
	Connect_addBytes( header, sizeof( header ), UART_Master );

	// Unlock Tx
	uart_unlockTx( UART_Master );
    414a:	70a6      	strb	r6, [r4, #2]
    414c:	70e5      	strb	r5, [r4, #3]
}
    414e:	b002      	add	sp, #8
    4150:	bd70      	pop	{r4, r5, r6, pc}
    4152:	bf00      	nop
    4154:	1fffa00e 	.word	0x1fffa00e
    4158:	00008c56 	.word	0x00008c56

0000415c <Connect_send_IdEnumeration>:

// id is the value the next slave should enumerate as
void Connect_send_IdEnumeration( uint8_t id )
{
    415c:	b573      	push	{r0, r1, r4, r5, r6, lr}
	// Lock slave bound Tx
	uart_lockTx( UART_Slave );
    415e:	4c0f      	ldr	r4, [pc, #60]	; (419c <Connect_send_IdEnumeration+0x40>)
    4160:	7865      	ldrb	r5, [r4, #1]
    4162:	b105      	cbz	r5, 4166 <Connect_send_IdEnumeration+0xa>
    4164:	e7fe      	b.n	4164 <Connect_send_IdEnumeration+0x8>
    4166:	7826      	ldrb	r6, [r4, #0]
    4168:	2301      	movs	r3, #1
    416a:	2e04      	cmp	r6, #4
    416c:	7063      	strb	r3, [r4, #1]
    416e:	d000      	beq.n	4172 <Connect_send_IdEnumeration+0x16>
    4170:	e7fe      	b.n	4170 <Connect_send_IdEnumeration+0x14>

	// Prepare header
	uint8_t header[] = { 0x16, 0x01, IdEnumeration, id };
    4172:	2216      	movs	r2, #22
    4174:	f88d 2004 	strb.w	r2, [sp, #4]
    4178:	f88d 3005 	strb.w	r3, [sp, #5]
    417c:	f88d 0007 	strb.w	r0, [sp, #7]
    4180:	2302      	movs	r3, #2
    4182:	a801      	add	r0, sp, #4
    4184:	4631      	mov	r1, r6
    4186:	462a      	mov	r2, r5

// id is the value the next slave should enumerate as
void Connect_send_IdEnumeration( uint8_t id )
{
	// Lock slave bound Tx
	uart_lockTx( UART_Slave );
    4188:	7025      	strb	r5, [r4, #0]

	// Prepare header
	uint8_t header[] = { 0x16, 0x01, IdEnumeration, id };
    418a:	f88d 3006 	strb.w	r3, [sp, #6]
    418e:	f7ff fdc7 	bl	3d20 <Connect_addBytes.part.1>

	// Send header
	Connect_addBytes( header, sizeof( header ), UART_Slave );

	// Unlock Tx
	uart_unlockTx( UART_Slave );
    4192:	7026      	strb	r6, [r4, #0]
    4194:	7065      	strb	r5, [r4, #1]
}
    4196:	b002      	add	sp, #8
    4198:	bd70      	pop	{r4, r5, r6, pc}
    419a:	bf00      	nop
    419c:	1fffa00e 	.word	0x1fffa00e

000041a0 <Connect_receive_IdRequest>:
	// Check whether the cable check has finished
	return *pending_bytes == 0 ? 1 : 0;
}

uint8_t Connect_receive_IdRequest( uint8_t byte, uint16_t *pending_bytes, uint8_t uart_num )
{
    41a0:	b510      	push	{r4, lr}
	dbug_print("IdRequest");
    41a2:	480a      	ldr	r0, [pc, #40]	; (41cc <Connect_receive_IdRequest+0x2c>)
	// Check whether the cable check has finished
	return *pending_bytes == 0 ? 1 : 0;
}

uint8_t Connect_receive_IdRequest( uint8_t byte, uint16_t *pending_bytes, uint8_t uart_num )
{
    41a4:	4614      	mov	r4, r2
	dbug_print("IdRequest");
    41a6:	f003 fb2d 	bl	7804 <_print>
	// Check the directionality
	if ( uart_num == UART_Master )
    41aa:	2c01      	cmp	r4, #1
    41ac:	d102      	bne.n	41b4 <Connect_receive_IdRequest+0x14>
	{
		erro_print("Invalid IdRequest direction...");
    41ae:	4808      	ldr	r0, [pc, #32]	; (41d0 <Connect_receive_IdRequest+0x30>)
    41b0:	f003 fb28 	bl	7804 <_print>
	}

	// Check if master, begin IdEnumeration
	if ( Connect_master )
    41b4:	4b07      	ldr	r3, [pc, #28]	; (41d4 <Connect_receive_IdRequest+0x34>)
    41b6:	781b      	ldrb	r3, [r3, #0]
    41b8:	b11b      	cbz	r3, 41c2 <Connect_receive_IdRequest+0x22>
	{
		// The first device is always id 1
		// Id 0 is reserved for the master
		Connect_send_IdEnumeration( 1 );
    41ba:	2001      	movs	r0, #1
    41bc:	f7ff ffce 	bl	415c <Connect_send_IdEnumeration>
    41c0:	e001      	b.n	41c6 <Connect_receive_IdRequest+0x26>
	}
	// Propagate IdRequest
	else
	{
		Connect_send_IdRequest();
    41c2:	f7ff ffab 	bl	411c <Connect_send_IdRequest>
	}

	return 1;
}
    41c6:	2001      	movs	r0, #1
    41c8:	bd10      	pop	{r4, pc}
    41ca:	bf00      	nop
    41cc:	00009038 	.word	0x00009038
    41d0:	00009057 	.word	0x00009057
    41d4:	1fff92d6 	.word	0x1fff92d6

000041d8 <Connect_send_IdReport>:
	uart_unlockTx( UART_Slave );
}

// id is the currently assigned id to the slave
void Connect_send_IdReport( uint8_t id )
{
    41d8:	b573      	push	{r0, r1, r4, r5, r6, lr}
	// Lock master bound Tx
	uart_lockTx( UART_Master );
    41da:	4c0e      	ldr	r4, [pc, #56]	; (4214 <Connect_send_IdReport+0x3c>)
    41dc:	78e5      	ldrb	r5, [r4, #3]
    41de:	b105      	cbz	r5, 41e2 <Connect_send_IdReport+0xa>
    41e0:	e7fe      	b.n	41e0 <Connect_send_IdReport+0x8>
    41e2:	78a6      	ldrb	r6, [r4, #2]
    41e4:	2201      	movs	r2, #1
    41e6:	2e04      	cmp	r6, #4
    41e8:	70e2      	strb	r2, [r4, #3]
    41ea:	d000      	beq.n	41ee <Connect_send_IdReport+0x16>
    41ec:	e7fe      	b.n	41ec <Connect_send_IdReport+0x14>

	// Prepare header
	uint8_t header[] = { 0x16, 0x01, IdReport, id };
    41ee:	2316      	movs	r3, #22
    41f0:	f88d 3004 	strb.w	r3, [sp, #4]
    41f4:	f88d 0007 	strb.w	r0, [sp, #7]
    41f8:	2303      	movs	r3, #3
    41fa:	a801      	add	r0, sp, #4
    41fc:	4631      	mov	r1, r6

// id is the currently assigned id to the slave
void Connect_send_IdReport( uint8_t id )
{
	// Lock master bound Tx
	uart_lockTx( UART_Master );
    41fe:	70a5      	strb	r5, [r4, #2]

	// Prepare header
	uint8_t header[] = { 0x16, 0x01, IdReport, id };
    4200:	f88d 2005 	strb.w	r2, [sp, #5]
    4204:	f88d 3006 	strb.w	r3, [sp, #6]
    4208:	f7ff fd8a 	bl	3d20 <Connect_addBytes.part.1>

	// Send header
	Connect_addBytes( header, sizeof( header ), UART_Master );

	// Unlock Tx
	uart_unlockTx( UART_Master );
    420c:	70a6      	strb	r6, [r4, #2]
    420e:	70e5      	strb	r5, [r4, #3]
}
    4210:	b002      	add	sp, #8
    4212:	bd70      	pop	{r4, r5, r6, pc}
    4214:	1fffa00e 	.word	0x1fffa00e

00004218 <Connect_receive_IdEnumeration>:

	return 1;
}

uint8_t Connect_receive_IdEnumeration( uint8_t id, uint16_t *pending_bytes, uint8_t uart_num )
{
    4218:	b538      	push	{r3, r4, r5, lr}
    421a:	4604      	mov	r4, r0
    421c:	4615      	mov	r5, r2
	dbug_print("IdEnumeration");
    421e:	480a      	ldr	r0, [pc, #40]	; (4248 <Connect_receive_IdEnumeration+0x30>)
    4220:	f003 faf0 	bl	7804 <_print>
	// Check the directionality
	if ( uart_num == UART_Slave )
    4224:	b915      	cbnz	r5, 422c <Connect_receive_IdEnumeration+0x14>
	{
		erro_print("Invalid IdEnumeration direction...");
    4226:	4809      	ldr	r0, [pc, #36]	; (424c <Connect_receive_IdEnumeration+0x34>)
    4228:	f003 faec 	bl	7804 <_print>
	}

	// Set the device id
	Connect_id = id;
    422c:	4b08      	ldr	r3, [pc, #32]	; (4250 <Connect_receive_IdEnumeration+0x38>)

	// Send reponse back to master
	Connect_send_IdReport( id );
    422e:	4620      	mov	r0, r4
	{
		erro_print("Invalid IdEnumeration direction...");
	}

	// Set the device id
	Connect_id = id;
    4230:	701c      	strb	r4, [r3, #0]

	// Send reponse back to master
	Connect_send_IdReport( id );
    4232:	f7ff ffd1 	bl	41d8 <Connect_send_IdReport>

	// Propogate next Id if the connection is ok
	if ( Connect_cableOkSlave )
    4236:	4b07      	ldr	r3, [pc, #28]	; (4254 <Connect_receive_IdEnumeration+0x3c>)
    4238:	781b      	ldrb	r3, [r3, #0]
    423a:	b11b      	cbz	r3, 4244 <Connect_receive_IdEnumeration+0x2c>
	{
		Connect_send_IdEnumeration( id + 1 );
    423c:	1c60      	adds	r0, r4, #1
    423e:	b2c0      	uxtb	r0, r0
    4240:	f7ff ff8c 	bl	415c <Connect_send_IdEnumeration>
	}

	return 1;
}
    4244:	2001      	movs	r0, #1
    4246:	bd38      	pop	{r3, r4, r5, pc}
    4248:	0000908d 	.word	0x0000908d
    424c:	000090b0 	.word	0x000090b0
    4250:	1fff89c5 	.word	0x1fff89c5
    4254:	1fff92d4 	.word	0x1fff92d4

00004258 <Connect_receive_IdReport>:

uint8_t Connect_receive_IdReport( uint8_t id, uint16_t *pending_bytes, uint8_t uart_num )
{
    4258:	b538      	push	{r3, r4, r5, lr}
    425a:	4615      	mov	r5, r2
    425c:	4604      	mov	r4, r0
	dbug_print("IdReport");
    425e:	4810      	ldr	r0, [pc, #64]	; (42a0 <Connect_receive_IdReport+0x48>)
    4260:	f003 fad0 	bl	7804 <_print>
	// Check the directionality
	if ( uart_num == UART_Master )
    4264:	2d01      	cmp	r5, #1
    4266:	d102      	bne.n	426e <Connect_receive_IdReport+0x16>
	{
		erro_print("Invalid IdRequest direction...");
    4268:	480e      	ldr	r0, [pc, #56]	; (42a4 <Connect_receive_IdReport+0x4c>)
    426a:	f003 facb 	bl	7804 <_print>
	}

	// Track Id response if master
	if ( Connect_master )
    426e:	4b0e      	ldr	r3, [pc, #56]	; (42a8 <Connect_receive_IdReport+0x50>)
    4270:	781b      	ldrb	r3, [r3, #0]
    4272:	b17b      	cbz	r3, 4294 <Connect_receive_IdReport+0x3c>
	{
		info_msg("Id Reported: ");
    4274:	480d      	ldr	r0, [pc, #52]	; (42ac <Connect_receive_IdReport+0x54>)
    4276:	f003 fac5 	bl	7804 <_print>
		printHex( id );
    427a:	4620      	mov	r0, r4
    427c:	2101      	movs	r1, #1
    427e:	f003 fb4a 	bl	7916 <printHex_op>
		print( NL );
    4282:	480b      	ldr	r0, [pc, #44]	; (42b0 <Connect_receive_IdReport+0x58>)
    4284:	f003 fabe 	bl	7804 <_print>

		// Check if this is the highest ID
		if ( id > Connect_maxId )
    4288:	4b0a      	ldr	r3, [pc, #40]	; (42b4 <Connect_receive_IdReport+0x5c>)
    428a:	781a      	ldrb	r2, [r3, #0]
    428c:	42a2      	cmp	r2, r4
    428e:	d204      	bcs.n	429a <Connect_receive_IdReport+0x42>
			Connect_maxId = id;
    4290:	701c      	strb	r4, [r3, #0]
    4292:	e002      	b.n	429a <Connect_receive_IdReport+0x42>
		return 1;
	}
	// Propagate id if yet another slave
	else
	{
		Connect_send_IdReport( id );
    4294:	4620      	mov	r0, r4
    4296:	f7ff ff9f 	bl	41d8 <Connect_send_IdReport>
	}

	return 1;
}
    429a:	2001      	movs	r0, #1
    429c:	bd38      	pop	{r3, r4, r5, pc}
    429e:	bf00      	nop
    42a0:	000090ea 	.word	0x000090ea
    42a4:	00009057 	.word	0x00009057
    42a8:	1fff92d6 	.word	0x1fff92d6
    42ac:	00009108 	.word	0x00009108
    42b0:	0000bafb 	.word	0x0000bafb
    42b4:	1fff92cc 	.word	0x1fff92cc

000042b8 <Connect_send_ScanCode>:

// id is the currently assigned id to the slave
// scanCodeStateList is an array of [scancode, state]'s (8 bit values)
// numScanCodes is the number of scan codes to parse from array
void Connect_send_ScanCode( uint8_t id, TriggerGuide *scanCodeStateList, uint8_t numScanCodes )
{
    42b8:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
	// Lock master bound Tx
	uart_lockTx( UART_Master );
    42bc:	4c14      	ldr	r4, [pc, #80]	; (4310 <Connect_send_ScanCode+0x58>)
    42be:	78e6      	ldrb	r6, [r4, #3]

// id is the currently assigned id to the slave
// scanCodeStateList is an array of [scancode, state]'s (8 bit values)
// numScanCodes is the number of scan codes to parse from array
void Connect_send_ScanCode( uint8_t id, TriggerGuide *scanCodeStateList, uint8_t numScanCodes )
{
    42c0:	4689      	mov	r9, r1
    42c2:	4690      	mov	r8, r2
	// Lock master bound Tx
	uart_lockTx( UART_Master );
    42c4:	b106      	cbz	r6, 42c8 <Connect_send_ScanCode+0x10>
    42c6:	e7fe      	b.n	42c6 <Connect_send_ScanCode+0xe>
    42c8:	78a7      	ldrb	r7, [r4, #2]
    42ca:	2501      	movs	r5, #1
    42cc:	2f04      	cmp	r7, #4
    42ce:	70e5      	strb	r5, [r4, #3]
    42d0:	d000      	beq.n	42d4 <Connect_send_ScanCode+0x1c>
    42d2:	e7fe      	b.n	42d2 <Connect_send_ScanCode+0x1a>

	// Prepare header
	uint8_t header[] = { 0x16, 0x01, ScanCode, id, numScanCodes };
    42d4:	2316      	movs	r3, #22
    42d6:	f88d 0003 	strb.w	r0, [sp, #3]
    42da:	f88d 2004 	strb.w	r2, [sp, #4]
    42de:	4668      	mov	r0, sp
    42e0:	462a      	mov	r2, r5
    42e2:	2105      	movs	r1, #5
    42e4:	f88d 3000 	strb.w	r3, [sp]
// scanCodeStateList is an array of [scancode, state]'s (8 bit values)
// numScanCodes is the number of scan codes to parse from array
void Connect_send_ScanCode( uint8_t id, TriggerGuide *scanCodeStateList, uint8_t numScanCodes )
{
	// Lock master bound Tx
	uart_lockTx( UART_Master );
    42e8:	70a6      	strb	r6, [r4, #2]

	// Prepare header
	uint8_t header[] = { 0x16, 0x01, ScanCode, id, numScanCodes };
    42ea:	f88d 5001 	strb.w	r5, [sp, #1]
    42ee:	f88d 7002 	strb.w	r7, [sp, #2]
    42f2:	f7ff fd15 	bl	3d20 <Connect_addBytes.part.1>

	// Send header
	Connect_addBytes( header, sizeof( header ), UART_Master );

	// Send each of the scan codes
	Connect_addBytes( (uint8_t*)scanCodeStateList, numScanCodes * TriggerGuideSize, UART_Master );
    42f6:	2303      	movs	r3, #3
    42f8:	fb03 f108 	mul.w	r1, r3, r8
    42fc:	4648      	mov	r0, r9
    42fe:	b2c9      	uxtb	r1, r1
    4300:	462a      	mov	r2, r5
    4302:	f7ff fe2b 	bl	3f5c <Connect_addBytes>

	// Unlock Tx
	uart_unlockTx( UART_Master );
    4306:	70a7      	strb	r7, [r4, #2]
    4308:	70e6      	strb	r6, [r4, #3]
}
    430a:	b003      	add	sp, #12
    430c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    4310:	1fffa00e 	.word	0x1fffa00e

00004314 <cliFunc_connectCmd>:


// ----- CLI Command Functions -----

void cliFunc_connectCmd( char* args )
{
    4314:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	// Parse number from argument
	//  NOTE: Only first argument is used
	char* arg1Ptr;
	char* arg2Ptr;
	CLI_argumentIsolation( args, &arg1Ptr, &arg2Ptr );
    4316:	4669      	mov	r1, sp
    4318:	aa01      	add	r2, sp, #4
    431a:	f002 ffc1 	bl	72a0 <CLI_argumentIsolation>

	print( NL );
    431e:	4815      	ldr	r0, [pc, #84]	; (4374 <cliFunc_connectCmd+0x60>)
    4320:	f003 fa70 	bl	7804 <_print>

	switch ( numToInt( &arg1Ptr[0] ) )
    4324:	9800      	ldr	r0, [sp, #0]
    4326:	f003 fb4b 	bl	79c0 <numToInt>
    432a:	2804      	cmp	r0, #4
    432c:	d81e      	bhi.n	436c <cliFunc_connectCmd+0x58>
    432e:	e8df f000 	tbb	[pc, r0]
    4332:	0703      	.short	0x0703
    4334:	0e0a      	.short	0x0e0a
    4336:	12          	.byte	0x12
    4337:	00          	.byte	0x00
	{
	case CableCheck:
		Connect_send_CableCheck( UARTConnectCableCheckLength_define );
    4338:	2002      	movs	r0, #2
    433a:	f7ff fea9 	bl	4090 <Connect_send_CableCheck>
		break;
    433e:	e015      	b.n	436c <cliFunc_connectCmd+0x58>

	case IdRequest:
		Connect_send_IdRequest();
    4340:	f7ff feec 	bl	411c <Connect_send_IdRequest>
		break;
    4344:	e012      	b.n	436c <cliFunc_connectCmd+0x58>

	case IdEnumeration:
		Connect_send_IdEnumeration( 5 );
    4346:	2005      	movs	r0, #5
    4348:	f7ff ff08 	bl	415c <Connect_send_IdEnumeration>
		break;
    434c:	e00e      	b.n	436c <cliFunc_connectCmd+0x58>

	case IdReport:
		Connect_send_IdReport( 8 );
    434e:	2008      	movs	r0, #8
    4350:	f7ff ff42 	bl	41d8 <Connect_send_IdReport>
		break;
    4354:	e00a      	b.n	436c <cliFunc_connectCmd+0x58>

	case ScanCode:
	{
		TriggerGuide scanCodes[] = { { 0x00, 0x01, 0x05 }, { 0x00, 0x03, 0x16 } };
    4356:	4b08      	ldr	r3, [pc, #32]	; (4378 <cliFunc_connectCmd+0x64>)
    4358:	6818      	ldr	r0, [r3, #0]
    435a:	889b      	ldrh	r3, [r3, #4]
    435c:	9002      	str	r0, [sp, #8]
		Connect_send_ScanCode( 10, scanCodes, 2 );
    435e:	a902      	add	r1, sp, #8
    4360:	200a      	movs	r0, #10
    4362:	2202      	movs	r2, #2
		Connect_send_IdReport( 8 );
		break;

	case ScanCode:
	{
		TriggerGuide scanCodes[] = { { 0x00, 0x01, 0x05 }, { 0x00, 0x03, 0x16 } };
    4364:	f8ad 300c 	strh.w	r3, [sp, #12]
		Connect_send_ScanCode( 10, scanCodes, 2 );
    4368:	f7ff ffa6 	bl	42b8 <Connect_send_ScanCode>
		break;

	default:
		break;
	}
}
    436c:	b005      	add	sp, #20
    436e:	f85d fb04 	ldr.w	pc, [sp], #4
    4372:	bf00      	nop
    4374:	0000bafb 	.word	0x0000bafb
    4378:	00008c59 	.word	0x00008c59

0000437c <Connect_send_RemoteCapability>:

// Send a remote capability command using capability index
// This may not be what's expected (especially if the firmware is not the same on each node)
// To broadcast to all slave nodes, set id to 255 instead of a specific id
void Connect_send_RemoteCapability( uint8_t id, uint8_t capabilityIndex, uint8_t state, uint8_t stateType, uint8_t numArgs, uint8_t *args )
{
    437c:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
	// Prepare header
	uint8_t header[] = { 0x16, 0x01, RemoteCapability, id, capabilityIndex, state, stateType, numArgs };
    4380:	f88d 3006 	strb.w	r3, [sp, #6]

	// Ignore current id
	if ( id == Connect_id )
    4384:	4b2c      	ldr	r3, [pc, #176]	; (4438 <Connect_send_RemoteCapability+0xbc>)
// This may not be what's expected (especially if the firmware is not the same on each node)
// To broadcast to all slave nodes, set id to 255 instead of a specific id
void Connect_send_RemoteCapability( uint8_t id, uint8_t capabilityIndex, uint8_t state, uint8_t stateType, uint8_t numArgs, uint8_t *args )
{
	// Prepare header
	uint8_t header[] = { 0x16, 0x01, RemoteCapability, id, capabilityIndex, state, stateType, numArgs };
    4386:	f88d 2005 	strb.w	r2, [sp, #5]

	// Ignore current id
	if ( id == Connect_id )
    438a:	781a      	ldrb	r2, [r3, #0]

// Send a remote capability command using capability index
// This may not be what's expected (especially if the firmware is not the same on each node)
// To broadcast to all slave nodes, set id to 255 instead of a specific id
void Connect_send_RemoteCapability( uint8_t id, uint8_t capabilityIndex, uint8_t state, uint8_t stateType, uint8_t numArgs, uint8_t *args )
{
    438c:	f89d 7028 	ldrb.w	r7, [sp, #40]	; 0x28
    4390:	f8dd 802c 	ldr.w	r8, [sp, #44]	; 0x2c
	// Prepare header
	uint8_t header[] = { 0x16, 0x01, RemoteCapability, id, capabilityIndex, state, stateType, numArgs };
    4394:	f88d 1004 	strb.w	r1, [sp, #4]

// Send a remote capability command using capability index
// This may not be what's expected (especially if the firmware is not the same on each node)
// To broadcast to all slave nodes, set id to 255 instead of a specific id
void Connect_send_RemoteCapability( uint8_t id, uint8_t capabilityIndex, uint8_t state, uint8_t stateType, uint8_t numArgs, uint8_t *args )
{
    4398:	4606      	mov	r6, r0
	// Prepare header
	uint8_t header[] = { 0x16, 0x01, RemoteCapability, id, capabilityIndex, state, stateType, numArgs };
    439a:	2016      	movs	r0, #22
    439c:	f88d 0000 	strb.w	r0, [sp]
    43a0:	2406      	movs	r4, #6
    43a2:	2001      	movs	r0, #1

	// Ignore current id
	if ( id == Connect_id )
    43a4:	4296      	cmp	r6, r2
// This may not be what's expected (especially if the firmware is not the same on each node)
// To broadcast to all slave nodes, set id to 255 instead of a specific id
void Connect_send_RemoteCapability( uint8_t id, uint8_t capabilityIndex, uint8_t state, uint8_t stateType, uint8_t numArgs, uint8_t *args )
{
	// Prepare header
	uint8_t header[] = { 0x16, 0x01, RemoteCapability, id, capabilityIndex, state, stateType, numArgs };
    43a6:	f88d 0001 	strb.w	r0, [sp, #1]
    43aa:	f88d 4002 	strb.w	r4, [sp, #2]
    43ae:	f88d 6003 	strb.w	r6, [sp, #3]
    43b2:	f88d 7007 	strb.w	r7, [sp, #7]
    43b6:	469a      	mov	sl, r3

	// Ignore current id
	if ( id == Connect_id )
    43b8:	d03b      	beq.n	4432 <Connect_send_RemoteCapability+0xb6>
		return;

	// Send towards slave node
	if ( id > Connect_id )
    43ba:	d918      	bls.n	43ee <Connect_send_RemoteCapability+0x72>
	{
		// Lock slave bound Tx
		uart_lockTx( UART_Slave );
    43bc:	4c1f      	ldr	r4, [pc, #124]	; (443c <Connect_send_RemoteCapability+0xc0>)
    43be:	7865      	ldrb	r5, [r4, #1]
    43c0:	b105      	cbz	r5, 43c4 <Connect_send_RemoteCapability+0x48>
    43c2:	e7fe      	b.n	43c2 <Connect_send_RemoteCapability+0x46>
    43c4:	f894 9000 	ldrb.w	r9, [r4]
    43c8:	7060      	strb	r0, [r4, #1]
    43ca:	f1b9 0f04 	cmp.w	r9, #4
    43ce:	d000      	beq.n	43d2 <Connect_send_RemoteCapability+0x56>
    43d0:	e7fe      	b.n	43d0 <Connect_send_RemoteCapability+0x54>
    43d2:	4668      	mov	r0, sp
    43d4:	2108      	movs	r1, #8
    43d6:	462a      	mov	r2, r5
    43d8:	7025      	strb	r5, [r4, #0]
    43da:	f7ff fca1 	bl	3d20 <Connect_addBytes.part.1>

		// Send header
		Connect_addBytes( header, sizeof( header ), UART_Slave );

		// Send arguments
		Connect_addBytes( args, numArgs, UART_Slave );
    43de:	4640      	mov	r0, r8
    43e0:	4639      	mov	r1, r7
    43e2:	462a      	mov	r2, r5
    43e4:	f7ff fdba 	bl	3f5c <Connect_addBytes>

		// Unlock Tx
		uart_unlockTx( UART_Slave );
    43e8:	f884 9000 	strb.w	r9, [r4]
    43ec:	7065      	strb	r5, [r4, #1]
	}

	// Send towards master node
	if ( id < Connect_id || id == 255 )
    43ee:	f89a 3000 	ldrb.w	r3, [sl]
    43f2:	42b3      	cmp	r3, r6
    43f4:	d903      	bls.n	43fe <Connect_send_RemoteCapability+0x82>
	{
		// Lock slave bound Tx
		uart_lockTx( UART_Master );
    43f6:	4c11      	ldr	r4, [pc, #68]	; (443c <Connect_send_RemoteCapability+0xc0>)
    43f8:	78e5      	ldrb	r5, [r4, #3]
    43fa:	b125      	cbz	r5, 4406 <Connect_send_RemoteCapability+0x8a>
    43fc:	e002      	b.n	4404 <Connect_send_RemoteCapability+0x88>
		// Unlock Tx
		uart_unlockTx( UART_Slave );
	}

	// Send towards master node
	if ( id < Connect_id || id == 255 )
    43fe:	2eff      	cmp	r6, #255	; 0xff
    4400:	d117      	bne.n	4432 <Connect_send_RemoteCapability+0xb6>
    4402:	e7f8      	b.n	43f6 <Connect_send_RemoteCapability+0x7a>
    4404:	e7fe      	b.n	4404 <Connect_send_RemoteCapability+0x88>
	{
		// Lock slave bound Tx
		uart_lockTx( UART_Master );
    4406:	f894 9002 	ldrb.w	r9, [r4, #2]
    440a:	2601      	movs	r6, #1
    440c:	f1b9 0f04 	cmp.w	r9, #4
    4410:	70e6      	strb	r6, [r4, #3]
    4412:	d000      	beq.n	4416 <Connect_send_RemoteCapability+0x9a>
    4414:	e7fe      	b.n	4414 <Connect_send_RemoteCapability+0x98>
    4416:	4668      	mov	r0, sp
    4418:	2108      	movs	r1, #8
    441a:	4632      	mov	r2, r6
    441c:	70a5      	strb	r5, [r4, #2]
    441e:	f7ff fc7f 	bl	3d20 <Connect_addBytes.part.1>

		// Send header
		Connect_addBytes( header, sizeof( header ), UART_Master );

		// Send arguments
		Connect_addBytes( args, numArgs, UART_Master );
    4422:	4640      	mov	r0, r8
    4424:	4639      	mov	r1, r7
    4426:	4632      	mov	r2, r6
    4428:	f7ff fd98 	bl	3f5c <Connect_addBytes>

		// Unlock Tx
		uart_unlockTx( UART_Master );
    442c:	f884 9002 	strb.w	r9, [r4, #2]
    4430:	70e5      	strb	r5, [r4, #3]
	}
}
    4432:	b002      	add	sp, #8
    4434:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    4438:	1fff89c5 	.word	0x1fff89c5
    443c:	1fffa00e 	.word	0x1fffa00e

00004440 <Connect_send_Idle>:

void Connect_send_Idle( uint8_t num )
{
    4440:	b573      	push	{r0, r1, r4, r5, r6, lr}
	// Wait until the Tx buffers are ready, then lock them
	uart_lockBothTx( UART_Slave, UART_Master );
    4442:	4c18      	ldr	r4, [pc, #96]	; (44a4 <Connect_send_Idle+0x64>)
    4444:	7862      	ldrb	r2, [r4, #1]
    4446:	78e3      	ldrb	r3, [r4, #3]
		uart_unlockTx( UART_Master );
	}
}

void Connect_send_Idle( uint8_t num )
{
    4448:	4606      	mov	r6, r0
	// Wait until the Tx buffers are ready, then lock them
	uart_lockBothTx( UART_Slave, UART_Master );
    444a:	2a00      	cmp	r2, #0
    444c:	d1fd      	bne.n	444a <Connect_send_Idle+0xa>
    444e:	2b00      	cmp	r3, #0
    4450:	d1fd      	bne.n	444e <Connect_send_Idle+0xe>
    4452:	2301      	movs	r3, #1
    4454:	7063      	strb	r3, [r4, #1]
    4456:	70e3      	strb	r3, [r4, #3]
    4458:	7822      	ldrb	r2, [r4, #0]
    445a:	78a3      	ldrb	r3, [r4, #2]
    445c:	2a04      	cmp	r2, #4
    445e:	d1fd      	bne.n	445c <Connect_send_Idle+0x1c>
    4460:	2b04      	cmp	r3, #4
    4462:	d1fd      	bne.n	4460 <Connect_send_Idle+0x20>
    4464:	2500      	movs	r5, #0

	// Send n number of idles to reset link status (if in a bad state)
	uint8_t value = 0x16;
    4466:	2316      	movs	r3, #22
}

void Connect_send_Idle( uint8_t num )
{
	// Wait until the Tx buffers are ready, then lock them
	uart_lockBothTx( UART_Slave, UART_Master );
    4468:	7025      	strb	r5, [r4, #0]
    446a:	70a5      	strb	r5, [r4, #2]

	// Send n number of idles to reset link status (if in a bad state)
	uint8_t value = 0x16;
    446c:	f88d 3007 	strb.w	r3, [sp, #7]
	for ( uint8_t c = 0; c < num; c++ )
    4470:	42b5      	cmp	r5, r6
    4472:	d00e      	beq.n	4492 <Connect_send_Idle+0x52>
    4474:	2101      	movs	r1, #1
    4476:	460a      	mov	r2, r1
    4478:	f10d 0007 	add.w	r0, sp, #7
    447c:	f7ff fc50 	bl	3d20 <Connect_addBytes.part.1>
    4480:	3501      	adds	r5, #1
    4482:	f10d 0007 	add.w	r0, sp, #7
    4486:	2101      	movs	r1, #1
    4488:	2200      	movs	r2, #0
    448a:	f7ff fc49 	bl	3d20 <Connect_addBytes.part.1>
    448e:	b2ed      	uxtb	r5, r5
    4490:	e7ee      	b.n	4470 <Connect_send_Idle+0x30>
		Connect_addBytes( &value, 1, UART_Master );
		Connect_addBytes( &value, 1, UART_Slave );
	}

	// Release Tx buffers
	uart_unlockTx( UART_Master );
    4492:	2204      	movs	r2, #4
    4494:	2300      	movs	r3, #0
    4496:	70a2      	strb	r2, [r4, #2]
    4498:	70e3      	strb	r3, [r4, #3]
	uart_unlockTx( UART_Slave );
    449a:	7022      	strb	r2, [r4, #0]
    449c:	7063      	strb	r3, [r4, #1]
}
    449e:	b002      	add	sp, #8
    44a0:	bd70      	pop	{r4, r5, r6, pc}
    44a2:	bf00      	nop
    44a4:	1fffa00e 	.word	0x1fffa00e

000044a8 <cliFunc_connectIdl>:
	info_msg("Connect Debug Mode Toggle");
	Connect_debug = !Connect_debug;
}

void cliFunc_connectIdl( char* args )
{
    44a8:	b507      	push	{r0, r1, r2, lr}
	// Parse number from argument
	//  NOTE: Only first argument is used
	char* arg1Ptr;
	char* arg2Ptr;
	CLI_argumentIsolation( args, &arg1Ptr, &arg2Ptr );
    44aa:	4669      	mov	r1, sp
    44ac:	aa01      	add	r2, sp, #4
    44ae:	f002 fef7 	bl	72a0 <CLI_argumentIsolation>

	print( NL );
    44b2:	4809      	ldr	r0, [pc, #36]	; (44d8 <cliFunc_connectIdl+0x30>)
    44b4:	f003 f9a6 	bl	7804 <_print>
	info_msg("Sending Sync Idles...");
    44b8:	4808      	ldr	r0, [pc, #32]	; (44dc <cliFunc_connectIdl+0x34>)
    44ba:	f003 f9a3 	bl	7804 <_print>

	uint8_t count = numToInt( &arg1Ptr[0] );
    44be:	9800      	ldr	r0, [sp, #0]
    44c0:	f003 fa7e 	bl	79c0 <numToInt>
    44c4:	b2c0      	uxtb	r0, r0
	// Default to 2 idles
	if ( count == 0 )
		count = 2;

	Connect_send_Idle( count );
    44c6:	2800      	cmp	r0, #0
    44c8:	bf08      	it	eq
    44ca:	2002      	moveq	r0, #2
    44cc:	f7ff ffb8 	bl	4440 <Connect_send_Idle>
}
    44d0:	b003      	add	sp, #12
    44d2:	f85d fb04 	ldr.w	pc, [sp], #4
    44d6:	bf00      	nop
    44d8:	0000bafb 	.word	0x0000bafb
    44dc:	00009128 	.word	0x00009128

000044e0 <Connect_reset>:

// ----- Functions -----

// Resets the state of the UART buffers and state variables
void Connect_reset()
{
    44e0:	b510      	push	{r4, lr}
	// Reset Rx
	memset( (void*)uart_rx_status, 0, sizeof( UARTStatusRx ) * UART_Num_Interfaces );
    44e2:	2100      	movs	r1, #0

	// Reset Tx
	memset( (void*)uart_tx_buf,    0, sizeof( UARTRingBuf )  * UART_Num_Interfaces );
	memset( (void*)uart_tx_status, 0, sizeof( UARTStatusTx ) * UART_Num_Interfaces );
    44e4:	4c0c      	ldr	r4, [pc, #48]	; (4518 <Connect_reset+0x38>)

// Resets the state of the UART buffers and state variables
void Connect_reset()
{
	// Reset Rx
	memset( (void*)uart_rx_status, 0, sizeof( UARTStatusRx ) * UART_Num_Interfaces );
    44e6:	480d      	ldr	r0, [pc, #52]	; (451c <Connect_reset+0x3c>)
    44e8:	2208      	movs	r2, #8
    44ea:	f7fe f83f 	bl	256c <memset>

	// Reset Tx
	memset( (void*)uart_tx_buf,    0, sizeof( UARTRingBuf )  * UART_Num_Interfaces );
    44ee:	2100      	movs	r1, #0
    44f0:	f44f 7283 	mov.w	r2, #262	; 0x106
    44f4:	480a      	ldr	r0, [pc, #40]	; (4520 <Connect_reset+0x40>)
    44f6:	f7fe f839 	bl	256c <memset>
	memset( (void*)uart_tx_status, 0, sizeof( UARTStatusTx ) * UART_Num_Interfaces );
    44fa:	2100      	movs	r1, #0
    44fc:	2204      	movs	r2, #4
    44fe:	4620      	mov	r0, r4
    4500:	f7fe f834 	bl	256c <memset>

	// Set Rx/Tx buffers as ready
	for ( uint8_t inter = 0; inter < UART_Num_Interfaces; inter++ )
	{
		uart_tx_status[ inter ].status = UARTStatus_Ready;
		uart_rx_buf[ inter ].last_read = UART_Buffer_Size;
    4504:	4b07      	ldr	r3, [pc, #28]	; (4524 <Connect_reset+0x44>)
	memset( (void*)uart_tx_status, 0, sizeof( UARTStatusTx ) * UART_Num_Interfaces );

	// Set Rx/Tx buffers as ready
	for ( uint8_t inter = 0; inter < UART_Num_Interfaces; inter++ )
	{
		uart_tx_status[ inter ].status = UARTStatus_Ready;
    4506:	2104      	movs	r1, #4
		uart_rx_buf[ inter ].last_read = UART_Buffer_Size;
    4508:	2280      	movs	r2, #128	; 0x80
    450a:	f8a3 2080 	strh.w	r2, [r3, #128]	; 0x80
	memset( (void*)uart_tx_status, 0, sizeof( UARTStatusTx ) * UART_Num_Interfaces );

	// Set Rx/Tx buffers as ready
	for ( uint8_t inter = 0; inter < UART_Num_Interfaces; inter++ )
	{
		uart_tx_status[ inter ].status = UARTStatus_Ready;
    450e:	7021      	strb	r1, [r4, #0]
    4510:	70a1      	strb	r1, [r4, #2]
		uart_rx_buf[ inter ].last_read = UART_Buffer_Size;
    4512:	f8a3 2102 	strh.w	r2, [r3, #258]	; 0x102
    4516:	bd10      	pop	{r4, pc}
    4518:	1fffa00e 	.word	0x1fffa00e
    451c:	1fffa02c 	.word	0x1fffa02c
    4520:	1fff9f02 	.word	0x1fff9f02
    4524:	1fffa034 	.word	0x1fffa034

00004528 <cliFunc_connectRst>:
		break;
	}
}

void cliFunc_connectRst( char* args )
{
    4528:	b508      	push	{r3, lr}
	print( NL );
    452a:	4806      	ldr	r0, [pc, #24]	; (4544 <cliFunc_connectRst+0x1c>)
    452c:	f003 f96a 	bl	7804 <_print>
	info_msg("Resetting UARTConnect state...");
    4530:	4805      	ldr	r0, [pc, #20]	; (4548 <cliFunc_connectRst+0x20>)
    4532:	f003 f967 	bl	7804 <_print>
	Connect_reset();
    4536:	f7ff ffd3 	bl	44e0 <Connect_reset>

	// Reset node id
	Connect_id = 0xFF;
    453a:	4b04      	ldr	r3, [pc, #16]	; (454c <cliFunc_connectRst+0x24>)
    453c:	22ff      	movs	r2, #255	; 0xff
    453e:	701a      	strb	r2, [r3, #0]
    4540:	bd08      	pop	{r3, pc}
    4542:	bf00      	nop
    4544:	0000bafb 	.word	0x0000bafb
    4548:	00009150 	.word	0x00009150
    454c:	1fff89c5 	.word	0x1fff89c5

00004550 <Connect_setup>:
// Setup connection to other side
// - Only supports a single slave and master
// - If USB has been initiallized at this point, this side is the master
// - If both sides assert master, flash error leds
void Connect_setup( uint8_t master )
{
    4550:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	// Indication that UARTs are not ready
	uarts_configured = 0;
    4552:	4e4e      	ldr	r6, [pc, #312]	; (468c <Connect_setup+0x13c>)

	// Register Connect CLI dictionary
	CLI_registerDictionary( uartConnectCLIDict, uartConnectCLIDictName );
    4554:	494e      	ldr	r1, [pc, #312]	; (4690 <Connect_setup+0x140>)
// Setup connection to other side
// - Only supports a single slave and master
// - If USB has been initiallized at this point, this side is the master
// - If both sides assert master, flash error leds
void Connect_setup( uint8_t master )
{
    4556:	4605      	mov	r5, r0
	// Indication that UARTs are not ready
	uarts_configured = 0;
    4558:	2400      	movs	r4, #0

	// Register Connect CLI dictionary
	CLI_registerDictionary( uartConnectCLIDict, uartConnectCLIDictName );
    455a:	484e      	ldr	r0, [pc, #312]	; (4694 <Connect_setup+0x144>)
// - If USB has been initiallized at this point, this side is the master
// - If both sides assert master, flash error leds
void Connect_setup( uint8_t master )
{
	// Indication that UARTs are not ready
	uarts_configured = 0;
    455c:	7034      	strb	r4, [r6, #0]

	// Register Connect CLI dictionary
	CLI_registerDictionary( uartConnectCLIDict, uartConnectCLIDictName );
    455e:	f002 ff13 	bl	7388 <CLI_registerDictionary>

	// Check if master
	Connect_master = master;
    4562:	4b4d      	ldr	r3, [pc, #308]	; (4698 <Connect_setup+0x148>)
    4564:	701d      	strb	r5, [r3, #0]
	if ( Connect_master )
    4566:	b10d      	cbz	r5, 456c <Connect_setup+0x1c>
		Connect_id = 0; // 0x00 is always the master Id
    4568:	4b4c      	ldr	r3, [pc, #304]	; (469c <Connect_setup+0x14c>)
    456a:	701c      	strb	r4, [r3, #0]

	// UART0 setup
	// UART1 setup
	// Setup the the UART interface for keyboard data input
	SIM_SCGC4 |= SIM_SCGC4_UART0; // Disable clock gating
    456c:	4b4c      	ldr	r3, [pc, #304]	; (46a0 <Connect_setup+0x150>)
	// Setup DMA clocks
	SIM_SCGC6 |= SIM_SCGC6_DMAMUX;
	SIM_SCGC7 |= SIM_SCGC7_DMA;

	// Start with channels disabled first
	DMAMUX0_CHCFG0 = 0;
    456e:	4c4d      	ldr	r4, [pc, #308]	; (46a4 <Connect_setup+0x154>)
		Connect_id = 0; // 0x00 is always the master Id

	// UART0 setup
	// UART1 setup
	// Setup the the UART interface for keyboard data input
	SIM_SCGC4 |= SIM_SCGC4_UART0; // Disable clock gating
    4570:	681a      	ldr	r2, [r3, #0]
	// Default control register
	DMA_CR = 0;

	// DMA Priority
	DMA_DCHPRI0 = 0; // Ch 0, priority 0
	DMA_DCHPRI1 = 1; // ch 1, priority 1
    4572:	4d4d      	ldr	r5, [pc, #308]	; (46a8 <Connect_setup+0x158>)

	// Clear error interrupts
	DMA_EEI = 0;

	// Setup TCD
	DMA_TCD0_SADDR = (uint32_t*)&UART0_D;
    4574:	4f4d      	ldr	r7, [pc, #308]	; (46ac <Connect_setup+0x15c>)
		Connect_id = 0; // 0x00 is always the master Id

	// UART0 setup
	// UART1 setup
	// Setup the the UART interface for keyboard data input
	SIM_SCGC4 |= SIM_SCGC4_UART0; // Disable clock gating
    4576:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
    457a:	601a      	str	r2, [r3, #0]
	SIM_SCGC4 |= SIM_SCGC4_UART1; // Disable clock gating
    457c:	681a      	ldr	r2, [r3, #0]
    457e:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
    4582:	601a      	str	r2, [r3, #0]

	// Pin Setup for UART0 / UART1
	PORTA_PCR1 = PORT_PCR_PE | PORT_PCR_PS | PORT_PCR_PFE | PORT_PCR_MUX(2); // RX Pin
    4584:	f240 2213 	movw	r2, #531	; 0x213
    4588:	f8c3 2fd0 	str.w	r2, [r3, #4048]	; 0xfd0
	PORTA_PCR2 = PORT_PCR_DSE | PORT_PCR_SRE | PORT_PCR_MUX(2); // TX Pin
    458c:	f44f 7211 	mov.w	r2, #580	; 0x244
    4590:	f8c3 2fd4 	str.w	r2, [r3, #4052]	; 0xfd4
	PORTE_PCR0 = PORT_PCR_PE | PORT_PCR_PS | PORT_PCR_PFE | PORT_PCR_MUX(3); // RX Pin
    4594:	4b46      	ldr	r3, [pc, #280]	; (46b0 <Connect_setup+0x160>)
    4596:	32cf      	adds	r2, #207	; 0xcf
    4598:	601a      	str	r2, [r3, #0]
	PORTE_PCR1 = PORT_PCR_DSE | PORT_PCR_SRE | PORT_PCR_MUX(3); // TX Pin
    459a:	f44f 7251 	mov.w	r2, #836	; 0x344
    459e:	605a      	str	r2, [r3, #4]

	// Baud Rate setting
	UART0_BDH = (uint8_t)(Connect_baud >> 8);
    45a0:	4b44      	ldr	r3, [pc, #272]	; (46b4 <Connect_setup+0x164>)
    45a2:	4a45      	ldr	r2, [pc, #276]	; (46b8 <Connect_setup+0x168>)
    45a4:	8819      	ldrh	r1, [r3, #0]
    45a6:	0a09      	lsrs	r1, r1, #8
    45a8:	7011      	strb	r1, [r2, #0]
	UART0_BDL = (uint8_t)Connect_baud;
    45aa:	7819      	ldrb	r1, [r3, #0]
    45ac:	7051      	strb	r1, [r2, #1]
	UART0_C4  = Connect_baudFine;
    45ae:	4a43      	ldr	r2, [pc, #268]	; (46bc <Connect_setup+0x16c>)
    45b0:	4943      	ldr	r1, [pc, #268]	; (46c0 <Connect_setup+0x170>)
    45b2:	7810      	ldrb	r0, [r2, #0]
    45b4:	7008      	strb	r0, [r1, #0]
	UART1_BDH = (uint8_t)(Connect_baud >> 8);
    45b6:	8818      	ldrh	r0, [r3, #0]
    45b8:	4942      	ldr	r1, [pc, #264]	; (46c4 <Connect_setup+0x174>)
    45ba:	0a00      	lsrs	r0, r0, #8
    45bc:	7008      	strb	r0, [r1, #0]
	UART1_BDL = (uint8_t)Connect_baud;
    45be:	7819      	ldrb	r1, [r3, #0]
    45c0:	4b41      	ldr	r3, [pc, #260]	; (46c8 <Connect_setup+0x178>)
	SIM_SCGC6 |= SIM_SCGC6_DMAMUX;
	SIM_SCGC7 |= SIM_SCGC7_DMA;

	// Start with channels disabled first
	DMAMUX0_CHCFG0 = 0;
	DMAMUX0_CHCFG1 = 0;
    45c2:	4842      	ldr	r0, [pc, #264]	; (46cc <Connect_setup+0x17c>)
	// Baud Rate setting
	UART0_BDH = (uint8_t)(Connect_baud >> 8);
	UART0_BDL = (uint8_t)Connect_baud;
	UART0_C4  = Connect_baudFine;
	UART1_BDH = (uint8_t)(Connect_baud >> 8);
	UART1_BDL = (uint8_t)Connect_baud;
    45c4:	7019      	strb	r1, [r3, #0]
	UART1_C4  = Connect_baudFine;
    45c6:	7812      	ldrb	r2, [r2, #0]
    45c8:	725a      	strb	r2, [r3, #9]

	// 8 bit, Even Parity, Idle Character bit after stop
	// NOTE: For 8 bit with Parity you must enable 9 bit transmission (pg. 1065)
	//       You only need to use UART0_D for 8 bit reading/writing though
	// UART_C1_M UART_C1_PE UART_C1_PT UART_C1_ILT
	UART0_C1 = UART_C1_M | UART_C1_PE | UART_C1_ILT;
    45ca:	4a41      	ldr	r2, [pc, #260]	; (46d0 <Connect_setup+0x180>)
    45cc:	2316      	movs	r3, #22
    45ce:	7013      	strb	r3, [r2, #0]
	UART1_C1 = UART_C1_M | UART_C1_PE | UART_C1_ILT;
    45d0:	f502 5280 	add.w	r2, r2, #4096	; 0x1000

	// Only using Tx Fifos
	UART0_PFIFO = UART_PFIFO_TXFE;
    45d4:	2180      	movs	r1, #128	; 0x80
	// 8 bit, Even Parity, Idle Character bit after stop
	// NOTE: For 8 bit with Parity you must enable 9 bit transmission (pg. 1065)
	//       You only need to use UART0_D for 8 bit reading/writing though
	// UART_C1_M UART_C1_PE UART_C1_PT UART_C1_ILT
	UART0_C1 = UART_C1_M | UART_C1_PE | UART_C1_ILT;
	UART1_C1 = UART_C1_M | UART_C1_PE | UART_C1_ILT;
    45d6:	7013      	strb	r3, [r2, #0]

	// Only using Tx Fifos
	UART0_PFIFO = UART_PFIFO_TXFE;
    45d8:	4b3e      	ldr	r3, [pc, #248]	; (46d4 <Connect_setup+0x184>)
    45da:	7019      	strb	r1, [r3, #0]
	UART1_PFIFO = UART_PFIFO_TXFE;
    45dc:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
    45e0:	7019      	strb	r1, [r3, #0]

	// Setup DMA clocks
	SIM_SCGC6 |= SIM_SCGC6_DMAMUX;
    45e2:	4b3d      	ldr	r3, [pc, #244]	; (46d8 <Connect_setup+0x188>)
    45e4:	681a      	ldr	r2, [r3, #0]
    45e6:	f042 0202 	orr.w	r2, r2, #2
    45ea:	601a      	str	r2, [r3, #0]
	SIM_SCGC7 |= SIM_SCGC7_DMA;
    45ec:	685a      	ldr	r2, [r3, #4]
    45ee:	f042 0202 	orr.w	r2, r2, #2
    45f2:	605a      	str	r2, [r3, #4]
	DMAMUX0_CHCFG0 = 0;
	DMAMUX0_CHCFG1 = 0;

	// Configure DMA channels
	//DMA_DSR_BCR0 |= DMA_DSR_BCR_DONE_MASK; // TODO What's this?
	DMA_TCD0_CSR = 0;
    45f4:	4a39      	ldr	r2, [pc, #228]	; (46dc <Connect_setup+0x18c>)
	// Setup DMA clocks
	SIM_SCGC6 |= SIM_SCGC6_DMAMUX;
	SIM_SCGC7 |= SIM_SCGC7_DMA;

	// Start with channels disabled first
	DMAMUX0_CHCFG0 = 0;
    45f6:	2300      	movs	r3, #0
    45f8:	7023      	strb	r3, [r4, #0]
	DMAMUX0_CHCFG1 = 0;
    45fa:	7003      	strb	r3, [r0, #0]

	// Configure DMA channels
	//DMA_DSR_BCR0 |= DMA_DSR_BCR_DONE_MASK; // TODO What's this?
	DMA_TCD0_CSR = 0;
    45fc:	8013      	strh	r3, [r2, #0]
	DMA_TCD1_CSR = 0;
    45fe:	8413      	strh	r3, [r2, #32]

	// Default control register
	DMA_CR = 0;
    4600:	4a37      	ldr	r2, [pc, #220]	; (46e0 <Connect_setup+0x190>)
    4602:	6013      	str	r3, [r2, #0]

	// DMA Priority
	DMA_DCHPRI0 = 0; // Ch 0, priority 0
    4604:	4a37      	ldr	r2, [pc, #220]	; (46e4 <Connect_setup+0x194>)
    4606:	7013      	strb	r3, [r2, #0]
	DMA_DCHPRI1 = 1; // ch 1, priority 1
    4608:	2201      	movs	r2, #1
    460a:	702a      	strb	r2, [r5, #0]

	// Clear error interrupts
	DMA_EEI = 0;
    460c:	f845 3cee 	str.w	r3, [r5, #-238]

	// Setup TCD
	DMA_TCD0_SADDR = (uint32_t*)&UART0_D;
    4610:	4d35      	ldr	r5, [pc, #212]	; (46e8 <Connect_setup+0x198>)
    4612:	602f      	str	r7, [r5, #0]
	DMA_TCD1_SADDR = (uint32_t*)&UART1_D;
    4614:	f507 5780 	add.w	r7, r7, #4096	; 0x1000
    4618:	622f      	str	r7, [r5, #32]
	DMA_TCD0_SOFF = 0;
    461a:	80ab      	strh	r3, [r5, #4]
	DMA_TCD1_SOFF = 0;
    461c:	84ab      	strh	r3, [r5, #36]	; 0x24

	// No modulo, 8-bit transfer size
	DMA_TCD0_ATTR = DMA_TCD_ATTR_SMOD(0) | DMA_TCD_ATTR_SSIZE(0) | DMA_TCD_ATTR_DMOD(0) | DMA_TCD_ATTR_DSIZE(0);
    461e:	80eb      	strh	r3, [r5, #6]
	DMA_TCD1_ATTR = DMA_TCD_ATTR_SMOD(0) | DMA_TCD_ATTR_SSIZE(0) | DMA_TCD_ATTR_DMOD(0) | DMA_TCD_ATTR_DSIZE(0);
    4620:	84eb      	strh	r3, [r5, #38]	; 0x26

	// One byte transferred at a time
	DMA_TCD0_NBYTES_MLNO = 1;
    4622:	60aa      	str	r2, [r5, #8]
	DMA_TCD1_NBYTES_MLNO = 1;
    4624:	62aa      	str	r2, [r5, #40]	; 0x28

	// Source address does not change
	DMA_TCD0_SLAST = 0;
    4626:	60eb      	str	r3, [r5, #12]
	DMA_TCD1_SLAST = 0;
    4628:	62eb      	str	r3, [r5, #44]	; 0x2c

	// Destination buffer
	DMA_TCD0_DADDR = (uint32_t*)uart_rx_buf[0].buffer;
    462a:	4b30      	ldr	r3, [pc, #192]	; (46ec <Connect_setup+0x19c>)
    462c:	612b      	str	r3, [r5, #16]
	DMA_TCD1_DADDR = (uint32_t*)uart_rx_buf[1].buffer;
    462e:	3382      	adds	r3, #130	; 0x82
    4630:	632b      	str	r3, [r5, #48]	; 0x30

	// Incoming byte, increment by 1 in the rx buffer
	DMA_TCD0_DOFF = 1;
    4632:	4b2f      	ldr	r3, [pc, #188]	; (46f0 <Connect_setup+0x1a0>)
    4634:	801a      	strh	r2, [r3, #0]
	DMA_TCD1_DOFF = 1;
    4636:	841a      	strh	r2, [r3, #32]

	// Single major loop, must be the same value
	DMA_TCD0_CITER_ELINKNO = UART_Buffer_Size;
    4638:	8059      	strh	r1, [r3, #2]
	DMA_TCD1_CITER_ELINKNO = UART_Buffer_Size;
    463a:	8459      	strh	r1, [r3, #34]	; 0x22
	DMA_TCD0_BITER_ELINKNO = UART_Buffer_Size;
    463c:	8159      	strh	r1, [r3, #10]
	DMA_TCD1_BITER_ELINKNO = UART_Buffer_Size;
    463e:	8559      	strh	r1, [r3, #42]	; 0x2a

	// Reset buffer when full
	DMA_TCD0_DLASTSGA = -( UART_Buffer_Size );
    4640:	492c      	ldr	r1, [pc, #176]	; (46f4 <Connect_setup+0x1a4>)
    4642:	f06f 037f 	mvn.w	r3, #127	; 0x7f
    4646:	600b      	str	r3, [r1, #0]
	DMA_TCD1_DLASTSGA = -( UART_Buffer_Size );
    4648:	620b      	str	r3, [r1, #32]

	// Enable DMA channels
	DMA_ERQ |= DMA_ERQ_ERQ0 | DMA_ERQ_ERQ1;
    464a:	4b2b      	ldr	r3, [pc, #172]	; (46f8 <Connect_setup+0x1a8>)
    464c:	6819      	ldr	r1, [r3, #0]
    464e:	f041 0103 	orr.w	r1, r1, #3
    4652:	6019      	str	r1, [r3, #0]

	// Setup DMA channel routing
	DMAMUX0_CHCFG0 = DMAMUX_ENABLE | DMAMUX_SOURCE_UART0_RX;
    4654:	2382      	movs	r3, #130	; 0x82
    4656:	7023      	strb	r3, [r4, #0]
	DMAMUX0_CHCFG1 = DMAMUX_ENABLE | DMAMUX_SOURCE_UART1_RX;

	// Enable DMA requests (requires Rx interrupts)
	UART0_C5 = UART_C5_RDMAS;
    4658:	4928      	ldr	r1, [pc, #160]	; (46fc <Connect_setup+0x1ac>)
	// Enable DMA channels
	DMA_ERQ |= DMA_ERQ_ERQ0 | DMA_ERQ_ERQ1;

	// Setup DMA channel routing
	DMAMUX0_CHCFG0 = DMAMUX_ENABLE | DMAMUX_SOURCE_UART0_RX;
	DMAMUX0_CHCFG1 = DMAMUX_ENABLE | DMAMUX_SOURCE_UART1_RX;
    465a:	2384      	movs	r3, #132	; 0x84
    465c:	7003      	strb	r3, [r0, #0]

	// Enable DMA requests (requires Rx interrupts)
	UART0_C5 = UART_C5_RDMAS;
    465e:	2320      	movs	r3, #32
    4660:	700b      	strb	r3, [r1, #0]
	UART1_C5 = UART_C5_RDMAS;
    4662:	f501 5180 	add.w	r1, r1, #4096	; 0x1000
    4666:	700b      	strb	r3, [r1, #0]

	// TX Enabled, RX Enabled, RX Interrupt Enabled
	UART0_C2 = UART_C2_TE | UART_C2_RE | UART_C2_RIE;
    4668:	4925      	ldr	r1, [pc, #148]	; (4700 <Connect_setup+0x1b0>)
    466a:	232c      	movs	r3, #44	; 0x2c
    466c:	700b      	strb	r3, [r1, #0]
	UART1_C2 = UART_C2_TE | UART_C2_RE | UART_C2_RIE;
    466e:	f501 5180 	add.w	r1, r1, #4096	; 0x1000
    4672:	700b      	strb	r3, [r1, #0]

	// Add interrupts to the vector table
	NVIC_ENABLE_IRQ( IRQ_UART0_STATUS );
    4674:	4b23      	ldr	r3, [pc, #140]	; (4704 <Connect_setup+0x1b4>)
    4676:	f44f 5100 	mov.w	r1, #8192	; 0x2000
    467a:	6019      	str	r1, [r3, #0]
	NVIC_ENABLE_IRQ( IRQ_UART1_STATUS );
    467c:	f44f 4100 	mov.w	r1, #32768	; 0x8000
    4680:	6019      	str	r1, [r3, #0]

	// UARTs are now ready to go
	uarts_configured = 1;
    4682:	7032      	strb	r2, [r6, #0]

	// Reset the state of the UART variables
	Connect_reset();
}
    4684:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}

	// UARTs are now ready to go
	uarts_configured = 1;

	// Reset the state of the UART variables
	Connect_reset();
    4688:	f7ff bf2a 	b.w	44e0 <Connect_reset>
    468c:	1fff92bd 	.word	0x1fff92bd
    4690:	000092cb 	.word	0x000092cb
    4694:	00008c60 	.word	0x00008c60
    4698:	1fff92d6 	.word	0x1fff92d6
    469c:	1fff89c5 	.word	0x1fff89c5
    46a0:	40048034 	.word	0x40048034
    46a4:	40021000 	.word	0x40021000
    46a8:	40008102 	.word	0x40008102
    46ac:	4006a007 	.word	0x4006a007
    46b0:	4004d000 	.word	0x4004d000
    46b4:	1fff89c6 	.word	0x1fff89c6
    46b8:	4006a000 	.word	0x4006a000
    46bc:	1fff92be 	.word	0x1fff92be
    46c0:	4006a00a 	.word	0x4006a00a
    46c4:	4006b000 	.word	0x4006b000
    46c8:	4006b001 	.word	0x4006b001
    46cc:	40021001 	.word	0x40021001
    46d0:	4006a002 	.word	0x4006a002
    46d4:	4006a010 	.word	0x4006a010
    46d8:	4004803c 	.word	0x4004803c
    46dc:	4000901c 	.word	0x4000901c
    46e0:	40008000 	.word	0x40008000
    46e4:	40008103 	.word	0x40008103
    46e8:	40009000 	.word	0x40009000
    46ec:	1fffa034 	.word	0x1fffa034
    46f0:	40009014 	.word	0x40009014
    46f4:	40009018 	.word	0x40009018
    46f8:	4000800c 	.word	0x4000800c
    46fc:	4006a00b 	.word	0x4006a00b
    4700:	4006a003 	.word	0x4006a003
    4704:	e000e104 	.word	0xe000e104

00004708 <Connect_rx_process>:
#define DMA_BUF_POS( x, pos ) \
	case x: \
		pos = DMA_TCD##x##_CITER_ELINKNO; \
		break
void Connect_rx_process( uint8_t uartNum )
{
    4708:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	// Determine current position to read until
	uint16_t bufpos = 0;
	switch ( uartNum )
    470c:	4604      	mov	r4, r0
    470e:	b118      	cbz	r0, 4718 <Connect_rx_process+0x10>
    4710:	2801      	cmp	r0, #1
    4712:	d107      	bne.n	4724 <Connect_rx_process+0x1c>
	{
	DMA_BUF_POS( 0, bufpos );
	DMA_BUF_POS( 1, bufpos );
    4714:	4b57      	ldr	r3, [pc, #348]	; (4874 <Connect_rx_process+0x16c>)
    4716:	e000      	b.n	471a <Connect_rx_process+0x12>
{
	// Determine current position to read until
	uint16_t bufpos = 0;
	switch ( uartNum )
	{
	DMA_BUF_POS( 0, bufpos );
    4718:	4b57      	ldr	r3, [pc, #348]	; (4878 <Connect_rx_process+0x170>)
	DMA_BUF_POS( 1, bufpos );
    471a:	f8b3 8000 	ldrh.w	r8, [r3]
    471e:	fa1f f888 	uxth.w	r8, r8
    4722:	e008      	b.n	4736 <Connect_rx_process+0x2e>
		pos = DMA_TCD##x##_CITER_ELINKNO; \
		break
void Connect_rx_process( uint8_t uartNum )
{
	// Determine current position to read until
	uint16_t bufpos = 0;
    4724:	f04f 0800 	mov.w	r8, #0
    4728:	e005      	b.n	4736 <Connect_rx_process+0x2e>
			break;
		}

		// Unknown status, should never get here
		default:
			erro_msg("Invalid UARTStatus...");
    472a:	4854      	ldr	r0, [pc, #336]	; (487c <Connect_rx_process+0x174>)
    472c:	f003 f86a 	bl	7804 <_print>
			uart_rx_status[ uartNum ].status = UARTStatus_Wait;
    4730:	2300      	movs	r3, #0
    4732:	f805 3024 	strb.w	r3, [r5, r4, lsl #2]
	DMA_BUF_POS( 1, bufpos );
	}

	// Process each of the new bytes
	// Even if we receive more bytes during processing, wait until the next check so we don't starve other tasks
	while ( bufpos != uart_rx_buf[ uartNum ].last_read )
    4736:	4b52      	ldr	r3, [pc, #328]	; (4880 <Connect_rx_process+0x178>)
    4738:	2282      	movs	r2, #130	; 0x82
    473a:	fb02 3204 	mla	r2, r2, r4, r3
    473e:	4618      	mov	r0, r3
    4740:	f8b2 1080 	ldrh.w	r1, [r2, #128]	; 0x80
    4744:	b289      	uxth	r1, r1
    4746:	4588      	cmp	r8, r1
    4748:	f000 8092 	beq.w	4870 <Connect_rx_process+0x168>
	{
		// If the last_read byte is at the buffer edge, roll back to beginning
		if ( uart_rx_buf[ uartNum ].last_read == 0 )
    474c:	f8b2 1080 	ldrh.w	r1, [r2, #128]	; 0x80
    4750:	b289      	uxth	r1, r1
    4752:	b1c9      	cbz	r1, 4788 <Connect_rx_process+0x80>
			if ( bufpos == UART_Buffer_Size )
				break;
		}

		// Read the byte out of Rx DMA buffer
		uint8_t byte = uart_rx_buf[ uartNum ].buffer[ UART_Buffer_Size - uart_rx_buf[ uartNum ].last_read-- ];
    4754:	2282      	movs	r2, #130	; 0x82
    4756:	4362      	muls	r2, r4
    4758:	4410      	add	r0, r2

		if ( Connect_debug )
    475a:	4e4a      	ldr	r6, [pc, #296]	; (4884 <Connect_rx_process+0x17c>)
			if ( bufpos == UART_Buffer_Size )
				break;
		}

		// Read the byte out of Rx DMA buffer
		uint8_t byte = uart_rx_buf[ uartNum ].buffer[ UART_Buffer_Size - uart_rx_buf[ uartNum ].last_read-- ];
    475c:	f8b0 1080 	ldrh.w	r1, [r0, #128]	; 0x80
    4760:	b289      	uxth	r1, r1
    4762:	1e4d      	subs	r5, r1, #1
    4764:	f1c1 0180 	rsb	r1, r1, #128	; 0x80
    4768:	b2ad      	uxth	r5, r5
    476a:	440a      	add	r2, r1
    476c:	f8a0 5080 	strh.w	r5, [r0, #128]	; 0x80
    4770:	5c9f      	ldrb	r7, [r3, r2]

		if ( Connect_debug )
    4772:	7833      	ldrb	r3, [r6, #0]
			if ( bufpos == UART_Buffer_Size )
				break;
		}

		// Read the byte out of Rx DMA buffer
		uint8_t byte = uart_rx_buf[ uartNum ].buffer[ UART_Buffer_Size - uart_rx_buf[ uartNum ].last_read-- ];
    4774:	b2ff      	uxtb	r7, r7

		if ( Connect_debug )
    4776:	b173      	cbz	r3, 4796 <Connect_rx_process+0x8e>
		{
			printHex( byte );
    4778:	4638      	mov	r0, r7
    477a:	2101      	movs	r1, #1
    477c:	f003 f8cb 	bl	7916 <printHex_op>
			print(" ");
    4780:	4841      	ldr	r0, [pc, #260]	; (4888 <Connect_rx_process+0x180>)
    4782:	f003 f83f 	bl	7804 <_print>
    4786:	e006      	b.n	4796 <Connect_rx_process+0x8e>
	while ( bufpos != uart_rx_buf[ uartNum ].last_read )
	{
		// If the last_read byte is at the buffer edge, roll back to beginning
		if ( uart_rx_buf[ uartNum ].last_read == 0 )
		{
			uart_rx_buf[ uartNum ].last_read = UART_Buffer_Size;
    4788:	2180      	movs	r1, #128	; 0x80

			// Check to see if we're at the boundary
			if ( bufpos == UART_Buffer_Size )
    478a:	4588      	cmp	r8, r1
	while ( bufpos != uart_rx_buf[ uartNum ].last_read )
	{
		// If the last_read byte is at the buffer edge, roll back to beginning
		if ( uart_rx_buf[ uartNum ].last_read == 0 )
		{
			uart_rx_buf[ uartNum ].last_read = UART_Buffer_Size;
    478c:	f8a2 1080 	strh.w	r1, [r2, #128]	; 0x80

			// Check to see if we're at the boundary
			if ( bufpos == UART_Buffer_Size )
    4790:	d1e0      	bne.n	4754 <Connect_rx_process+0x4c>
    4792:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			printHex( byte );
			print(" ");
		}

		// Process UART byte
		switch ( uart_rx_status[ uartNum ].status )
    4796:	4d3d      	ldr	r5, [pc, #244]	; (488c <Connect_rx_process+0x184>)
    4798:	f815 3024 	ldrb.w	r3, [r5, r4, lsl #2]
    479c:	46a9      	mov	r9, r5
    479e:	2b03      	cmp	r3, #3
    47a0:	d8c3      	bhi.n	472a <Connect_rx_process+0x22>
    47a2:	e8df f003 	tbb	[pc, r3]
    47a6:	0c02      	.short	0x0c02
    47a8:	4918      	.short	0x4918
		{
		// Every packet must start with a SYN / 0x16
		case UARTStatus_Wait:
			if ( Connect_debug )
    47aa:	7833      	ldrb	r3, [r6, #0]
    47ac:	b113      	cbz	r3, 47b4 <Connect_rx_process+0xac>
			{
				print(" Wait ");
    47ae:	4838      	ldr	r0, [pc, #224]	; (4890 <Connect_rx_process+0x188>)
    47b0:	f003 f828 	bl	7804 <_print>
			}
			uart_rx_status[ uartNum ].status = byte == 0x16 ? UARTStatus_SYN : UARTStatus_Wait;
    47b4:	f1b7 0316 	subs.w	r3, r7, #22
    47b8:	425f      	negs	r7, r3
    47ba:	415f      	adcs	r7, r3
    47bc:	e008      	b.n	47d0 <Connect_rx_process+0xc8>
			break;

		// After a SYN, there must be a SOH / 0x01
		case UARTStatus_SYN:
			if ( Connect_debug )
    47be:	7833      	ldrb	r3, [r6, #0]
    47c0:	b113      	cbz	r3, 47c8 <Connect_rx_process+0xc0>
			{
				print(" SYN ");
    47c2:	4834      	ldr	r0, [pc, #208]	; (4894 <Connect_rx_process+0x18c>)
    47c4:	f003 f81e 	bl	7804 <_print>
			}
			uart_rx_status[ uartNum ].status = byte == 0x01 ? UARTStatus_SOH : UARTStatus_Wait;
    47c8:	2f01      	cmp	r7, #1
    47ca:	bf0c      	ite	eq
    47cc:	2702      	moveq	r7, #2
    47ce:	2700      	movne	r7, #0
    47d0:	f805 7024 	strb.w	r7, [r5, r4, lsl #2]
			break;
    47d4:	e044      	b.n	4860 <Connect_rx_process+0x158>
		// After a SOH the packet structure may diverge a bit
		// This is the packet type field (refer to the Command enum)
		// For very small packets (e.g. IdRequest) this is all that's required to take action
		case UARTStatus_SOH:
		{
			if ( Connect_debug )
    47d6:	7833      	ldrb	r3, [r6, #0]
    47d8:	b113      	cbz	r3, 47e0 <Connect_rx_process+0xd8>
			{
				print(" SOH ");
    47da:	482f      	ldr	r0, [pc, #188]	; (4898 <Connect_rx_process+0x190>)
    47dc:	f003 f812 	bl	7804 <_print>
			}

			// Check if this is actually a reserved CMD 0x16 (Error condition)
			if ( byte == Command_SYN )
    47e0:	2f16      	cmp	r7, #22
    47e2:	d103      	bne.n	47ec <Connect_rx_process+0xe4>
			{
				uart_rx_status[ uartNum ].status = UARTStatus_SYN;
    47e4:	2301      	movs	r3, #1
    47e6:	f805 3024 	strb.w	r3, [r5, r4, lsl #2]
				break;
    47ea:	e039      	b.n	4860 <Connect_rx_process+0x158>
			}

			// Otherwise process the command
			if ( byte < Command_TOP )
    47ec:	2f08      	cmp	r7, #8
    47ee:	ea4f 0384 	mov.w	r3, r4, lsl #2
    47f2:	d809      	bhi.n	4808 <Connect_rx_process+0x100>
			{
				uart_rx_status[ uartNum ].status = UARTStatus_Command;
    47f4:	2203      	movs	r2, #3
    47f6:	f805 2024 	strb.w	r2, [r5, r4, lsl #2]
				uart_rx_status[ uartNum ].command = byte;
    47fa:	eb09 0203 	add.w	r2, r9, r3
				uart_rx_status[ uartNum ].bytes_waiting = 0xFFFF;
    47fe:	f64f 71ff 	movw	r1, #65535	; 0xffff

			// Otherwise process the command
			if ( byte < Command_TOP )
			{
				uart_rx_status[ uartNum ].status = UARTStatus_Command;
				uart_rx_status[ uartNum ].command = byte;
    4802:	7057      	strb	r7, [r2, #1]
				uart_rx_status[ uartNum ].bytes_waiting = 0xFFFF;
    4804:	8051      	strh	r1, [r2, #2]
    4806:	e002      	b.n	480e <Connect_rx_process+0x106>
			}
			// Invalid packet type, ignore
			else
			{
				uart_rx_status[ uartNum ].status = UARTStatus_Wait;
    4808:	2200      	movs	r2, #0
    480a:	f805 2024 	strb.w	r2, [r5, r4, lsl #2]
			}

			// Check if this is a very short packet
			switch ( uart_rx_status[ uartNum ].command )
    480e:	eb09 0503 	add.w	r5, r9, r3
    4812:	786b      	ldrb	r3, [r5, #1]
    4814:	2b01      	cmp	r3, #1
    4816:	d105      	bne.n	4824 <Connect_rx_process+0x11c>
			{
			case IdRequest:
				Connect_receive_IdRequest( 0, (uint16_t*)&uart_rx_status[ uartNum ].bytes_waiting, uartNum );
    4818:	1ca9      	adds	r1, r5, #2
    481a:	4622      	mov	r2, r4
    481c:	2000      	movs	r0, #0
    481e:	f7ff fcbf 	bl	41a0 <Connect_receive_IdRequest>
    4822:	e019      	b.n	4858 <Connect_rx_process+0x150>
				uart_rx_status[ uartNum ].status = UARTStatus_Wait;
				break;

			default:
				if ( Connect_debug )
    4824:	7833      	ldrb	r3, [r6, #0]
    4826:	b1db      	cbz	r3, 4860 <Connect_rx_process+0x158>
				{
					print(" ### ");
    4828:	481c      	ldr	r0, [pc, #112]	; (489c <Connect_rx_process+0x194>)
    482a:	f002 ffeb 	bl	7804 <_print>
					printHex( uart_rx_status[ uartNum ].command );
    482e:	7868      	ldrb	r0, [r5, #1]
    4830:	2101      	movs	r1, #1
    4832:	f003 f870 	bl	7916 <printHex_op>
    4836:	e013      	b.n	4860 <Connect_rx_process+0x158>

		// After the packet type has been deciphered do Command specific processing
		// Until the Command has received all the bytes it requires the UART buffer stays in this state
		case UARTStatus_Command:
		{
			if ( Connect_debug )
    4838:	7833      	ldrb	r3, [r6, #0]
    483a:	b113      	cbz	r3, 4842 <Connect_rx_process+0x13a>
			{
				print(" CMD ");
    483c:	4818      	ldr	r0, [pc, #96]	; (48a0 <Connect_rx_process+0x198>)
    483e:	f002 ffe1 	bl	7804 <_print>
			}
			/* Call specific UARTConnect command receive function */
			uint8_t (*rcvFunc)(uint8_t, uint16_t(*), uint8_t) = (uint8_t(*)(uint8_t, uint16_t(*), uint8_t))(Connect_receiveFunctions[ uart_rx_status[ uartNum ].command ]);
    4842:	eb09 0184 	add.w	r1, r9, r4, lsl #2
			if ( rcvFunc( byte, (uint16_t*)&uart_rx_status[ uartNum ].bytes_waiting, uartNum ) )
    4846:	4b17      	ldr	r3, [pc, #92]	; (48a4 <Connect_rx_process+0x19c>)
			if ( Connect_debug )
			{
				print(" CMD ");
			}
			/* Call specific UARTConnect command receive function */
			uint8_t (*rcvFunc)(uint8_t, uint16_t(*), uint8_t) = (uint8_t(*)(uint8_t, uint16_t(*), uint8_t))(Connect_receiveFunctions[ uart_rx_status[ uartNum ].command ]);
    4848:	784a      	ldrb	r2, [r1, #1]
			if ( rcvFunc( byte, (uint16_t*)&uart_rx_status[ uartNum ].bytes_waiting, uartNum ) )
    484a:	4638      	mov	r0, r7
    484c:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    4850:	3102      	adds	r1, #2
    4852:	4622      	mov	r2, r4
    4854:	4798      	blx	r3
    4856:	b118      	cbz	r0, 4860 <Connect_rx_process+0x158>
				uart_rx_status[ uartNum ].status = UARTStatus_Wait;
    4858:	4b0c      	ldr	r3, [pc, #48]	; (488c <Connect_rx_process+0x184>)
    485a:	2200      	movs	r2, #0
    485c:	f803 2024 	strb.w	r2, [r3, r4, lsl #2]
			erro_msg("Invalid UARTStatus...");
			uart_rx_status[ uartNum ].status = UARTStatus_Wait;
			continue;
		}

		if ( Connect_debug )
    4860:	7833      	ldrb	r3, [r6, #0]
    4862:	2b00      	cmp	r3, #0
    4864:	f43f af67 	beq.w	4736 <Connect_rx_process+0x2e>
		{
			print( NL );
    4868:	480f      	ldr	r0, [pc, #60]	; (48a8 <Connect_rx_process+0x1a0>)
    486a:	f002 ffcb 	bl	7804 <_print>
    486e:	e762      	b.n	4736 <Connect_rx_process+0x2e>
    4870:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    4874:	40009036 	.word	0x40009036
    4878:	40009016 	.word	0x40009016
    487c:	000091a0 	.word	0x000091a0
    4880:	1fffa034 	.word	0x1fffa034
    4884:	1fff92cd 	.word	0x1fff92cd
    4888:	00008156 	.word	0x00008156
    488c:	1fffa02c 	.word	0x1fffa02c
    4890:	00009181 	.word	0x00009181
    4894:	00009188 	.word	0x00009188
    4898:	0000918e 	.word	0x0000918e
    489c:	00009194 	.word	0x00009194
    48a0:	0000919a 	.word	0x0000919a
    48a4:	1fff89c8 	.word	0x1fff89c8
    48a8:	0000bafb 	.word	0x0000bafb

000048ac <Connect_scan>:
// - Interrupts will deal with most input functions
// - Used to send queries
// - SyncEvent is sent immediately once the current command is sent
// - SyncEvent is also blocking until sent
void Connect_scan()
{
    48ac:	b570      	push	{r4, r5, r6, lr}
	// Check if initially configured as a slave and usb comes up
	// Then reconfigure as a master
	if ( !Connect_master && Output_Available && !Connect_override )
    48ae:	4b63      	ldr	r3, [pc, #396]	; (4a3c <Connect_scan+0x190>)
    48b0:	781a      	ldrb	r2, [r3, #0]
    48b2:	461c      	mov	r4, r3
    48b4:	b942      	cbnz	r2, 48c8 <Connect_scan+0x1c>
    48b6:	4b62      	ldr	r3, [pc, #392]	; (4a40 <Connect_scan+0x194>)
    48b8:	781a      	ldrb	r2, [r3, #0]
    48ba:	b12a      	cbz	r2, 48c8 <Connect_scan+0x1c>
    48bc:	4a61      	ldr	r2, [pc, #388]	; (4a44 <Connect_scan+0x198>)
    48be:	7812      	ldrb	r2, [r2, #0]
    48c0:	b912      	cbnz	r2, 48c8 <Connect_scan+0x1c>
	{
		Connect_setup( Output_Available );
    48c2:	7818      	ldrb	r0, [r3, #0]
    48c4:	f7ff fe44 	bl	4550 <Connect_setup>
	}

	// Limit how often we do cable checks
	uint32_t time_compare = 0x7FF; // Must be all 1's, 0x3FF is valid, 0x4FF is not
	uint32_t current_time = systick_millis_count;
    48c8:	4b5f      	ldr	r3, [pc, #380]	; (4a48 <Connect_scan+0x19c>)
	if ( Connect_lastCheck != current_time
    48ca:	4a60      	ldr	r2, [pc, #384]	; (4a4c <Connect_scan+0x1a0>)
		Connect_setup( Output_Available );
	}

	// Limit how often we do cable checks
	uint32_t time_compare = 0x7FF; // Must be all 1's, 0x3FF is valid, 0x4FF is not
	uint32_t current_time = systick_millis_count;
    48cc:	681b      	ldr	r3, [r3, #0]
	if ( Connect_lastCheck != current_time
    48ce:	6811      	ldr	r1, [r2, #0]
    48d0:	4299      	cmp	r1, r3
    48d2:	d014      	beq.n	48fe <Connect_scan+0x52>
		&& ( current_time & time_compare ) == time_compare
    48d4:	f3c3 000a 	ubfx	r0, r3, #0, #11
    48d8:	f240 71ff 	movw	r1, #2047	; 0x7ff
    48dc:	4288      	cmp	r0, r1
    48de:	d10e      	bne.n	48fe <Connect_scan+0x52>
	{
		// Make sure we don't double check if the clock speed is too high
		Connect_lastCheck = current_time;

		// Send a cable check command of 2 bytes
		Connect_send_CableCheck( UARTConnectCableCheckLength_define );
    48e0:	2002      	movs	r0, #2
	if ( Connect_lastCheck != current_time
		&& ( current_time & time_compare ) == time_compare
	)
	{
		// Make sure we don't double check if the clock speed is too high
		Connect_lastCheck = current_time;
    48e2:	6013      	str	r3, [r2, #0]

		// Send a cable check command of 2 bytes
		Connect_send_CableCheck( UARTConnectCableCheckLength_define );
    48e4:	f7ff fbd4 	bl	4090 <Connect_send_CableCheck>

		// If this is a slave, and we don't have an id yeth
		// Don't bother sending if there are cable issues
		if ( !Connect_master && Connect_id == 0xFF && Connect_cableOkMaster )
    48e8:	7823      	ldrb	r3, [r4, #0]
    48ea:	b943      	cbnz	r3, 48fe <Connect_scan+0x52>
    48ec:	4b58      	ldr	r3, [pc, #352]	; (4a50 <Connect_scan+0x1a4>)
    48ee:	781b      	ldrb	r3, [r3, #0]
    48f0:	2bff      	cmp	r3, #255	; 0xff
    48f2:	d104      	bne.n	48fe <Connect_scan+0x52>
    48f4:	4b57      	ldr	r3, [pc, #348]	; (4a54 <Connect_scan+0x1a8>)
    48f6:	781b      	ldrb	r3, [r3, #0]
    48f8:	b10b      	cbz	r3, 48fe <Connect_scan+0x52>
		{
			Connect_send_IdRequest();
    48fa:	f7ff fc0f 	bl	411c <Connect_send_IdRequest>
		}
	}

	// Only process commands if uarts have been configured
	if ( uarts_configured )
    48fe:	4b56      	ldr	r3, [pc, #344]	; (4a58 <Connect_scan+0x1ac>)
    4900:	781b      	ldrb	r3, [r3, #0]
    4902:	2b00      	cmp	r3, #0
    4904:	f000 8099 	beq.w	4a3a <Connect_scan+0x18e>
	{
		// Check if Tx Buffers are empty and the Tx Ring buffers have data to send
		// This happens if there was previously nothing to send
		if ( uart_tx_buf[ 0 ].items > 0 && UART0_TCFIFO == 0 )
    4908:	4c54      	ldr	r4, [pc, #336]	; (4a5c <Connect_scan+0x1b0>)
    490a:	78a3      	ldrb	r3, [r4, #2]
    490c:	b923      	cbnz	r3, 4918 <Connect_scan+0x6c>
			uart_fillTxFifo( 0 );
		if ( uart_tx_buf[ 1 ].items > 0 && UART1_TCFIFO == 0 )
    490e:	f894 3085 	ldrb.w	r3, [r4, #133]	; 0x85
    4912:	2b00      	cmp	r3, #0
    4914:	d141      	bne.n	499a <Connect_scan+0xee>
    4916:	e043      	b.n	49a0 <Connect_scan+0xf4>
	// Only process commands if uarts have been configured
	if ( uarts_configured )
	{
		// Check if Tx Buffers are empty and the Tx Ring buffers have data to send
		// This happens if there was previously nothing to send
		if ( uart_tx_buf[ 0 ].items > 0 && UART0_TCFIFO == 0 )
    4918:	4e51      	ldr	r6, [pc, #324]	; (4a60 <Connect_scan+0x1b4>)
    491a:	7833      	ldrb	r3, [r6, #0]
    491c:	2b00      	cmp	r3, #0
    491e:	d1f6      	bne.n	490e <Connect_scan+0x62>
			uart_fillTxFifo( 0 );
    4920:	4b50      	ldr	r3, [pc, #320]	; (4a64 <Connect_scan+0x1b8>)
    4922:	781d      	ldrb	r5, [r3, #0]
    4924:	4b50      	ldr	r3, [pc, #320]	; (4a68 <Connect_scan+0x1bc>)
    4926:	f005 0570 	and.w	r5, r5, #112	; 0x70
    492a:	781b      	ldrb	r3, [r3, #0]
    492c:	08ad      	lsrs	r5, r5, #2
    492e:	bf08      	it	eq
    4930:	2501      	moveq	r5, #1
    4932:	b1bb      	cbz	r3, 4964 <Connect_scan+0xb8>
    4934:	484d      	ldr	r0, [pc, #308]	; (4a6c <Connect_scan+0x1c0>)
    4936:	f002 ff65 	bl	7804 <_print>
    493a:	2101      	movs	r1, #1
    493c:	4628      	mov	r0, r5
    493e:	f002 ffea 	bl	7916 <printHex_op>
    4942:	484b      	ldr	r0, [pc, #300]	; (4a70 <Connect_scan+0x1c4>)
    4944:	f002 ff5e 	bl	7804 <_print>
    4948:	2101      	movs	r1, #1
    494a:	7830      	ldrb	r0, [r6, #0]
    494c:	f002 ffe3 	bl	7916 <printHex_op>
    4950:	4847      	ldr	r0, [pc, #284]	; (4a70 <Connect_scan+0x1c4>)
    4952:	f002 ff57 	bl	7804 <_print>
    4956:	78a0      	ldrb	r0, [r4, #2]
    4958:	2101      	movs	r1, #1
    495a:	f002 ffdc 	bl	7916 <printHex_op>
    495e:	4845      	ldr	r0, [pc, #276]	; (4a74 <Connect_scan+0x1c8>)
    4960:	f002 ff50 	bl	7804 <_print>
    4964:	4b3e      	ldr	r3, [pc, #248]	; (4a60 <Connect_scan+0x1b4>)
    4966:	781b      	ldrb	r3, [r3, #0]
    4968:	1aed      	subs	r5, r5, r3
    496a:	b2ed      	uxtb	r5, r5
    496c:	2d00      	cmp	r5, #0
    496e:	d0ce      	beq.n	490e <Connect_scan+0x62>
    4970:	78a2      	ldrb	r2, [r4, #2]
    4972:	4b3a      	ldr	r3, [pc, #232]	; (4a5c <Connect_scan+0x1b0>)
    4974:	2a00      	cmp	r2, #0
    4976:	d0ca      	beq.n	490e <Connect_scan+0x62>
    4978:	7819      	ldrb	r1, [r3, #0]
    497a:	1c48      	adds	r0, r1, #1
    497c:	4419      	add	r1, r3
    497e:	7018      	strb	r0, [r3, #0]
    4980:	78c8      	ldrb	r0, [r1, #3]
    4982:	493d      	ldr	r1, [pc, #244]	; (4a78 <Connect_scan+0x1cc>)
    4984:	3a01      	subs	r2, #1
    4986:	7008      	strb	r0, [r1, #0]
    4988:	709a      	strb	r2, [r3, #2]
    498a:	f993 2000 	ldrsb.w	r2, [r3]
    498e:	2a00      	cmp	r2, #0
    4990:	bfbc      	itt	lt
    4992:	2200      	movlt	r2, #0
    4994:	701a      	strblt	r2, [r3, #0]
    4996:	3d01      	subs	r5, #1
    4998:	e7e7      	b.n	496a <Connect_scan+0xbe>
		if ( uart_tx_buf[ 1 ].items > 0 && UART1_TCFIFO == 0 )
    499a:	4e38      	ldr	r6, [pc, #224]	; (4a7c <Connect_scan+0x1d0>)
    499c:	7833      	ldrb	r3, [r6, #0]
    499e:	b13b      	cbz	r3, 49b0 <Connect_scan+0x104>
			uart_fillTxFifo( 1 );

		// Process Rx Buffers
		Connect_rx_process( 0 );
    49a0:	2000      	movs	r0, #0
    49a2:	f7ff feb1 	bl	4708 <Connect_rx_process>
		Connect_rx_process( 1 );
    49a6:	2001      	movs	r0, #1
	}
}
    49a8:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		if ( uart_tx_buf[ 1 ].items > 0 && UART1_TCFIFO == 0 )
			uart_fillTxFifo( 1 );

		// Process Rx Buffers
		Connect_rx_process( 0 );
		Connect_rx_process( 1 );
    49ac:	f7ff beac 	b.w	4708 <Connect_rx_process>
		// Check if Tx Buffers are empty and the Tx Ring buffers have data to send
		// This happens if there was previously nothing to send
		if ( uart_tx_buf[ 0 ].items > 0 && UART0_TCFIFO == 0 )
			uart_fillTxFifo( 0 );
		if ( uart_tx_buf[ 1 ].items > 0 && UART1_TCFIFO == 0 )
			uart_fillTxFifo( 1 );
    49b0:	4b33      	ldr	r3, [pc, #204]	; (4a80 <Connect_scan+0x1d4>)
    49b2:	781d      	ldrb	r5, [r3, #0]
    49b4:	4b2c      	ldr	r3, [pc, #176]	; (4a68 <Connect_scan+0x1bc>)
    49b6:	f005 0570 	and.w	r5, r5, #112	; 0x70
    49ba:	781b      	ldrb	r3, [r3, #0]
    49bc:	08ad      	lsrs	r5, r5, #2
    49be:	bf08      	it	eq
    49c0:	2501      	moveq	r5, #1
    49c2:	b1c3      	cbz	r3, 49f6 <Connect_scan+0x14a>
    49c4:	482f      	ldr	r0, [pc, #188]	; (4a84 <Connect_scan+0x1d8>)
    49c6:	f002 ff1d 	bl	7804 <_print>
    49ca:	2101      	movs	r1, #1
    49cc:	4628      	mov	r0, r5
    49ce:	f002 ffa2 	bl	7916 <printHex_op>
    49d2:	4827      	ldr	r0, [pc, #156]	; (4a70 <Connect_scan+0x1c4>)
    49d4:	f002 ff16 	bl	7804 <_print>
    49d8:	2101      	movs	r1, #1
    49da:	7830      	ldrb	r0, [r6, #0]
    49dc:	f002 ff9b 	bl	7916 <printHex_op>
    49e0:	4823      	ldr	r0, [pc, #140]	; (4a70 <Connect_scan+0x1c4>)
    49e2:	f002 ff0f 	bl	7804 <_print>
    49e6:	f894 0085 	ldrb.w	r0, [r4, #133]	; 0x85
    49ea:	2101      	movs	r1, #1
    49ec:	f002 ff93 	bl	7916 <printHex_op>
    49f0:	4820      	ldr	r0, [pc, #128]	; (4a74 <Connect_scan+0x1c8>)
    49f2:	f002 ff07 	bl	7804 <_print>
    49f6:	4b21      	ldr	r3, [pc, #132]	; (4a7c <Connect_scan+0x1d0>)
    49f8:	781b      	ldrb	r3, [r3, #0]
    49fa:	1aed      	subs	r5, r5, r3
    49fc:	b2ed      	uxtb	r5, r5
    49fe:	2d00      	cmp	r5, #0
    4a00:	d0ce      	beq.n	49a0 <Connect_scan+0xf4>
    4a02:	f894 1085 	ldrb.w	r1, [r4, #133]	; 0x85
    4a06:	4b15      	ldr	r3, [pc, #84]	; (4a5c <Connect_scan+0x1b0>)
    4a08:	2900      	cmp	r1, #0
    4a0a:	d0c9      	beq.n	49a0 <Connect_scan+0xf4>
    4a0c:	f893 0083 	ldrb.w	r0, [r3, #131]	; 0x83
    4a10:	1c42      	adds	r2, r0, #1
    4a12:	4418      	add	r0, r3
    4a14:	f883 2083 	strb.w	r2, [r3, #131]	; 0x83
    4a18:	f890 6086 	ldrb.w	r6, [r0, #134]	; 0x86
    4a1c:	481a      	ldr	r0, [pc, #104]	; (4a88 <Connect_scan+0x1dc>)
    4a1e:	0612      	lsls	r2, r2, #24
    4a20:	f101 31ff 	add.w	r1, r1, #4294967295	; 0xffffffff
    4a24:	bf48      	it	mi
    4a26:	2200      	movmi	r2, #0
    4a28:	7006      	strb	r6, [r0, #0]
    4a2a:	f105 35ff 	add.w	r5, r5, #4294967295	; 0xffffffff
    4a2e:	f883 1085 	strb.w	r1, [r3, #133]	; 0x85
    4a32:	bf48      	it	mi
    4a34:	f883 2083 	strbmi.w	r2, [r3, #131]	; 0x83
    4a38:	e7e0      	b.n	49fc <Connect_scan+0x150>
    4a3a:	bd70      	pop	{r4, r5, r6, pc}
    4a3c:	1fff92d6 	.word	0x1fff92d6
    4a40:	1fff94f5 	.word	0x1fff94f5
    4a44:	1fff92d5 	.word	0x1fff92d5
    4a48:	1fff92a4 	.word	0x1fff92a4
    4a4c:	1fff92b8 	.word	0x1fff92b8
    4a50:	1fff89c5 	.word	0x1fff89c5
    4a54:	1fff92bc 	.word	0x1fff92bc
    4a58:	1fff92bd 	.word	0x1fff92bd
    4a5c:	1fff9f02 	.word	0x1fff9f02
    4a60:	4006a014 	.word	0x4006a014
    4a64:	4006a010 	.word	0x4006a010
    4a68:	1fff92cd 	.word	0x1fff92cd
    4a6c:	000091cb 	.word	0x000091cb
    4a70:	00008e6c 	.word	0x00008e6c
    4a74:	0000bafb 	.word	0x0000bafb
    4a78:	4006a007 	.word	0x4006a007
    4a7c:	4006b014 	.word	0x4006b014
    4a80:	4006b010 	.word	0x4006b010
    4a84:	000091d7 	.word	0x000091d7
    4a88:	4006b007 	.word	0x4006b007

00004a8c <Scan_setup>:

// ----- Functions -----

// Setup
inline void Scan_setup()
{
    4a8c:	b508      	push	{r3, lr}
	// Setup UART Connect, if Output_Available, this is the master node
	Connect_setup( Output_Available );
    4a8e:	4b07      	ldr	r3, [pc, #28]	; (4aac <Scan_setup+0x20>)
    4a90:	7818      	ldrb	r0, [r3, #0]
    4a92:	f7ff fd5d 	bl	4550 <Connect_setup>

	// Setup GPIO pins for matrix scanning
	Matrix_setup();
    4a96:	f7fe faf7 	bl	3088 <Matrix_setup>

	// Setup ISSI chip to control the leds
	LED_setup();
    4a9a:	f7fd ffd7 	bl	2a4c <LED_setup>

	// Setup the ST/NHD lcd display
	LCD_setup();
    4a9e:	f7fe fe1b 	bl	36d8 <LCD_setup>

	// Reset scan count
	Scan_scanCount = 0;
    4aa2:	4b03      	ldr	r3, [pc, #12]	; (4ab0 <Scan_setup+0x24>)
    4aa4:	2200      	movs	r2, #0
    4aa6:	801a      	strh	r2, [r3, #0]
    4aa8:	bd08      	pop	{r3, pc}
    4aaa:	bf00      	nop
    4aac:	1fff94f5 	.word	0x1fff94f5
    4ab0:	1fff92d8 	.word	0x1fff92d8

00004ab4 <Scan_loop>:
}


// Main Detection Loop
inline uint8_t Scan_loop()
{
    4ab4:	b508      	push	{r3, lr}
	// Scan Matrix
	Matrix_scan( Scan_scanCount++ );
    4ab6:	4b07      	ldr	r3, [pc, #28]	; (4ad4 <Scan_loop+0x20>)
    4ab8:	8818      	ldrh	r0, [r3, #0]
    4aba:	1c42      	adds	r2, r0, #1
    4abc:	801a      	strh	r2, [r3, #0]
    4abe:	f7fe fb71 	bl	31a4 <Matrix_scan>

	// Process any interconnect commands
	Connect_scan();
    4ac2:	f7ff fef3 	bl	48ac <Connect_scan>

	// Process any LED events
	LED_scan();
    4ac6:	f7fe f970 	bl	2daa <LED_scan>

	// Process any LCD events
	LCD_scan();
    4aca:	f7fe fe8d 	bl	37e8 <LCD_scan>

	return 0;
}
    4ace:	2000      	movs	r0, #0
    4ad0:	bd08      	pop	{r3, pc}
    4ad2:	bf00      	nop
    4ad4:	1fff92d8 	.word	0x1fff92d8

00004ad8 <Scan_finishedWithMacro>:


// Signal from Macro Module that all keys have been processed (that it knows about)
inline void Scan_finishedWithMacro( uint8_t sentKeys )
{
    4ad8:	4770      	bx	lr
    4ada:	0000      	movs	r0, r0

00004adc <Scan_finishedWithOutput>:
// Signal from Output Module that all keys have been processed (that it knows about)
inline void Scan_finishedWithOutput( uint8_t sentKeys )
{
	// Reset scan loop indicator (resets each key debounce state)
	// TODO should this occur after USB send or Macro processing?
	Scan_scanCount = 0;
    4adc:	4b01      	ldr	r3, [pc, #4]	; (4ae4 <Scan_finishedWithOutput+0x8>)
    4ade:	2200      	movs	r2, #0
    4ae0:	801a      	strh	r2, [r3, #0]
    4ae2:	4770      	bx	lr
    4ae4:	1fff92d8 	.word	0x1fff92d8

00004ae8 <cliFunc_capList>:


// ----- CLI Command Functions -----

void cliFunc_capList( char* args )
{
    4ae8:	b510      	push	{r4, lr}
	print( NL );
    4aea:	4810      	ldr	r0, [pc, #64]	; (4b2c <cliFunc_capList+0x44>)
    4aec:	f002 fe8a 	bl	7804 <_print>
	info_msg("Capabilities List ");
    4af0:	480f      	ldr	r0, [pc, #60]	; (4b30 <cliFunc_capList+0x48>)
    4af2:	f002 fe87 	bl	7804 <_print>
	printHex( CapabilitiesNum );
    4af6:	200f      	movs	r0, #15
    4af8:	2101      	movs	r1, #1
    4afa:	f002 ff0c 	bl	7916 <printHex_op>
    4afe:	2400      	movs	r4, #0

	// Iterate through all of the capabilities and display them
	for ( var_uint_t cap = 0; cap < CapabilitiesNum; cap++ )
	{
		print( NL "\t" );
    4b00:	480c      	ldr	r0, [pc, #48]	; (4b34 <cliFunc_capList+0x4c>)
    4b02:	f002 fe7f 	bl	7804 <_print>
		printHex( cap );
    4b06:	b2a0      	uxth	r0, r4
    4b08:	2101      	movs	r1, #1
    4b0a:	f002 ff04 	bl	7916 <printHex_op>
		print(" - ");
    4b0e:	480a      	ldr	r0, [pc, #40]	; (4b38 <cliFunc_capList+0x50>)
    4b10:	f002 fe78 	bl	7804 <_print>

		// Display/Lookup Capability Name (utilize debug mode of capability)
		void (*capability)(uint8_t, uint8_t, uint8_t*) = (void(*)(uint8_t, uint8_t, uint8_t*))(CapabilitiesList[ cap ].func);
    4b14:	4b09      	ldr	r3, [pc, #36]	; (4b3c <cliFunc_capList+0x54>)
		capability( 0xFF, 0xFF, 0 );
    4b16:	20ff      	movs	r0, #255	; 0xff
    4b18:	f853 3034 	ldr.w	r3, [r3, r4, lsl #3]
    4b1c:	4601      	mov	r1, r0
    4b1e:	2200      	movs	r2, #0
    4b20:	3401      	adds	r4, #1
    4b22:	4798      	blx	r3
	print( NL );
	info_msg("Capabilities List ");
	printHex( CapabilitiesNum );

	// Iterate through all of the capabilities and display them
	for ( var_uint_t cap = 0; cap < CapabilitiesNum; cap++ )
    4b24:	2c0f      	cmp	r4, #15
    4b26:	d1eb      	bne.n	4b00 <cliFunc_capList+0x18>

		// Display/Lookup Capability Name (utilize debug mode of capability)
		void (*capability)(uint8_t, uint8_t, uint8_t*) = (void(*)(uint8_t, uint8_t, uint8_t*))(CapabilitiesList[ cap ].func);
		capability( 0xFF, 0xFF, 0 );
	}
}
    4b28:	bd10      	pop	{r4, pc}
    4b2a:	bf00      	nop
    4b2c:	0000bafb 	.word	0x0000bafb
    4b30:	00009444 	.word	0x00009444
    4b34:	00009469 	.word	0x00009469
    4b38:	000091d3 	.word	0x000091d3
    4b3c:	0000a1f8 	.word	0x0000a1f8

00004b40 <cliFunc_macroStep>:
		}
	}
}

void cliFunc_macroStep( char* args )
{
    4b40:	b507      	push	{r0, r1, r2, lr}
	// Parse number from argument
	//  NOTE: Only first argument is used
	char* arg1Ptr;
	char* arg2Ptr;
	CLI_argumentIsolation( args, &arg1Ptr, &arg2Ptr );
    4b42:	4669      	mov	r1, sp
    4b44:	aa01      	add	r2, sp, #4
    4b46:	f002 fbab 	bl	72a0 <CLI_argumentIsolation>

	// Default to 1, if no argument given
	var_uint_t count = (var_uint_t)numToInt( arg1Ptr );
    4b4a:	9800      	ldr	r0, [sp, #0]
    4b4c:	f002 ff38 	bl	79c0 <numToInt>

	if ( count == 0 )
		count = 1;

	// Set the macro step counter, negative int's are cast to uint
	macroStepCounter = count;
    4b50:	4b04      	ldr	r3, [pc, #16]	; (4b64 <cliFunc_macroStep+0x24>)
	char* arg1Ptr;
	char* arg2Ptr;
	CLI_argumentIsolation( args, &arg1Ptr, &arg2Ptr );

	// Default to 1, if no argument given
	var_uint_t count = (var_uint_t)numToInt( arg1Ptr );
    4b52:	b2c0      	uxtb	r0, r0

	if ( count == 0 )
		count = 1;
    4b54:	2800      	cmp	r0, #0
    4b56:	bf08      	it	eq
    4b58:	2001      	moveq	r0, #1

	// Set the macro step counter, negative int's are cast to uint
	macroStepCounter = count;
    4b5a:	8018      	strh	r0, [r3, #0]
}
    4b5c:	b003      	add	sp, #12
    4b5e:	f85d fb04 	ldr.w	pc, [sp], #4
    4b62:	bf00      	nop
    4b64:	1fff92da 	.word	0x1fff92da

00004b68 <cliFunc_capSelect>:
		capability( 0xFF, 0xFF, 0 );
	}
}

void cliFunc_capSelect( char* args )
{
    4b68:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
	// Arguments used for keyboard capability function
	var_uint_t argSetCount = 0;
	uint8_t *argSet = (uint8_t*)args;

	// Process all args
	for ( var_uint_t c = 0; argSetCount < totalArgs; c++ )
    4b6c:	2500      	movs	r5, #0
		capability( 0xFF, 0xFF, 0 );
	}
}

void cliFunc_capSelect( char* args )
{
    4b6e:	4604      	mov	r4, r0
	// Parse code from argument
	char* curArgs;
	char* arg1Ptr;
	char* arg2Ptr = args;
    4b70:	9001      	str	r0, [sp, #4]
	// Total number of args to scan (must do a lookup if a keyboard capability is selected)
	var_uint_t totalArgs = 2; // Always at least two args
	var_uint_t cap = 0;

	// Arguments used for keyboard capability function
	var_uint_t argSetCount = 0;
    4b72:	46a8      	mov	r8, r5
	char* arg1Ptr;
	char* arg2Ptr = args;

	// Total number of args to scan (must do a lookup if a keyboard capability is selected)
	var_uint_t totalArgs = 2; // Always at least two args
	var_uint_t cap = 0;
    4b74:	46a9      	mov	r9, r5
	char* curArgs;
	char* arg1Ptr;
	char* arg2Ptr = args;

	// Total number of args to scan (must do a lookup if a keyboard capability is selected)
	var_uint_t totalArgs = 2; // Always at least two args
    4b76:	2702      	movs	r7, #2

	// Process all args
	for ( var_uint_t c = 0; argSetCount < totalArgs; c++ )
	{
		curArgs = arg2Ptr;
		CLI_argumentIsolation( curArgs, &arg1Ptr, &arg2Ptr );
    4b78:	9801      	ldr	r0, [sp, #4]
    4b7a:	4669      	mov	r1, sp
    4b7c:	aa01      	add	r2, sp, #4
    4b7e:	f002 fb8f 	bl	72a0 <CLI_argumentIsolation>

		// Stop processing args if no more are found
		// Extra arguments are ignored
		if ( *arg1Ptr == '\0' )
    4b82:	9800      	ldr	r0, [sp, #0]
    4b84:	7803      	ldrb	r3, [r0, #0]
    4b86:	2b00      	cmp	r3, #0
    4b88:	d059      	beq.n	4c3e <cliFunc_capSelect+0xd6>
			break;

		// For the first argument, choose the capability
		if ( c == 0 ) switch ( arg1Ptr[0] )
    4b8a:	b975      	cbnz	r5, 4baa <cliFunc_capSelect+0x42>
    4b8c:	2b4b      	cmp	r3, #75	; 0x4b
    4b8e:	d10c      	bne.n	4baa <cliFunc_capSelect+0x42>
		{
		// Keyboard Capability
		case 'K':
			// Determine capability index
			cap = numToInt( &arg1Ptr[1] );
    4b90:	3001      	adds	r0, #1
    4b92:	f002 ff15 	bl	79c0 <numToInt>

			// Lookup the number of args
			totalArgs += CapabilitiesList[ cap ].argCount;
    4b96:	4b2b      	ldr	r3, [pc, #172]	; (4c44 <cliFunc_capSelect+0xdc>)
		if ( c == 0 ) switch ( arg1Ptr[0] )
		{
		// Keyboard Capability
		case 'K':
			// Determine capability index
			cap = numToInt( &arg1Ptr[1] );
    4b98:	fa5f f980 	uxtb.w	r9, r0

			// Lookup the number of args
			totalArgs += CapabilitiesList[ cap ].argCount;
    4b9c:	eb03 03c9 	add.w	r3, r3, r9, lsl #3
			continue;
    4ba0:	4646      	mov	r6, r8
		case 'K':
			// Determine capability index
			cap = numToInt( &arg1Ptr[1] );

			// Lookup the number of args
			totalArgs += CapabilitiesList[ cap ].argCount;
    4ba2:	791b      	ldrb	r3, [r3, #4]
    4ba4:	441f      	add	r7, r3
    4ba6:	b2ff      	uxtb	r7, r7
			continue;
    4ba8:	e043      	b.n	4c32 <cliFunc_capSelect+0xca>
		}

		// Because allocating memory isn't doable, and the argument count is arbitrary
		// The argument pointer is repurposed as the argument list (much smaller anyways)
		argSet[ argSetCount++ ] = (uint8_t)numToInt( arg1Ptr );
    4baa:	f002 ff09 	bl	79c0 <numToInt>
    4bae:	f108 0601 	add.w	r6, r8, #1
    4bb2:	b2f6      	uxtb	r6, r6

		// Once all the arguments are prepared, call the keyboard capability function
		if ( argSetCount == totalArgs )
    4bb4:	42be      	cmp	r6, r7
			continue;
		}

		// Because allocating memory isn't doable, and the argument count is arbitrary
		// The argument pointer is repurposed as the argument list (much smaller anyways)
		argSet[ argSetCount++ ] = (uint8_t)numToInt( arg1Ptr );
    4bb6:	f804 0008 	strb.w	r0, [r4, r8]

		// Once all the arguments are prepared, call the keyboard capability function
		if ( argSetCount == totalArgs )
    4bba:	d13a      	bne.n	4c32 <cliFunc_capSelect+0xca>
		{
			// Indicate that the capability was called
			print( NL );
    4bbc:	4822      	ldr	r0, [pc, #136]	; (4c48 <cliFunc_capSelect+0xe0>)
    4bbe:	f002 fe21 	bl	7804 <_print>
			info_msg("K");
    4bc2:	4822      	ldr	r0, [pc, #136]	; (4c4c <cliFunc_capSelect+0xe4>)
    4bc4:	f002 fe1e 	bl	7804 <_print>
			printInt8( cap );
    4bc8:	4648      	mov	r0, r9
    4bca:	f002 fe4d 	bl	7868 <printInt8>
			print(" - ");
    4bce:	4820      	ldr	r0, [pc, #128]	; (4c50 <cliFunc_capSelect+0xe8>)
    4bd0:	f002 fe18 	bl	7804 <_print>
			printHex( argSet[0] );
    4bd4:	2101      	movs	r1, #1
    4bd6:	7820      	ldrb	r0, [r4, #0]
    4bd8:	f002 fe9d 	bl	7916 <printHex_op>
			print(" - ");
    4bdc:	481c      	ldr	r0, [pc, #112]	; (4c50 <cliFunc_capSelect+0xe8>)
    4bde:	f002 fe11 	bl	7804 <_print>
			printHex( argSet[1] );
    4be2:	2101      	movs	r1, #1
    4be4:	7860      	ldrb	r0, [r4, #1]
    4be6:	f002 fe96 	bl	7916 <printHex_op>
			print(" - ");
    4bea:	4819      	ldr	r0, [pc, #100]	; (4c50 <cliFunc_capSelect+0xe8>)
    4bec:	f002 fe0a 	bl	7804 <_print>
			printHex( argSet[2] );
    4bf0:	78a0      	ldrb	r0, [r4, #2]
    4bf2:	2101      	movs	r1, #1
    4bf4:	f002 fe8f 	bl	7916 <printHex_op>
			print( "..." NL );
    4bf8:	4816      	ldr	r0, [pc, #88]	; (4c54 <cliFunc_capSelect+0xec>)
    4bfa:	f002 fe03 	bl	7804 <_print>
    4bfe:	2300      	movs	r3, #0

			// Make sure this isn't the reload capability
			// If it is, and the remote reflash define is not set, ignore
			if ( flashModeEnabled_define == 0 ) for ( uint32_t cap = 0; cap < CapabilitiesNum; cap++ )
			{
				if ( CapabilitiesList[ cap ].func == (const void*)Output_flashMode_capability )
    4c00:	4a10      	ldr	r2, [pc, #64]	; (4c44 <cliFunc_capSelect+0xdc>)
    4c02:	4815      	ldr	r0, [pc, #84]	; (4c58 <cliFunc_capSelect+0xf0>)
    4c04:	5899      	ldr	r1, [r3, r2]
    4c06:	4281      	cmp	r1, r0
    4c08:	d109      	bne.n	4c1e <cliFunc_capSelect+0xb6>
				{
					print( NL );
    4c0a:	480f      	ldr	r0, [pc, #60]	; (4c48 <cliFunc_capSelect+0xe0>)
    4c0c:	f002 fdfa 	bl	7804 <_print>
					warn_print("flashModeEnabled not set, cancelling firmware reload...");
    4c10:	4812      	ldr	r0, [pc, #72]	; (4c5c <cliFunc_capSelect+0xf4>)
    4c12:	f002 fdf7 	bl	7804 <_print>
					info_msg("Set flashModeEnabled to 1 in your kll configuration.");
    4c16:	4812      	ldr	r0, [pc, #72]	; (4c60 <cliFunc_capSelect+0xf8>)
    4c18:	f002 fdf4 	bl	7804 <_print>
    4c1c:	e00f      	b.n	4c3e <cliFunc_capSelect+0xd6>
    4c1e:	3308      	adds	r3, #8
			printHex( argSet[2] );
			print( "..." NL );

			// Make sure this isn't the reload capability
			// If it is, and the remote reflash define is not set, ignore
			if ( flashModeEnabled_define == 0 ) for ( uint32_t cap = 0; cap < CapabilitiesNum; cap++ )
    4c20:	2b78      	cmp	r3, #120	; 0x78
    4c22:	d1ed      	bne.n	4c00 <cliFunc_capSelect+0x98>
					return;
				}
			}

			void (*capability)(uint8_t, uint8_t, uint8_t*) = (void(*)(uint8_t, uint8_t, uint8_t*))(CapabilitiesList[ cap ].func);
			capability( argSet[0], argSet[1], &argSet[2] );
    4c24:	f852 3039 	ldr.w	r3, [r2, r9, lsl #3]
    4c28:	7820      	ldrb	r0, [r4, #0]
    4c2a:	7861      	ldrb	r1, [r4, #1]
    4c2c:	1ca2      	adds	r2, r4, #2
    4c2e:	4798      	blx	r3
    4c30:	4637      	mov	r7, r6
	// Arguments used for keyboard capability function
	var_uint_t argSetCount = 0;
	uint8_t *argSet = (uint8_t*)args;

	// Process all args
	for ( var_uint_t c = 0; argSetCount < totalArgs; c++ )
    4c32:	3501      	adds	r5, #1
    4c34:	42be      	cmp	r6, r7
    4c36:	b2ed      	uxtb	r5, r5
    4c38:	d201      	bcs.n	4c3e <cliFunc_capSelect+0xd6>
    4c3a:	46b0      	mov	r8, r6
    4c3c:	e79c      	b.n	4b78 <cliFunc_capSelect+0x10>

			void (*capability)(uint8_t, uint8_t, uint8_t*) = (void(*)(uint8_t, uint8_t, uint8_t*))(CapabilitiesList[ cap ].func);
			capability( argSet[0], argSet[1], &argSet[2] );
		}
	}
}
    4c3e:	b003      	add	sp, #12
    4c40:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    4c44:	0000a1f8 	.word	0x0000a1f8
    4c48:	0000bafb 	.word	0x0000bafb
    4c4c:	0000946d 	.word	0x0000946d
    4c50:	000091d3 	.word	0x000091d3
    4c54:	000094ca 	.word	0x000094ca
    4c58:	00005ef9 	.word	0x00005ef9
    4c5c:	00009481 	.word	0x00009481
    4c60:	000094d0 	.word	0x000094d0

00004c64 <cliFunc_layerDebug>:
		}
	}
}

void cliFunc_layerDebug( char *args )
{
    4c64:	b510      	push	{r4, lr}
	// Toggle layer debug mode
	layerDebugMode = layerDebugMode ? 0 : 1;
    4c66:	4c09      	ldr	r4, [pc, #36]	; (4c8c <cliFunc_layerDebug+0x28>)

	print( NL );
    4c68:	4809      	ldr	r0, [pc, #36]	; (4c90 <cliFunc_layerDebug+0x2c>)
}

void cliFunc_layerDebug( char *args )
{
	// Toggle layer debug mode
	layerDebugMode = layerDebugMode ? 0 : 1;
    4c6a:	7823      	ldrb	r3, [r4, #0]
    4c6c:	f1d3 0301 	rsbs	r3, r3, #1
    4c70:	bf38      	it	cc
    4c72:	2300      	movcc	r3, #0
    4c74:	7023      	strb	r3, [r4, #0]

	print( NL );
    4c76:	f002 fdc5 	bl	7804 <_print>
	info_msg("Layer Debug Mode: ");
    4c7a:	4806      	ldr	r0, [pc, #24]	; (4c94 <cliFunc_layerDebug+0x30>)
    4c7c:	f002 fdc2 	bl	7804 <_print>
	printInt8( layerDebugMode );
    4c80:	7820      	ldrb	r0, [r4, #0]
}
    4c82:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	// Toggle layer debug mode
	layerDebugMode = layerDebugMode ? 0 : 1;

	print( NL );
	info_msg("Layer Debug Mode: ");
	printInt8( layerDebugMode );
    4c86:	f002 bdef 	b.w	7868 <printInt8>
    4c8a:	bf00      	nop
    4c8c:	1fff9408 	.word	0x1fff9408
    4c90:	0000bafb 	.word	0x0000bafb
    4c94:	00009517 	.word	0x00009517

00004c98 <cliFunc_layerState>:
		printHex( LayerIndex[ layer ].last );
	}
}

void cliFunc_layerState( char* args )
{
    4c98:	b573      	push	{r0, r1, r4, r5, r6, lr}

	uint8_t arg1 = 0;
	uint8_t arg2 = 0;

	// Process first two args
	for ( uint8_t c = 0; c < 2; c++ )
    4c9a:	2400      	movs	r4, #0
void cliFunc_layerState( char* args )
{
	// Parse codes from arguments
	char* curArgs;
	char* arg1Ptr;
	char* arg2Ptr = args;
    4c9c:	9001      	str	r0, [sp, #4]

	uint8_t arg1 = 0;
    4c9e:	4625      	mov	r5, r4

	// Process first two args
	for ( uint8_t c = 0; c < 2; c++ )
	{
		curArgs = arg2Ptr;
		CLI_argumentIsolation( curArgs, &arg1Ptr, &arg2Ptr );
    4ca0:	9801      	ldr	r0, [sp, #4]
    4ca2:	4669      	mov	r1, sp
    4ca4:	aa01      	add	r2, sp, #4
    4ca6:	f002 fafb 	bl	72a0 <CLI_argumentIsolation>

		// Stop processing args if no more are found
		if ( *arg1Ptr == '\0' )
    4caa:	9800      	ldr	r0, [sp, #0]
    4cac:	7803      	ldrb	r3, [r0, #0]
    4cae:	b30b      	cbz	r3, 4cf4 <cliFunc_layerState+0x5c>
			break;

		switch ( c )
    4cb0:	2c01      	cmp	r4, #1
    4cb2:	d006      	beq.n	4cc2 <cliFunc_layerState+0x2a>
		{
		// First argument (e.g. L1)
		case 0:
			if ( arg1Ptr[0] != 'L' )
    4cb4:	2b4c      	cmp	r3, #76	; 0x4c
    4cb6:	d11d      	bne.n	4cf4 <cliFunc_layerState+0x5c>
				return;

			arg1 = (uint8_t)numToInt( &arg1Ptr[1] );
    4cb8:	3001      	adds	r0, #1
    4cba:	f002 fe81 	bl	79c0 <numToInt>
    4cbe:	b2c5      	uxtb	r5, r0
			break;
    4cc0:	e014      	b.n	4cec <cliFunc_layerState+0x54>
		// Second argument (e.g. 4)
		case 1:
			arg2 = (uint8_t)numToInt( arg1Ptr );
    4cc2:	f002 fe7d 	bl	79c0 <numToInt>
    4cc6:	b2c6      	uxtb	r6, r0

			// Display operation (to indicate that it worked)
			print( NL );
    4cc8:	480b      	ldr	r0, [pc, #44]	; (4cf8 <cliFunc_layerState+0x60>)
    4cca:	f002 fd9b 	bl	7804 <_print>
			info_msg("Setting Layer L");
    4cce:	480b      	ldr	r0, [pc, #44]	; (4cfc <cliFunc_layerState+0x64>)
    4cd0:	f002 fd98 	bl	7804 <_print>
			printInt8( arg1 );
    4cd4:	4628      	mov	r0, r5
    4cd6:	f002 fdc7 	bl	7868 <printInt8>
			print(" to - ");
    4cda:	4809      	ldr	r0, [pc, #36]	; (4d00 <cliFunc_layerState+0x68>)
    4cdc:	f002 fd92 	bl	7804 <_print>
			printHex( arg2 );
    4ce0:	4630      	mov	r0, r6
    4ce2:	4621      	mov	r1, r4
    4ce4:	f002 fe17 	bl	7916 <printHex_op>

			// Set the layer state
			LayerState[ arg1 ] = arg2;
    4ce8:	4b06      	ldr	r3, [pc, #24]	; (4d04 <cliFunc_layerState+0x6c>)
    4cea:	555e      	strb	r6, [r3, r5]

	uint8_t arg1 = 0;
	uint8_t arg2 = 0;

	// Process first two args
	for ( uint8_t c = 0; c < 2; c++ )
    4cec:	3401      	adds	r4, #1
    4cee:	b2e4      	uxtb	r4, r4
    4cf0:	2c02      	cmp	r4, #2
    4cf2:	d1d5      	bne.n	4ca0 <cliFunc_layerState+0x8>
			// Set the layer state
			LayerState[ arg1 ] = arg2;
			break;
		}
	}
}
    4cf4:	b002      	add	sp, #8
    4cf6:	bd70      	pop	{r4, r5, r6, pc}
    4cf8:	0000bafb 	.word	0x0000bafb
    4cfc:	0000953c 	.word	0x0000953c
    4d00:	0000955e 	.word	0x0000955e
    4d04:	1fffa399 	.word	0x1fffa399

00004d08 <cliFunc_macroDebug>:

void cliFunc_macroDebug( char* args )
{
    4d08:	b510      	push	{r4, lr}
	// Toggle macro debug mode
	macroDebugMode = macroDebugMode ? 0 : 1;
    4d0a:	4c09      	ldr	r4, [pc, #36]	; (4d30 <cliFunc_macroDebug+0x28>)

	print( NL );
    4d0c:	4809      	ldr	r0, [pc, #36]	; (4d34 <cliFunc_macroDebug+0x2c>)
}

void cliFunc_macroDebug( char* args )
{
	// Toggle macro debug mode
	macroDebugMode = macroDebugMode ? 0 : 1;
    4d0e:	7823      	ldrb	r3, [r4, #0]
    4d10:	f1d3 0301 	rsbs	r3, r3, #1
    4d14:	bf38      	it	cc
    4d16:	2300      	movcc	r3, #0
    4d18:	7023      	strb	r3, [r4, #0]

	print( NL );
    4d1a:	f002 fd73 	bl	7804 <_print>
	info_msg("Macro Debug Mode: ");
    4d1e:	4806      	ldr	r0, [pc, #24]	; (4d38 <cliFunc_macroDebug+0x30>)
    4d20:	f002 fd70 	bl	7804 <_print>
	printInt8( macroDebugMode );
    4d24:	7820      	ldrb	r0, [r4, #0]
}
    4d26:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	// Toggle macro debug mode
	macroDebugMode = macroDebugMode ? 0 : 1;

	print( NL );
	info_msg("Macro Debug Mode: ");
	printInt8( macroDebugMode );
    4d2a:	f002 bd9d 	b.w	7868 <printInt8>
    4d2e:	bf00      	nop
    4d30:	1fff940c 	.word	0x1fff940c
    4d34:	0000bafb 	.word	0x0000bafb
    4d38:	00009565 	.word	0x00009565

00004d3c <cliFunc_macroProc>:
		printInt16( (uint16_t)TriggerMacroList[ macro ].result ); // Hopefully large enough :P (can't assume 32-bit)
	}
}

void cliFunc_macroProc( char* args )
{
    4d3c:	b510      	push	{r4, lr}
	// Toggle macro pause mode
	macroPauseMode = macroPauseMode ? 0 : 1;
    4d3e:	4c09      	ldr	r4, [pc, #36]	; (4d64 <cliFunc_macroProc+0x28>)

	print( NL );
    4d40:	4809      	ldr	r0, [pc, #36]	; (4d68 <cliFunc_macroProc+0x2c>)
}

void cliFunc_macroProc( char* args )
{
	// Toggle macro pause mode
	macroPauseMode = macroPauseMode ? 0 : 1;
    4d42:	7823      	ldrb	r3, [r4, #0]
    4d44:	f1d3 0301 	rsbs	r3, r3, #1
    4d48:	bf38      	it	cc
    4d4a:	2300      	movcc	r3, #0
    4d4c:	7023      	strb	r3, [r4, #0]

	print( NL );
    4d4e:	f002 fd59 	bl	7804 <_print>
	info_msg("Macro Processing Mode: ");
    4d52:	4806      	ldr	r0, [pc, #24]	; (4d6c <cliFunc_macroProc+0x30>)
    4d54:	f002 fd56 	bl	7804 <_print>
	printInt8( macroPauseMode );
    4d58:	7820      	ldrb	r0, [r4, #0]
}
    4d5a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	// Toggle macro pause mode
	macroPauseMode = macroPauseMode ? 0 : 1;

	print( NL );
	info_msg("Macro Processing Mode: ");
	printInt8( macroPauseMode );
    4d5e:	f002 bd83 	b.w	7868 <printInt8>
    4d62:	bf00      	nop
    4d64:	1fff92df 	.word	0x1fff92df
    4d68:	0000bafb 	.word	0x0000bafb
    4d6c:	0000958a 	.word	0x0000958a

00004d70 <cliFunc_layerList>:
	info_msg("Layer Debug Mode: ");
	printInt8( layerDebugMode );
}

void cliFunc_layerList( char* args )
{
    4d70:	b570      	push	{r4, r5, r6, lr}
	print( NL );
    4d72:	481b      	ldr	r0, [pc, #108]	; (4de0 <cliFunc_layerList+0x70>)
    4d74:	4d1b      	ldr	r5, [pc, #108]	; (4de4 <cliFunc_layerList+0x74>)
    4d76:	f002 fd45 	bl	7804 <_print>
	info_msg("Layer List");
    4d7a:	481b      	ldr	r0, [pc, #108]	; (4de8 <cliFunc_layerList+0x78>)
    4d7c:	f002 fd42 	bl	7804 <_print>
    4d80:	2400      	movs	r4, #0
    4d82:	b2a6      	uxth	r6, r4

	// Iterate through all of the layers and display them
	for ( uint16_t layer = 0; layer < LayerNum; layer++ )
	{
		print( NL "\t" );
    4d84:	4819      	ldr	r0, [pc, #100]	; (4dec <cliFunc_layerList+0x7c>)
    4d86:	f002 fd3d 	bl	7804 <_print>
		printHex( layer );
    4d8a:	4630      	mov	r0, r6
    4d8c:	2101      	movs	r1, #1
    4d8e:	f002 fdc2 	bl	7916 <printHex_op>
		print(" - ");
    4d92:	4817      	ldr	r0, [pc, #92]	; (4df0 <cliFunc_layerList+0x80>)
    4d94:	f002 fd36 	bl	7804 <_print>

		// Display layer name
		dPrint( (char*)LayerIndex[ layer ].name );
    4d98:	6828      	ldr	r0, [r5, #0]
    4d9a:	f001 fa35 	bl	6208 <Output_putstr>

		// Default map
		if ( layer == 0 )
    4d9e:	b916      	cbnz	r6, 4da6 <cliFunc_layerList+0x36>
			print(" \033[1m(default)\033[0m");
    4da0:	4814      	ldr	r0, [pc, #80]	; (4df4 <cliFunc_layerList+0x84>)
    4da2:	f002 fd2f 	bl	7804 <_print>

		// Layer State
		print( NL "\t\t Layer State: " );
    4da6:	4814      	ldr	r0, [pc, #80]	; (4df8 <cliFunc_layerList+0x88>)
    4da8:	f002 fd2c 	bl	7804 <_print>
		printHex( LayerState[ layer ] );
    4dac:	4b13      	ldr	r3, [pc, #76]	; (4dfc <cliFunc_layerList+0x8c>)
    4dae:	2101      	movs	r1, #1
    4db0:	5d18      	ldrb	r0, [r3, r4]
    4db2:	f002 fdb0 	bl	7916 <printHex_op>

		// First -> Last Indices
		print(" First -> Last Indices: ");
    4db6:	4812      	ldr	r0, [pc, #72]	; (4e00 <cliFunc_layerList+0x90>)
    4db8:	f002 fd24 	bl	7804 <_print>
		printHex( LayerIndex[ layer ].first );
    4dbc:	7928      	ldrb	r0, [r5, #4]
    4dbe:	2101      	movs	r1, #1
    4dc0:	f002 fda9 	bl	7916 <printHex_op>
		print(" -> ");
    4dc4:	480f      	ldr	r0, [pc, #60]	; (4e04 <cliFunc_layerList+0x94>)
    4dc6:	f002 fd1d 	bl	7804 <_print>
    4dca:	3401      	adds	r4, #1
		printHex( LayerIndex[ layer ].last );
    4dcc:	7968      	ldrb	r0, [r5, #5]
    4dce:	2101      	movs	r1, #1
    4dd0:	f002 fda1 	bl	7916 <printHex_op>
{
	print( NL );
	info_msg("Layer List");

	// Iterate through all of the layers and display them
	for ( uint16_t layer = 0; layer < LayerNum; layer++ )
    4dd4:	2c04      	cmp	r4, #4
    4dd6:	f105 050c 	add.w	r5, r5, #12
    4dda:	d1d2      	bne.n	4d82 <cliFunc_layerList+0x12>
		print(" First -> Last Indices: ");
		printHex( LayerIndex[ layer ].first );
		print(" -> ");
		printHex( LayerIndex[ layer ].last );
	}
}
    4ddc:	bd70      	pop	{r4, r5, r6, pc}
    4dde:	bf00      	nop
    4de0:	0000bafb 	.word	0x0000bafb
    4de4:	0000ab88 	.word	0x0000ab88
    4de8:	000095b4 	.word	0x000095b4
    4dec:	00009469 	.word	0x00009469
    4df0:	000091d3 	.word	0x000091d3
    4df4:	000095d1 	.word	0x000095d1
    4df8:	000095e4 	.word	0x000095e4
    4dfc:	1fffa399 	.word	0x1fffa399
    4e00:	000095f7 	.word	0x000095f7
    4e04:	00008d5c 	.word	0x00008d5c

00004e08 <cliFunc_macroList>:
	info_msg("Macro Debug Mode: ");
	printInt8( macroDebugMode );
}

void cliFunc_macroList( char* args )
{
    4e08:	b538      	push	{r3, r4, r5, lr}
	// Show pending key events
	print( NL );
    4e0a:	4844      	ldr	r0, [pc, #272]	; (4f1c <cliFunc_macroList+0x114>)
	info_msg("Pending Key Events: ");
	printInt16( (uint16_t)macroTriggerListBufferSize );
    4e0c:	4d44      	ldr	r5, [pc, #272]	; (4f20 <cliFunc_macroList+0x118>)
}

void cliFunc_macroList( char* args )
{
	// Show pending key events
	print( NL );
    4e0e:	f002 fcf9 	bl	7804 <_print>
	info_msg("Pending Key Events: ");
    4e12:	4844      	ldr	r0, [pc, #272]	; (4f24 <cliFunc_macroList+0x11c>)
    4e14:	f002 fcf6 	bl	7804 <_print>
	printInt16( (uint16_t)macroTriggerListBufferSize );
    4e18:	7828      	ldrb	r0, [r5, #0]
    4e1a:	f002 fd45 	bl	78a8 <printInt16>
	print(" : ");
    4e1e:	4842      	ldr	r0, [pc, #264]	; (4f28 <cliFunc_macroList+0x120>)
    4e20:	f002 fcf0 	bl	7804 <_print>
	for ( uint8_t key = 0; key < macroTriggerListBufferSize; key++ )
    4e24:	2400      	movs	r4, #0
    4e26:	782b      	ldrb	r3, [r5, #0]
    4e28:	42a3      	cmp	r3, r4
    4e2a:	d90d      	bls.n	4e48 <cliFunc_macroList+0x40>
	{
		printHex( macroTriggerListBuffer[ key ].scanCode );
    4e2c:	4b3f      	ldr	r3, [pc, #252]	; (4f2c <cliFunc_macroList+0x124>)
    4e2e:	2203      	movs	r2, #3
    4e30:	fb02 3304 	mla	r3, r2, r4, r3
    4e34:	2101      	movs	r1, #1
    4e36:	7898      	ldrb	r0, [r3, #2]
    4e38:	f002 fd6d 	bl	7916 <printHex_op>
	// Show pending key events
	print( NL );
	info_msg("Pending Key Events: ");
	printInt16( (uint16_t)macroTriggerListBufferSize );
	print(" : ");
	for ( uint8_t key = 0; key < macroTriggerListBufferSize; key++ )
    4e3c:	3401      	adds	r4, #1
	{
		printHex( macroTriggerListBuffer[ key ].scanCode );
		print(" ");
    4e3e:	483c      	ldr	r0, [pc, #240]	; (4f30 <cliFunc_macroList+0x128>)
    4e40:	f002 fce0 	bl	7804 <_print>
	// Show pending key events
	print( NL );
	info_msg("Pending Key Events: ");
	printInt16( (uint16_t)macroTriggerListBufferSize );
	print(" : ");
	for ( uint8_t key = 0; key < macroTriggerListBufferSize; key++ )
    4e44:	b2e4      	uxtb	r4, r4
    4e46:	e7ee      	b.n	4e26 <cliFunc_macroList+0x1e>
		printHex( macroTriggerListBuffer[ key ].scanCode );
		print(" ");
	}

	// Show pending trigger macros
	print( NL );
    4e48:	4834      	ldr	r0, [pc, #208]	; (4f1c <cliFunc_macroList+0x114>)
	info_msg("Pending Trigger Macros: ");
	printInt16( (uint16_t)macroTriggerMacroPendingListSize );
    4e4a:	4d3a      	ldr	r5, [pc, #232]	; (4f34 <cliFunc_macroList+0x12c>)
		printHex( macroTriggerListBuffer[ key ].scanCode );
		print(" ");
	}

	// Show pending trigger macros
	print( NL );
    4e4c:	f002 fcda 	bl	7804 <_print>
	info_msg("Pending Trigger Macros: ");
    4e50:	4839      	ldr	r0, [pc, #228]	; (4f38 <cliFunc_macroList+0x130>)
    4e52:	f002 fcd7 	bl	7804 <_print>
	printInt16( (uint16_t)macroTriggerMacroPendingListSize );
    4e56:	8828      	ldrh	r0, [r5, #0]
    4e58:	f002 fd26 	bl	78a8 <printInt16>
	print(" : ");
    4e5c:	4832      	ldr	r0, [pc, #200]	; (4f28 <cliFunc_macroList+0x120>)
    4e5e:	f002 fcd1 	bl	7804 <_print>
	for ( var_uint_t macro = 0; macro < macroTriggerMacroPendingListSize; macro++ )
    4e62:	2400      	movs	r4, #0
    4e64:	882b      	ldrh	r3, [r5, #0]
    4e66:	42a3      	cmp	r3, r4
    4e68:	d90b      	bls.n	4e82 <cliFunc_macroList+0x7a>
	{
		printHex( macroTriggerMacroPendingList[ macro ] );
    4e6a:	4b34      	ldr	r3, [pc, #208]	; (4f3c <cliFunc_macroList+0x134>)
    4e6c:	2101      	movs	r1, #1
    4e6e:	f833 0014 	ldrh.w	r0, [r3, r4, lsl #1]
    4e72:	f002 fd50 	bl	7916 <printHex_op>
	// Show pending trigger macros
	print( NL );
	info_msg("Pending Trigger Macros: ");
	printInt16( (uint16_t)macroTriggerMacroPendingListSize );
	print(" : ");
	for ( var_uint_t macro = 0; macro < macroTriggerMacroPendingListSize; macro++ )
    4e76:	3401      	adds	r4, #1
	{
		printHex( macroTriggerMacroPendingList[ macro ] );
		print(" ");
    4e78:	482d      	ldr	r0, [pc, #180]	; (4f30 <cliFunc_macroList+0x128>)
    4e7a:	f002 fcc3 	bl	7804 <_print>
	// Show pending trigger macros
	print( NL );
	info_msg("Pending Trigger Macros: ");
	printInt16( (uint16_t)macroTriggerMacroPendingListSize );
	print(" : ");
	for ( var_uint_t macro = 0; macro < macroTriggerMacroPendingListSize; macro++ )
    4e7e:	b2e4      	uxtb	r4, r4
    4e80:	e7f0      	b.n	4e64 <cliFunc_macroList+0x5c>
		printHex( macroTriggerMacroPendingList[ macro ] );
		print(" ");
	}

	// Show pending result macros
	print( NL );
    4e82:	4826      	ldr	r0, [pc, #152]	; (4f1c <cliFunc_macroList+0x114>)
	info_msg("Pending Result Macros: ");
	printInt16( (uint16_t)macroResultMacroPendingListSize );
    4e84:	4d2e      	ldr	r5, [pc, #184]	; (4f40 <cliFunc_macroList+0x138>)
		printHex( macroTriggerMacroPendingList[ macro ] );
		print(" ");
	}

	// Show pending result macros
	print( NL );
    4e86:	f002 fcbd 	bl	7804 <_print>
	info_msg("Pending Result Macros: ");
    4e8a:	482e      	ldr	r0, [pc, #184]	; (4f44 <cliFunc_macroList+0x13c>)
    4e8c:	f002 fcba 	bl	7804 <_print>
	printInt16( (uint16_t)macroResultMacroPendingListSize );
    4e90:	8828      	ldrh	r0, [r5, #0]
    4e92:	f002 fd09 	bl	78a8 <printInt16>
	print(" : ");
    4e96:	4824      	ldr	r0, [pc, #144]	; (4f28 <cliFunc_macroList+0x120>)
    4e98:	f002 fcb4 	bl	7804 <_print>
	for ( var_uint_t macro = 0; macro < macroResultMacroPendingListSize; macro++ )
    4e9c:	2400      	movs	r4, #0
    4e9e:	882b      	ldrh	r3, [r5, #0]
    4ea0:	42a3      	cmp	r3, r4
    4ea2:	d90b      	bls.n	4ebc <cliFunc_macroList+0xb4>
	{
		printHex( macroResultMacroPendingList[ macro ] );
    4ea4:	4b28      	ldr	r3, [pc, #160]	; (4f48 <cliFunc_macroList+0x140>)
    4ea6:	2101      	movs	r1, #1
    4ea8:	f833 0014 	ldrh.w	r0, [r3, r4, lsl #1]
    4eac:	f002 fd33 	bl	7916 <printHex_op>
	// Show pending result macros
	print( NL );
	info_msg("Pending Result Macros: ");
	printInt16( (uint16_t)macroResultMacroPendingListSize );
	print(" : ");
	for ( var_uint_t macro = 0; macro < macroResultMacroPendingListSize; macro++ )
    4eb0:	3401      	adds	r4, #1
	{
		printHex( macroResultMacroPendingList[ macro ] );
		print(" ");
    4eb2:	481f      	ldr	r0, [pc, #124]	; (4f30 <cliFunc_macroList+0x128>)
    4eb4:	f002 fca6 	bl	7804 <_print>
	// Show pending result macros
	print( NL );
	info_msg("Pending Result Macros: ");
	printInt16( (uint16_t)macroResultMacroPendingListSize );
	print(" : ");
	for ( var_uint_t macro = 0; macro < macroResultMacroPendingListSize; macro++ )
    4eb8:	b2e4      	uxtb	r4, r4
    4eba:	e7f0      	b.n	4e9e <cliFunc_macroList+0x96>
		printHex( macroResultMacroPendingList[ macro ] );
		print(" ");
	}

	// Show available trigger macro indices
	print( NL );
    4ebc:	4817      	ldr	r0, [pc, #92]	; (4f1c <cliFunc_macroList+0x114>)
    4ebe:	f002 fca1 	bl	7804 <_print>
	info_msg("Trigger Macros Range: T0 -> T");
    4ec2:	4822      	ldr	r0, [pc, #136]	; (4f4c <cliFunc_macroList+0x144>)
    4ec4:	f002 fc9e 	bl	7804 <_print>
	printInt16( (uint16_t)TriggerMacroNum - 1 ); // Hopefully large enough :P (can't assume 32-bit)
    4ec8:	208c      	movs	r0, #140	; 0x8c
    4eca:	f002 fced 	bl	78a8 <printInt16>

	// Show available result macro indices
	print( NL );
    4ece:	4813      	ldr	r0, [pc, #76]	; (4f1c <cliFunc_macroList+0x114>)
    4ed0:	f002 fc98 	bl	7804 <_print>
	info_msg("Result  Macros Range: R0 -> R");
    4ed4:	481e      	ldr	r0, [pc, #120]	; (4f50 <cliFunc_macroList+0x148>)
    4ed6:	f002 fc95 	bl	7804 <_print>
	printInt16( (uint16_t)ResultMacroNum - 1 ); // Hopefully large enough :P (can't assume 32-bit)
    4eda:	206f      	movs	r0, #111	; 0x6f
    4edc:	f002 fce4 	bl	78a8 <printInt16>

	// Show Trigger to Result Macro Links
	print( NL );
    4ee0:	480e      	ldr	r0, [pc, #56]	; (4f1c <cliFunc_macroList+0x114>)
    4ee2:	f002 fc8f 	bl	7804 <_print>
	info_msg("Trigger : Result Macro Pairs");
    4ee6:	481b      	ldr	r0, [pc, #108]	; (4f54 <cliFunc_macroList+0x14c>)
    4ee8:	f002 fc8c 	bl	7804 <_print>
    4eec:	2400      	movs	r4, #0
	for ( var_uint_t macro = 0; macro < TriggerMacroNum; macro++ )
	{
		print( NL );
    4eee:	480b      	ldr	r0, [pc, #44]	; (4f1c <cliFunc_macroList+0x114>)
    4ef0:	f002 fc88 	bl	7804 <_print>
		print("\tT");
    4ef4:	4818      	ldr	r0, [pc, #96]	; (4f58 <cliFunc_macroList+0x150>)
    4ef6:	f002 fc85 	bl	7804 <_print>
		printInt16( (uint16_t)macro ); // Hopefully large enough :P (can't assume 32-bit)
    4efa:	b2a0      	uxth	r0, r4
    4efc:	f002 fcd4 	bl	78a8 <printInt16>
		print(" : R");
    4f00:	4816      	ldr	r0, [pc, #88]	; (4f5c <cliFunc_macroList+0x154>)
    4f02:	f002 fc7f 	bl	7804 <_print>
    4f06:	4b16      	ldr	r3, [pc, #88]	; (4f60 <cliFunc_macroList+0x158>)
    4f08:	eb03 03c4 	add.w	r3, r3, r4, lsl #3
    4f0c:	3401      	adds	r4, #1
		printInt16( (uint16_t)TriggerMacroList[ macro ].result ); // Hopefully large enough :P (can't assume 32-bit)
    4f0e:	7918      	ldrb	r0, [r3, #4]
    4f10:	f002 fcca 	bl	78a8 <printInt16>
	printInt16( (uint16_t)ResultMacroNum - 1 ); // Hopefully large enough :P (can't assume 32-bit)

	// Show Trigger to Result Macro Links
	print( NL );
	info_msg("Trigger : Result Macro Pairs");
	for ( var_uint_t macro = 0; macro < TriggerMacroNum; macro++ )
    4f14:	2c8d      	cmp	r4, #141	; 0x8d
    4f16:	d1ea      	bne.n	4eee <cliFunc_macroList+0xe6>
		print("\tT");
		printInt16( (uint16_t)macro ); // Hopefully large enough :P (can't assume 32-bit)
		print(" : R");
		printInt16( (uint16_t)TriggerMacroList[ macro ].result ); // Hopefully large enough :P (can't assume 32-bit)
	}
}
    4f18:	bd38      	pop	{r3, r4, r5, pc}
    4f1a:	bf00      	nop
    4f1c:	0000bafb 	.word	0x0000bafb
    4f20:	1fff92de 	.word	0x1fff92de
    4f24:	00009610 	.word	0x00009610
    4f28:	00009637 	.word	0x00009637
    4f2c:	1fffa13e 	.word	0x1fffa13e
    4f30:	00008156 	.word	0x00008156
    4f34:	1fff940a 	.word	0x1fff940a
    4f38:	0000963b 	.word	0x0000963b
    4f3c:	1fff92e0 	.word	0x1fff92e0
    4f40:	1fff9406 	.word	0x1fff9406
    4f44:	00009666 	.word	0x00009666
    4f48:	1fff940e 	.word	0x1fff940e
    4f4c:	00009690 	.word	0x00009690
    4f50:	000096c0 	.word	0x000096c0
    4f54:	000096f0 	.word	0x000096f0
    4f58:	0000971f 	.word	0x0000971f
    4f5c:	00009722 	.word	0x00009722
    4f60:	0000a408 	.word	0x0000a408

00004f64 <Macro_layerState>:

// Sets the given layer with the specified layerState
void Macro_layerState( uint8_t state, uint8_t stateType, uint16_t layer, uint8_t layerState )
{
	// Ignore if layer does not exist or trying to manipulate layer 0/Default layer
	if ( layer >= LayerNum || layer == 0 )
    4f64:	1e51      	subs	r1, r2, #1
    4f66:	b289      	uxth	r1, r1
    4f68:	2902      	cmp	r1, #2

// ----- Capabilities -----

// Sets the given layer with the specified layerState
void Macro_layerState( uint8_t state, uint8_t stateType, uint16_t layer, uint8_t layerState )
{
    4f6a:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	// Ignore if layer does not exist or trying to manipulate layer 0/Default layer
	if ( layer >= LayerNum || layer == 0 )
    4f6c:	d852      	bhi.n	5014 <Macro_layerState+0xb0>
		return;

	// Is layer in the LayerIndexStack?
	uint8_t inLayerIndexStack = 0;
	uint16_t stackItem = 0;
	while ( stackItem < macroLayerIndexStackSize )
    4f6e:	4c2a      	ldr	r4, [pc, #168]	; (5018 <Macro_layerState+0xb4>)
    4f70:	8825      	ldrh	r5, [r4, #0]
    4f72:	2000      	movs	r0, #0
    4f74:	b281      	uxth	r1, r0
    4f76:	42a9      	cmp	r1, r5
    4f78:	d209      	bcs.n	4f8e <Macro_layerState+0x2a>
    4f7a:	4e28      	ldr	r6, [pc, #160]	; (501c <Macro_layerState+0xb8>)
    4f7c:	3001      	adds	r0, #1
    4f7e:	eb06 0640 	add.w	r6, r6, r0, lsl #1
	{
		// Flag if layer is already in the LayerIndexStack
		if ( macroLayerIndexStack[ stackItem ] == layer )
    4f82:	f836 6c02 	ldrh.w	r6, [r6, #-2]
    4f86:	4296      	cmp	r6, r2
    4f88:	d1f4      	bne.n	4f74 <Macro_layerState+0x10>
		{
			inLayerIndexStack = 1;
    4f8a:	2001      	movs	r0, #1
    4f8c:	e000      	b.n	4f90 <Macro_layerState+0x2c>
	// Ignore if layer does not exist or trying to manipulate layer 0/Default layer
	if ( layer >= LayerNum || layer == 0 )
		return;

	// Is layer in the LayerIndexStack?
	uint8_t inLayerIndexStack = 0;
    4f8e:	2000      	movs	r0, #0
		// Increment to next item
		stackItem++;
	}

	// Toggle Layer State Byte
	if ( LayerState[ layer ] & layerState )
    4f90:	4e23      	ldr	r6, [pc, #140]	; (5020 <Macro_layerState+0xbc>)
    4f92:	5cb7      	ldrb	r7, [r6, r2]
    4f94:	421f      	tst	r7, r3
	{
		// Unset
		LayerState[ layer ] &= ~layerState;
    4f96:	bf14      	ite	ne
    4f98:	ea27 0303 	bicne.w	r3, r7, r3
	}
	else
	{
		// Set
		LayerState[ layer ] |= layerState;
    4f9c:	433b      	orreq	r3, r7
    4f9e:	54b3      	strb	r3, [r6, r2]
	}

	// If the layer was not in the LayerIndexStack add it
	if ( !inLayerIndexStack )
    4fa0:	b920      	cbnz	r0, 4fac <Macro_layerState+0x48>
	{
		macroLayerIndexStack[ macroLayerIndexStackSize++ ] = layer;
    4fa2:	1c6b      	adds	r3, r5, #1
    4fa4:	8023      	strh	r3, [r4, #0]
    4fa6:	4b1d      	ldr	r3, [pc, #116]	; (501c <Macro_layerState+0xb8>)
    4fa8:	f823 2015 	strh.w	r2, [r3, r5, lsl #1]
	}

	// If the layer is in the LayerIndexStack and the state is 0x00, remove
	if ( LayerState[ layer ] == 0x00 && inLayerIndexStack )
    4fac:	5cb3      	ldrb	r3, [r6, r2]
    4fae:	b96b      	cbnz	r3, 4fcc <Macro_layerState+0x68>
    4fb0:	b160      	cbz	r0, 4fcc <Macro_layerState+0x68>
	{
		// Remove the layer from the LayerIndexStack
		// Using the already positioned stackItem variable from the loop above
		while ( stackItem < macroLayerIndexStackSize )
    4fb2:	8823      	ldrh	r3, [r4, #0]
    4fb4:	4299      	cmp	r1, r3
    4fb6:	d207      	bcs.n	4fc8 <Macro_layerState+0x64>
		{
			macroLayerIndexStack[ stackItem ] = macroLayerIndexStack[ stackItem + 1 ];
    4fb8:	4818      	ldr	r0, [pc, #96]	; (501c <Macro_layerState+0xb8>)
    4fba:	1c4a      	adds	r2, r1, #1
    4fbc:	f830 5012 	ldrh.w	r5, [r0, r2, lsl #1]
    4fc0:	f820 5011 	strh.w	r5, [r0, r1, lsl #1]
			stackItem++;
    4fc4:	b291      	uxth	r1, r2
    4fc6:	e7f5      	b.n	4fb4 <Macro_layerState+0x50>
		}

		// Reduce LayerIndexStack size
		macroLayerIndexStackSize--;
    4fc8:	3b01      	subs	r3, #1
    4fca:	8023      	strh	r3, [r4, #0]
	}

	// Layer Debug Mode
	if ( layerDebugMode )
    4fcc:	4b15      	ldr	r3, [pc, #84]	; (5024 <Macro_layerState+0xc0>)
    4fce:	781b      	ldrb	r3, [r3, #0]
    4fd0:	b303      	cbz	r3, 5014 <Macro_layerState+0xb0>
	{
		dbug_msg("Layer ");
    4fd2:	4815      	ldr	r0, [pc, #84]	; (5028 <Macro_layerState+0xc4>)
    4fd4:	f002 fc16 	bl	7804 <_print>
    4fd8:	2500      	movs	r5, #0

		// Iterate over each of the layers displaying the state as a hex value
		for ( uint16_t index = 0; index < LayerNum; index++ )
		{
			printHex_op( LayerState[ index ], 0 );
    4fda:	5d70      	ldrb	r0, [r6, r5]
    4fdc:	2100      	movs	r1, #0
    4fde:	3501      	adds	r5, #1
    4fe0:	f002 fc99 	bl	7916 <printHex_op>
	if ( layerDebugMode )
	{
		dbug_msg("Layer ");

		// Iterate over each of the layers displaying the state as a hex value
		for ( uint16_t index = 0; index < LayerNum; index++ )
    4fe4:	2d04      	cmp	r5, #4
    4fe6:	d1f8      	bne.n	4fda <Macro_layerState+0x76>
		{
			printHex_op( LayerState[ index ], 0 );
		}

		// Always show the default layer (it's always 0)
		print(" 0");
    4fe8:	4810      	ldr	r0, [pc, #64]	; (502c <Macro_layerState+0xc8>)
    4fea:	f002 fc0b 	bl	7804 <_print>

		// Iterate over the layer stack starting from the bottom of the stack
		for ( uint16_t index = macroLayerIndexStackSize; index > 0; index-- )
    4fee:	8824      	ldrh	r4, [r4, #0]
    4ff0:	b15c      	cbz	r4, 500a <Macro_layerState+0xa6>
		{
			print(":");
    4ff2:	480f      	ldr	r0, [pc, #60]	; (5030 <Macro_layerState+0xcc>)
    4ff4:	f002 fc06 	bl	7804 <_print>
			printHex_op( macroLayerIndexStack[ index - 1 ], 0 );
    4ff8:	3c01      	subs	r4, #1
    4ffa:	4b08      	ldr	r3, [pc, #32]	; (501c <Macro_layerState+0xb8>)
    4ffc:	2100      	movs	r1, #0
    4ffe:	f833 0014 	ldrh.w	r0, [r3, r4, lsl #1]
    5002:	f002 fc88 	bl	7916 <printHex_op>

		// Always show the default layer (it's always 0)
		print(" 0");

		// Iterate over the layer stack starting from the bottom of the stack
		for ( uint16_t index = macroLayerIndexStackSize; index > 0; index-- )
    5006:	b2a4      	uxth	r4, r4
    5008:	e7f2      	b.n	4ff0 <Macro_layerState+0x8c>
		{
			print(":");
			printHex_op( macroLayerIndexStack[ index - 1 ], 0 );
		}

		print( NL );
    500a:	480a      	ldr	r0, [pc, #40]	; (5034 <Macro_layerState+0xd0>)
	}
}
    500c:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
		{
			print(":");
			printHex_op( macroLayerIndexStack[ index - 1 ], 0 );
		}

		print( NL );
    5010:	f002 bbf8 	b.w	7804 <_print>
    5014:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    5016:	bf00      	nop
    5018:	1fff92dc 	.word	0x1fff92dc
    501c:	1fff93fa 	.word	0x1fff93fa
    5020:	1fffa399 	.word	0x1fffa399
    5024:	1fff9408 	.word	0x1fff9408
    5028:	00009727 	.word	0x00009727
    502c:	00009741 	.word	0x00009741
    5030:	000081eb 	.word	0x000081eb
    5034:	0000bafb 	.word	0x0000bafb

00005038 <Macro_layerState_capability>:
// Argument #1: Layer Index -> uint16_t
// Argument #2: Layer State -> uint8_t
void Macro_layerState_capability( uint8_t state, uint8_t stateType, uint8_t *args )
{
	// Display capability name
	if ( stateType == 0xFF && state == 0xFF )
    5038:	29ff      	cmp	r1, #255	; 0xff

// Modifies the specified Layer control byte
// Argument #1: Layer Index -> uint16_t
// Argument #2: Layer State -> uint8_t
void Macro_layerState_capability( uint8_t state, uint8_t stateType, uint8_t *args )
{
    503a:	4613      	mov	r3, r2
	// Display capability name
	if ( stateType == 0xFF && state == 0xFF )
    503c:	d104      	bne.n	5048 <Macro_layerState_capability+0x10>
    503e:	28ff      	cmp	r0, #255	; 0xff
    5040:	d105      	bne.n	504e <Macro_layerState_capability+0x16>
	{
		print("Macro_layerState(layerIndex,layerState)");
    5042:	4805      	ldr	r0, [pc, #20]	; (5058 <Macro_layerState_capability+0x20>)
    5044:	f002 bbde 	b.w	7804 <_print>
	}

	// Only use capability on press or release
	// TODO Analog
	// XXX This may cause issues, might be better to implement state table here to decide -HaaTa
	if ( stateType == 0x00 && state == 0x02 ) // Hold condition
    5048:	b909      	cbnz	r1, 504e <Macro_layerState_capability+0x16>
    504a:	2802      	cmp	r0, #2
    504c:	d003      	beq.n	5056 <Macro_layerState_capability+0x1e>
	uint16_t layer = *(uint16_t*)(&args[0]);

	// Get layer toggle byte
	uint8_t layerState = args[ sizeof(uint16_t) ];

	Macro_layerState( state, stateType, layer, layerState );
    504e:	881a      	ldrh	r2, [r3, #0]
    5050:	789b      	ldrb	r3, [r3, #2]
    5052:	f7ff bf87 	b.w	4f64 <Macro_layerState>
    5056:	4770      	bx	lr
    5058:	00009744 	.word	0x00009744

0000505c <Macro_layerLatch_capability>:
// Latches given layer
// Argument #1: Layer Index -> uint16_t
void Macro_layerLatch_capability( uint8_t state, uint8_t stateType, uint8_t *args )
{
	// Display capability name
	if ( stateType == 0xFF && state == 0xFF )
    505c:	29ff      	cmp	r1, #255	; 0xff
    505e:	d104      	bne.n	506a <Macro_layerLatch_capability+0xe>
    5060:	28ff      	cmp	r0, #255	; 0xff
    5062:	d105      	bne.n	5070 <Macro_layerLatch_capability+0x14>
	{
		print("Macro_layerLatch(layerIndex)");
    5064:	4805      	ldr	r0, [pc, #20]	; (507c <Macro_layerLatch_capability+0x20>)
    5066:	f002 bbcd 	b.w	7804 <_print>
		return;
	}

	// Only use capability on press
	// TODO Analog
	if ( stateType == 0x00 && state != 0x03 ) // Only on release
    506a:	b909      	cbnz	r1, 5070 <Macro_layerLatch_capability+0x14>
    506c:	2803      	cmp	r0, #3
    506e:	d103      	bne.n	5078 <Macro_layerLatch_capability+0x1c>

	// Get layer index from arguments
	// Cast pointer to uint8_t to uint16_t then access that memory location
	uint16_t layer = *(uint16_t*)(&args[0]);

	Macro_layerState( state, stateType, layer, 0x02 );
    5070:	8812      	ldrh	r2, [r2, #0]
    5072:	2302      	movs	r3, #2
    5074:	f7ff bf76 	b.w	4f64 <Macro_layerState>
    5078:	4770      	bx	lr
    507a:	bf00      	nop
    507c:	0000976c 	.word	0x0000976c

00005080 <Macro_layerLock_capability>:
// Locks given layer
// Argument #1: Layer Index -> uint16_t
void Macro_layerLock_capability( uint8_t state, uint8_t stateType, uint8_t *args )
{
	// Display capability name
	if ( stateType == 0xFF && state == 0xFF )
    5080:	29ff      	cmp	r1, #255	; 0xff
    5082:	d104      	bne.n	508e <Macro_layerLock_capability+0xe>
    5084:	28ff      	cmp	r0, #255	; 0xff
    5086:	d105      	bne.n	5094 <Macro_layerLock_capability+0x14>
	{
		print("Macro_layerLock(layerIndex)");
    5088:	4805      	ldr	r0, [pc, #20]	; (50a0 <Macro_layerLock_capability+0x20>)
    508a:	f002 bbbb 	b.w	7804 <_print>
	}

	// Only use capability on press
	// TODO Analog
	// XXX Could also be on release, but that's sorta dumb -HaaTa
	if ( stateType == 0x00 && state != 0x01 ) // All normal key conditions except press
    508e:	b909      	cbnz	r1, 5094 <Macro_layerLock_capability+0x14>
    5090:	2801      	cmp	r0, #1
    5092:	d103      	bne.n	509c <Macro_layerLock_capability+0x1c>

	// Get layer index from arguments
	// Cast pointer to uint8_t to uint16_t then access that memory location
	uint16_t layer = *(uint16_t*)(&args[0]);

	Macro_layerState( state, stateType, layer, 0x04 );
    5094:	8812      	ldrh	r2, [r2, #0]
    5096:	2304      	movs	r3, #4
    5098:	f7ff bf64 	b.w	4f64 <Macro_layerState>
    509c:	4770      	bx	lr
    509e:	bf00      	nop
    50a0:	00009789 	.word	0x00009789

000050a4 <Macro_layerShift_capability>:
// Shifts given layer
// Argument #1: Layer Index -> uint16_t
void Macro_layerShift_capability( uint8_t state, uint8_t stateType, uint8_t *args )
{
	// Display capability name
	if ( stateType == 0xFF && state == 0xFF )
    50a4:	29ff      	cmp	r1, #255	; 0xff
    50a6:	d104      	bne.n	50b2 <Macro_layerShift_capability+0xe>
    50a8:	28ff      	cmp	r0, #255	; 0xff
    50aa:	d106      	bne.n	50ba <Macro_layerShift_capability+0x16>
	{
		print("Macro_layerShift(layerIndex)");
    50ac:	4805      	ldr	r0, [pc, #20]	; (50c4 <Macro_layerShift_capability+0x20>)
    50ae:	f002 bba9 	b.w	7804 <_print>
		return;
	}

	// Only use capability on press or release
	// TODO Analog
	if ( stateType == 0x00 && ( state == 0x00 || state == 0x02 ) ) // Only pass press or release conditions
    50b2:	b911      	cbnz	r1, 50ba <Macro_layerShift_capability+0x16>
    50b4:	f010 0ffd 	tst.w	r0, #253	; 0xfd
    50b8:	d003      	beq.n	50c2 <Macro_layerShift_capability+0x1e>

	// Get layer index from arguments
	// Cast pointer to uint8_t to uint16_t then access that memory location
	uint16_t layer = *(uint16_t*)(&args[0]);

	Macro_layerState( state, stateType, layer, 0x01 );
    50ba:	8812      	ldrh	r2, [r2, #0]
    50bc:	2301      	movs	r3, #1
    50be:	f7ff bf51 	b.w	4f64 <Macro_layerState>
    50c2:	4770      	bx	lr
    50c4:	000097a5 	.word	0x000097a5

000050c8 <Macro_layerRotate_capability>:
// Layers are still evaluated using the layer stack
uint16_t Macro_rotationLayer;
void Macro_layerRotate_capability( uint8_t state, uint8_t stateType, uint8_t *args )
{
	// Display capability name
	if ( stateType == 0xFF && state == 0xFF )
    50c8:	29ff      	cmp	r1, #255	; 0xff
// Rotate layer to next/previous
// Uses state variable to keep track of the current layer position
// Layers are still evaluated using the layer stack
uint16_t Macro_rotationLayer;
void Macro_layerRotate_capability( uint8_t state, uint8_t stateType, uint8_t *args )
{
    50ca:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    50ce:	4606      	mov	r6, r0
    50d0:	460d      	mov	r5, r1
    50d2:	4617      	mov	r7, r2
	// Display capability name
	if ( stateType == 0xFF && state == 0xFF )
    50d4:	d106      	bne.n	50e4 <Macro_layerRotate_capability+0x1c>
    50d6:	28ff      	cmp	r0, #255	; 0xff
    50d8:	d107      	bne.n	50ea <Macro_layerRotate_capability+0x22>
	{
		print("Macro_layerRotate(previous)");
    50da:	4817      	ldr	r0, [pc, #92]	; (5138 <Macro_layerRotate_capability+0x70>)
			Macro_rotationLayer = LayerNum - 1;
	}

	// Toggle the computed layer rotation
	Macro_layerState( state, stateType, Macro_rotationLayer, 0x04 );
}
    50dc:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
void Macro_layerRotate_capability( uint8_t state, uint8_t stateType, uint8_t *args )
{
	// Display capability name
	if ( stateType == 0xFF && state == 0xFF )
	{
		print("Macro_layerRotate(previous)");
    50e0:	f002 bb90 	b.w	7804 <_print>
	}

	// Only use capability on press
	// TODO Analog
	// XXX Could also be on release, but that's sorta dumb -HaaTa
	if ( stateType == 0x00 && state != 0x01 ) // All normal key conditions except press
    50e4:	b909      	cbnz	r1, 50ea <Macro_layerRotate_capability+0x22>
    50e6:	2801      	cmp	r0, #1
    50e8:	d123      	bne.n	5132 <Macro_layerRotate_capability+0x6a>
		return;

	// Unset previous rotation layer if not 0
	if ( Macro_rotationLayer != 0 )
    50ea:	4c14      	ldr	r4, [pc, #80]	; (513c <Macro_layerRotate_capability+0x74>)
    50ec:	8822      	ldrh	r2, [r4, #0]
    50ee:	b122      	cbz	r2, 50fa <Macro_layerRotate_capability+0x32>
	{
		Macro_layerState( state, stateType, Macro_rotationLayer, 0x04 );
    50f0:	4630      	mov	r0, r6
    50f2:	4629      	mov	r1, r5
    50f4:	2304      	movs	r3, #4
    50f6:	f7ff ff35 	bl	4f64 <Macro_layerState>

	// Get direction of rotation, 0, next, non-zero previous
	uint8_t direction = *args;

	// Next
	if ( !direction )
    50fa:	783b      	ldrb	r3, [r7, #0]
    50fc:	b943      	cbnz	r3, 5110 <Macro_layerRotate_capability+0x48>
	{
		Macro_rotationLayer++;
    50fe:	8822      	ldrh	r2, [r4, #0]
    5100:	3201      	adds	r2, #1
    5102:	b292      	uxth	r2, r2

		// Invalid layer
		if ( Macro_rotationLayer >= LayerNum )
    5104:	2a03      	cmp	r2, #3
	uint8_t direction = *args;

	// Next
	if ( !direction )
	{
		Macro_rotationLayer++;
    5106:	8022      	strh	r2, [r4, #0]

		// Invalid layer
		if ( Macro_rotationLayer >= LayerNum )
    5108:	d90b      	bls.n	5122 <Macro_layerRotate_capability+0x5a>
			Macro_rotationLayer = 0;
    510a:	4a0c      	ldr	r2, [pc, #48]	; (513c <Macro_layerRotate_capability+0x74>)
    510c:	8013      	strh	r3, [r2, #0]
    510e:	e008      	b.n	5122 <Macro_layerRotate_capability+0x5a>
	}
	// Previous
	else
	{
		Macro_rotationLayer--;
    5110:	8823      	ldrh	r3, [r4, #0]
    5112:	3b01      	subs	r3, #1
    5114:	b29b      	uxth	r3, r3

		// Layer wrap
		if ( Macro_rotationLayer >= LayerNum )
    5116:	2b03      	cmp	r3, #3
			Macro_rotationLayer = 0;
	}
	// Previous
	else
	{
		Macro_rotationLayer--;
    5118:	8023      	strh	r3, [r4, #0]

		// Layer wrap
		if ( Macro_rotationLayer >= LayerNum )
    511a:	d902      	bls.n	5122 <Macro_layerRotate_capability+0x5a>
			Macro_rotationLayer = LayerNum - 1;
    511c:	4b07      	ldr	r3, [pc, #28]	; (513c <Macro_layerRotate_capability+0x74>)
    511e:	2203      	movs	r2, #3
    5120:	801a      	strh	r2, [r3, #0]
	}

	// Toggle the computed layer rotation
	Macro_layerState( state, stateType, Macro_rotationLayer, 0x04 );
    5122:	4630      	mov	r0, r6
    5124:	4629      	mov	r1, r5
    5126:	8822      	ldrh	r2, [r4, #0]
    5128:	2304      	movs	r3, #4
}
    512a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		if ( Macro_rotationLayer >= LayerNum )
			Macro_rotationLayer = LayerNum - 1;
	}

	// Toggle the computed layer rotation
	Macro_layerState( state, stateType, Macro_rotationLayer, 0x04 );
    512e:	f7ff bf19 	b.w	4f64 <Macro_layerState>
    5132:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    5136:	bf00      	nop
    5138:	000097c2 	.word	0x000097c2
    513c:	1fffa13c 	.word	0x1fffa13c

00005140 <Macro_layerLookup>:
// ----- Functions -----

// Looks up the trigger list for the given scan code (from the active layer)
// NOTE: Calling function must handle the NULL pointer case
nat_ptr_t *Macro_layerLookup( TriggerGuide *guide, uint8_t latch_expire )
{
    5140:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	uint8_t scanCode = guide->scanCode;

	// TODO Analog
	// If a normal key, and not pressed, do a layer cache lookup
	if ( guide->type == 0x00 && guide->state != 0x01 )
    5144:	7805      	ldrb	r5, [r0, #0]

// Looks up the trigger list for the given scan code (from the active layer)
// NOTE: Calling function must handle the NULL pointer case
nat_ptr_t *Macro_layerLookup( TriggerGuide *guide, uint8_t latch_expire )
{
	uint8_t scanCode = guide->scanCode;
    5146:	7884      	ldrb	r4, [r0, #2]
// ----- Functions -----

// Looks up the trigger list for the given scan code (from the active layer)
// NOTE: Calling function must handle the NULL pointer case
nat_ptr_t *Macro_layerLookup( TriggerGuide *guide, uint8_t latch_expire )
{
    5148:	460f      	mov	r7, r1
	uint8_t scanCode = guide->scanCode;

	// TODO Analog
	// If a normal key, and not pressed, do a layer cache lookup
	if ( guide->type == 0x00 && guide->state != 0x01 )
    514a:	b9f5      	cbnz	r5, 518a <Macro_layerLookup+0x4a>
    514c:	7843      	ldrb	r3, [r0, #1]
    514e:	2b01      	cmp	r3, #1
    5150:	d01b      	beq.n	518a <Macro_layerLookup+0x4a>
	{
		// Cached layer
		var_uint_t cachedLayer = macroTriggerListLayerCache[ scanCode ];
    5152:	4b3d      	ldr	r3, [pc, #244]	; (5248 <Macro_layerLookup+0x108>)

		// Lookup map, then layer
		nat_ptr_t **map = (nat_ptr_t**)LayerIndex[ cachedLayer ].triggerMap;
    5154:	493d      	ldr	r1, [pc, #244]	; (524c <Macro_layerLookup+0x10c>)
	// TODO Analog
	// If a normal key, and not pressed, do a layer cache lookup
	if ( guide->type == 0x00 && guide->state != 0x01 )
	{
		// Cached layer
		var_uint_t cachedLayer = macroTriggerListLayerCache[ scanCode ];
    5156:	5d1a      	ldrb	r2, [r3, r4]

		// Lookup map, then layer
		nat_ptr_t **map = (nat_ptr_t**)LayerIndex[ cachedLayer ].triggerMap;
    5158:	230c      	movs	r3, #12
    515a:	4353      	muls	r3, r2
    515c:	18c8      	adds	r0, r1, r3
		const Layer *layer = &LayerIndex[ cachedLayer ];

		// Cache trigger list before attempting to expire latch
		nat_ptr_t *trigger_list = map[ scanCode - layer->first ];
    515e:	58cb      	ldr	r3, [r1, r3]
    5160:	7a00      	ldrb	r0, [r0, #8]
    5162:	1a24      	subs	r4, r4, r0
    5164:	f853 4024 	ldr.w	r4, [r3, r4, lsl #2]

		// Check if latch has been pressed for this layer
		uint8_t latch = LayerState[ cachedLayer ] & 0x02;
    5168:	4b39      	ldr	r3, [pc, #228]	; (5250 <Macro_layerLookup+0x110>)
    516a:	5c9b      	ldrb	r3, [r3, r2]
		if ( latch && latch_expire )
    516c:	079b      	lsls	r3, r3, #30
    516e:	d568      	bpl.n	5242 <Macro_layerLookup+0x102>
    5170:	2f00      	cmp	r7, #0
    5172:	d066      	beq.n	5242 <Macro_layerLookup+0x102>
		{
			Macro_layerState( 0, 0, cachedLayer, 0x02 );
    5174:	4628      	mov	r0, r5
    5176:	4629      	mov	r1, r5
    5178:	2302      	movs	r3, #2
    517a:	f7ff fef3 	bl	4f64 <Macro_layerState>
#if defined(ConnectEnabled_define) && defined(LCDEnabled_define)
			// Evaluate the layerStack capability if available (LCD + Interconnect)
			extern void LCD_layerStack_capability( uint8_t state, uint8_t stateType, uint8_t *args );
			LCD_layerStack_capability( 0, 0, 0 );
    517e:	4628      	mov	r0, r5
    5180:	4629      	mov	r1, r5
    5182:	462a      	mov	r2, r5
    5184:	f7fe fbc0 	bl	3908 <LCD_layerStack_capability>
    5188:	e05b      	b.n	5242 <Macro_layerLookup+0x102>

		return trigger_list;
	}

	// If no trigger macro is defined at the given layer, fallthrough to the next layer
	for ( uint16_t layerIndex = macroLayerIndexStackSize; layerIndex != 0xFFFF; layerIndex-- )
    518a:	4b32      	ldr	r3, [pc, #200]	; (5254 <Macro_layerLookup+0x114>)
    518c:	881d      	ldrh	r5, [r3, #0]
    518e:	f64f 73ff 	movw	r3, #65535	; 0xffff
    5192:	429d      	cmp	r5, r3
    5194:	d03a      	beq.n	520c <Macro_layerLookup+0xcc>
	{
		// Lookup Layer
		const Layer *layer = &LayerIndex[ macroLayerIndexStack[ layerIndex ] ];
    5196:	f8df 90cc 	ldr.w	r9, [pc, #204]	; 5264 <Macro_layerLookup+0x124>

		// Check if latch has been pressed for this layer
		// XXX Regardless of whether a key is found, the latch is removed on first lookup
		uint8_t latch = LayerState[ macroLayerIndexStack[ layerIndex ] ] & 0x02;
    519a:	f8df 80b4 	ldr.w	r8, [pc, #180]	; 5250 <Macro_layerLookup+0x110>

	// If no trigger macro is defined at the given layer, fallthrough to the next layer
	for ( uint16_t layerIndex = macroLayerIndexStackSize; layerIndex != 0xFFFF; layerIndex-- )
	{
		// Lookup Layer
		const Layer *layer = &LayerIndex[ macroLayerIndexStack[ layerIndex ] ];
    519e:	f839 6015 	ldrh.w	r6, [r9, r5, lsl #1]

		// Check if latch has been pressed for this layer
		// XXX Regardless of whether a key is found, the latch is removed on first lookup
		uint8_t latch = LayerState[ macroLayerIndexStack[ layerIndex ] ] & 0x02;
    51a2:	f818 3006 	ldrb.w	r3, [r8, r6]
    51a6:	f003 0302 	and.w	r3, r3, #2
		if ( latch && latch_expire )
    51aa:	f003 0aff 	and.w	sl, r3, #255	; 0xff
    51ae:	b133      	cbz	r3, 51be <Macro_layerLookup+0x7e>
    51b0:	b12f      	cbz	r7, 51be <Macro_layerLookup+0x7e>
		{
			Macro_layerState( 0, 0, macroLayerIndexStack[ layerIndex ], 0x02 );
    51b2:	2000      	movs	r0, #0
    51b4:	4601      	mov	r1, r0
    51b6:	4632      	mov	r2, r6
    51b8:	2302      	movs	r3, #2
    51ba:	f7ff fed3 	bl	4f64 <Macro_layerState>
		}

		// Only use layer, if state is valid
		// XOR each of the state bits
		// If only two are enabled, do not use this state
		if ( (LayerState[ macroLayerIndexStack[ layerIndex ] ] & 0x01) ^ (latch>>1) ^ ((LayerState[ macroLayerIndexStack[ layerIndex ] ] & 0x04)>>2) )
    51be:	f839 2015 	ldrh.w	r2, [r9, r5, lsl #1]
    51c2:	f818 3002 	ldrb.w	r3, [r8, r2]
    51c6:	f003 0101 	and.w	r1, r3, #1
    51ca:	ea81 0a5a 	eor.w	sl, r1, sl, lsr #1
    51ce:	f3c3 0380 	ubfx	r3, r3, #2, #1
    51d2:	459a      	cmp	sl, r3
    51d4:	d017      	beq.n	5206 <Macro_layerLookup+0xc6>

	// If no trigger macro is defined at the given layer, fallthrough to the next layer
	for ( uint16_t layerIndex = macroLayerIndexStackSize; layerIndex != 0xFFFF; layerIndex-- )
	{
		// Lookup Layer
		const Layer *layer = &LayerIndex[ macroLayerIndexStack[ layerIndex ] ];
    51d6:	210c      	movs	r1, #12
    51d8:	4b1c      	ldr	r3, [pc, #112]	; (524c <Macro_layerLookup+0x10c>)
    51da:	434e      	muls	r6, r1
    51dc:	1999      	adds	r1, r3, r6
		// XOR each of the state bits
		// If only two are enabled, do not use this state
		if ( (LayerState[ macroLayerIndexStack[ layerIndex ] ] & 0x01) ^ (latch>>1) ^ ((LayerState[ macroLayerIndexStack[ layerIndex ] ] & 0x04)>>2) )
		{
			// Lookup layer
			nat_ptr_t **map = (nat_ptr_t**)layer->triggerMap;
    51de:	599b      	ldr	r3, [r3, r6]

			// Determine if layer has key defined
			// Make sure scanCode is between layer first and last scancodes
			if ( map != 0
    51e0:	b18b      	cbz	r3, 5206 <Macro_layerLookup+0xc6>
				&& scanCode <= layer->last
    51e2:	7a48      	ldrb	r0, [r1, #9]
    51e4:	42a0      	cmp	r0, r4
    51e6:	d30e      	bcc.n	5206 <Macro_layerLookup+0xc6>
				&& scanCode >= layer->first
    51e8:	7a09      	ldrb	r1, [r1, #8]
    51ea:	428c      	cmp	r4, r1
    51ec:	d30b      	bcc.n	5206 <Macro_layerLookup+0xc6>
				&& *map[ scanCode - layer->first ] != 0 )
    51ee:	1a61      	subs	r1, r4, r1
    51f0:	eb03 0081 	add.w	r0, r3, r1, lsl #2
    51f4:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
    51f8:	681b      	ldr	r3, [r3, #0]
    51fa:	b123      	cbz	r3, 5206 <Macro_layerLookup+0xc6>
			{
				// Set the layer cache
				macroTriggerListLayerCache[ scanCode ] = macroLayerIndexStack[ layerIndex ];
    51fc:	4b12      	ldr	r3, [pc, #72]	; (5248 <Macro_layerLookup+0x108>)
    51fe:	551a      	strb	r2, [r3, r4]

				return map[ scanCode - layer->first ];
    5200:	6800      	ldr	r0, [r0, #0]
    5202:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

		return trigger_list;
	}

	// If no trigger macro is defined at the given layer, fallthrough to the next layer
	for ( uint16_t layerIndex = macroLayerIndexStackSize; layerIndex != 0xFFFF; layerIndex-- )
    5206:	3d01      	subs	r5, #1
    5208:	b2ad      	uxth	r5, r5
    520a:	e7c0      	b.n	518e <Macro_layerLookup+0x4e>
	const Layer *layer = &LayerIndex[0];

	// Make sure scanCode is between layer first and last scancodes
	if ( map != 0
		&& scanCode <= layer->last
		&& scanCode >= layer->first
    520c:	1ea3      	subs	r3, r4, #2
    520e:	b2da      	uxtb	r2, r3
    5210:	2a57      	cmp	r2, #87	; 0x57
    5212:	d809      	bhi.n	5228 <Macro_layerLookup+0xe8>
		&& *map[ scanCode - layer->first ] != 0 )
    5214:	4a10      	ldr	r2, [pc, #64]	; (5258 <Macro_layerLookup+0x118>)
    5216:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
    521a:	6803      	ldr	r3, [r0, #0]
    521c:	b123      	cbz	r3, 5228 <Macro_layerLookup+0xe8>
	{
		// Set the layer cache to default map
		macroTriggerListLayerCache[ scanCode ] = 0;
    521e:	4b0a      	ldr	r3, [pc, #40]	; (5248 <Macro_layerLookup+0x108>)
    5220:	2200      	movs	r2, #0
    5222:	551a      	strb	r2, [r3, r4]

		return map[ scanCode - layer->first ];
    5224:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	}

	// Otherwise no defined Trigger Macro
	erro_msg("Scan Code has no defined Trigger Macro: ");
    5228:	480c      	ldr	r0, [pc, #48]	; (525c <Macro_layerLookup+0x11c>)
    522a:	f002 faeb 	bl	7804 <_print>
	printHex( scanCode );
    522e:	4620      	mov	r0, r4
    5230:	2101      	movs	r1, #1
    5232:	f002 fb70 	bl	7916 <printHex_op>
	print( NL );
    5236:	480a      	ldr	r0, [pc, #40]	; (5260 <Macro_layerLookup+0x120>)
    5238:	f002 fae4 	bl	7804 <_print>
	return 0;
    523c:	2000      	movs	r0, #0
    523e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
			extern void LCD_layerStack_capability( uint8_t state, uint8_t stateType, uint8_t *args );
			LCD_layerStack_capability( 0, 0, 0 );
#endif
		}

		return trigger_list;
    5242:	4620      	mov	r0, r4
	// Otherwise no defined Trigger Macro
	erro_msg("Scan Code has no defined Trigger Macro: ");
	printHex( scanCode );
	print( NL );
	return 0;
}
    5244:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    5248:	1fffa39d 	.word	0x1fffa39d
    524c:	0000ab84 	.word	0x0000ab84
    5250:	1fffa399 	.word	0x1fffa399
    5254:	1fff92dc 	.word	0x1fff92dc
    5258:	1fff8c04 	.word	0x1fff8c04
    525c:	000097de 	.word	0x000097de
    5260:	0000bafb 	.word	0x0000bafb
    5264:	1fff93fa 	.word	0x1fff93fa

00005268 <Macro_interconnectAdd>:

// Add an interconnect ScanCode
// These are handled differently (less information is sent, hold/off states must be assumed)
#if defined(ConnectEnabled_define)
inline void Macro_interconnectAdd( void *trigger_ptr )
{
    5268:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	TriggerGuide *trigger = (TriggerGuide*)trigger_ptr;

	// Error checking
	uint8_t error = 0;
	switch ( trigger->type )
    526a:	7803      	ldrb	r3, [r0, #0]

// Add an interconnect ScanCode
// These are handled differently (less information is sent, hold/off states must be assumed)
#if defined(ConnectEnabled_define)
inline void Macro_interconnectAdd( void *trigger_ptr )
{
    526c:	4604      	mov	r4, r0
	TriggerGuide *trigger = (TriggerGuide*)trigger_ptr;

	// Error checking
	uint8_t error = 0;
	switch ( trigger->type )
    526e:	b923      	cbnz	r3, 527a <Macro_interconnectAdd+0x12>
	{
	case 0x00: // Normal key
		switch ( trigger->state )
    5270:	7842      	ldrb	r2, [r0, #1]
    5272:	2a03      	cmp	r2, #3
    5274:	d905      	bls.n	5282 <Macro_interconnectAdd+0x1a>
		case 0x01:
		case 0x02:
		case 0x03:
			break;
		default:
			erro_msg("Invalid key state - ");
    5276:	4822      	ldr	r0, [pc, #136]	; (5300 <Macro_interconnectAdd+0x98>)
    5278:	e000      	b.n	527c <Macro_interconnectAdd+0x14>
		}
		break;

	// Invalid TriggerGuide type
	default:
		erro_msg("Invalid type - ");
    527a:	4822      	ldr	r0, [pc, #136]	; (5304 <Macro_interconnectAdd+0x9c>)
    527c:	f002 fac2 	bl	7804 <_print>
		error = 1;
    5280:	2301      	movs	r3, #1
		break;
	}

	// Check if ScanCode is out of range
	if ( trigger->scanCode > MaxScanCode )
    5282:	78a0      	ldrb	r0, [r4, #2]
    5284:	2859      	cmp	r0, #89	; 0x59
    5286:	d903      	bls.n	5290 <Macro_interconnectAdd+0x28>
	{
		warn_msg("ScanCode is out of range/not defined - ");
    5288:	481f      	ldr	r0, [pc, #124]	; (5308 <Macro_interconnectAdd+0xa0>)
    528a:	f002 fabb 	bl	7804 <_print>
    528e:	e004      	b.n	529a <Macro_interconnectAdd+0x32>
		error = 1;
	}

	// Display TriggerGuide
	if ( error )
    5290:	b91b      	cbnz	r3, 529a <Macro_interconnectAdd+0x32>
		return;
	}

	// Add trigger to the Interconnect Cache
	// During each processing loop, a scancode may be re-added depending on it's state
	for ( uint8_t c = 0; c < macroInterconnectCacheSize; c++ )
    5292:	4a1e      	ldr	r2, [pc, #120]	; (530c <Macro_interconnectAdd+0xa4>)
    5294:	7811      	ldrb	r1, [r2, #0]
    5296:	4616      	mov	r6, r2
    5298:	e016      	b.n	52c8 <Macro_interconnectAdd+0x60>
	}

	// Display TriggerGuide
	if ( error )
	{
		printHex( trigger->type );
    529a:	7820      	ldrb	r0, [r4, #0]
    529c:	2101      	movs	r1, #1
    529e:	f002 fb3a 	bl	7916 <printHex_op>
		print(" ");
    52a2:	481b      	ldr	r0, [pc, #108]	; (5310 <Macro_interconnectAdd+0xa8>)
    52a4:	f002 faae 	bl	7804 <_print>
		printHex( trigger->state );
    52a8:	7860      	ldrb	r0, [r4, #1]
    52aa:	2101      	movs	r1, #1
    52ac:	f002 fb33 	bl	7916 <printHex_op>
		print(" ");
    52b0:	4817      	ldr	r0, [pc, #92]	; (5310 <Macro_interconnectAdd+0xa8>)
    52b2:	f002 faa7 	bl	7804 <_print>
		printHex( trigger->scanCode );
    52b6:	78a0      	ldrb	r0, [r4, #2]
    52b8:	2101      	movs	r1, #1
    52ba:	f002 fb2c 	bl	7916 <printHex_op>
		print( NL );
    52be:	4815      	ldr	r0, [pc, #84]	; (5314 <Macro_interconnectAdd+0xac>)
		}
	}

	// If not in the list, add it
	macroInterconnectCache[ macroInterconnectCacheSize++ ] = *trigger;
}
    52c0:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
		printHex( trigger->type );
		print(" ");
		printHex( trigger->state );
		print(" ");
		printHex( trigger->scanCode );
		print( NL );
    52c4:	f002 ba9e 	b.w	7804 <_print>
		return;
	}

	// Add trigger to the Interconnect Cache
	// During each processing loop, a scancode may be re-added depending on it's state
	for ( uint8_t c = 0; c < macroInterconnectCacheSize; c++ )
    52c8:	b2da      	uxtb	r2, r3
    52ca:	428a      	cmp	r2, r1
    52cc:	4a12      	ldr	r2, [pc, #72]	; (5318 <Macro_interconnectAdd+0xb0>)
    52ce:	d20d      	bcs.n	52ec <Macro_interconnectAdd+0x84>
	{
		// Check if the same ScanCode
		if ( macroInterconnectCache[ c ].scanCode == trigger->scanCode )
    52d0:	461f      	mov	r7, r3
    52d2:	2503      	movs	r5, #3
    52d4:	3301      	adds	r3, #1
    52d6:	fb05 2c03 	mla	ip, r5, r3, r2
    52da:	f81c cc01 	ldrb.w	ip, [ip, #-1]
    52de:	4584      	cmp	ip, r0
    52e0:	d1f2      	bne.n	52c8 <Macro_interconnectAdd+0x60>
		{
			// Update the state
			macroInterconnectCache[ c ].state = trigger->state;
    52e2:	7863      	ldrb	r3, [r4, #1]
    52e4:	fb05 2207 	mla	r2, r5, r7, r2
    52e8:	7053      	strb	r3, [r2, #1]
			return;
    52ea:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		}
	}

	// If not in the list, add it
	macroInterconnectCache[ macroInterconnectCacheSize++ ] = *trigger;
    52ec:	1c4b      	adds	r3, r1, #1
    52ee:	7033      	strb	r3, [r6, #0]
    52f0:	2303      	movs	r3, #3
    52f2:	4359      	muls	r1, r3
    52f4:	8820      	ldrh	r0, [r4, #0]
    52f6:	5250      	strh	r0, [r2, r1]
    52f8:	1853      	adds	r3, r2, r1
    52fa:	78a2      	ldrb	r2, [r4, #2]
    52fc:	709a      	strb	r2, [r3, #2]
    52fe:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    5300:	0000981c 	.word	0x0000981c
    5304:	00009846 	.word	0x00009846
    5308:	0000986b 	.word	0x0000986b
    530c:	1fff9404 	.word	0x1fff9404
    5310:	00008156 	.word	0x00008156
    5314:	0000bafb 	.word	0x0000bafb
    5318:	1fffa3f6 	.word	0x1fffa3f6

0000531c <Macro_keyState>:
//   * 0x01 - Pressed
//   * 0x02 - Held
//   * 0x03 - Released
//   * 0x04 - Unpressed (this is currently ignored)
inline void Macro_keyState( uint8_t scanCode, uint8_t state )
{
    531c:	b570      	push	{r4, r5, r6, lr}
#if defined(ConnectEnabled_define)
	// Only compile in if a Connect node module is available
	if ( !Connect_master )
    531e:	4b12      	ldr	r3, [pc, #72]	; (5368 <Macro_keyState+0x4c>)
    5320:	781b      	ldrb	r3, [r3, #0]
//   * 0x01 - Pressed
//   * 0x02 - Held
//   * 0x03 - Released
//   * 0x04 - Unpressed (this is currently ignored)
inline void Macro_keyState( uint8_t scanCode, uint8_t state )
{
    5322:	4604      	mov	r4, r0
#if defined(ConnectEnabled_define)
	// Only compile in if a Connect node module is available
	if ( !Connect_master )
    5324:	b913      	cbnz	r3, 532c <Macro_keyState+0x10>
	{
		// ScanCodes are only added if there was a state change (on/off)
		switch ( state )
    5326:	b1f1      	cbz	r1, 5366 <Macro_keyState+0x4a>
    5328:	2902      	cmp	r1, #2
    532a:	d01c      	beq.n	5366 <Macro_keyState+0x4a>
		}
	}
#endif

	// Only add to macro trigger list if one of three states
	switch ( state )
    532c:	1e4b      	subs	r3, r1, #1
    532e:	2b02      	cmp	r3, #2
    5330:	d819      	bhi.n	5366 <Macro_keyState+0x4a>
	{
	case 0x01: // Pressed
	case 0x02: // Held
	case 0x03: // Released
		// Check if ScanCode is out of range
		if ( scanCode > MaxScanCode )
    5332:	2c59      	cmp	r4, #89	; 0x59
    5334:	d90b      	bls.n	534e <Macro_keyState+0x32>
		{
			warn_msg("ScanCode is out of range/not defined: ");
    5336:	480d      	ldr	r0, [pc, #52]	; (536c <Macro_keyState+0x50>)
    5338:	f002 fa64 	bl	7804 <_print>
			printHex( scanCode );
    533c:	4620      	mov	r0, r4
    533e:	2101      	movs	r1, #1
    5340:	f002 fae9 	bl	7916 <printHex_op>
			print( NL );
    5344:	480a      	ldr	r0, [pc, #40]	; (5370 <Macro_keyState+0x54>)
		macroTriggerListBuffer[ macroTriggerListBufferSize ].state    = state;
		macroTriggerListBuffer[ macroTriggerListBufferSize ].type     = 0x00; // Normal key
		macroTriggerListBufferSize++;
		break;
	}
}
    5346:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		// Check if ScanCode is out of range
		if ( scanCode > MaxScanCode )
		{
			warn_msg("ScanCode is out of range/not defined: ");
			printHex( scanCode );
			print( NL );
    534a:	f002 ba5b 	b.w	7804 <_print>
			return;
		}

		macroTriggerListBuffer[ macroTriggerListBufferSize ].scanCode = scanCode;
    534e:	4b09      	ldr	r3, [pc, #36]	; (5374 <Macro_keyState+0x58>)
    5350:	4d09      	ldr	r5, [pc, #36]	; (5378 <Macro_keyState+0x5c>)
    5352:	781a      	ldrb	r2, [r3, #0]
    5354:	2003      	movs	r0, #3
    5356:	4350      	muls	r0, r2
    5358:	182e      	adds	r6, r5, r0
		macroTriggerListBuffer[ macroTriggerListBufferSize ].state    = state;
		macroTriggerListBuffer[ macroTriggerListBufferSize ].type     = 0x00; // Normal key
		macroTriggerListBufferSize++;
    535a:	3201      	adds	r2, #1
			print( NL );
			return;
		}

		macroTriggerListBuffer[ macroTriggerListBufferSize ].scanCode = scanCode;
		macroTriggerListBuffer[ macroTriggerListBufferSize ].state    = state;
    535c:	7071      	strb	r1, [r6, #1]
		macroTriggerListBuffer[ macroTriggerListBufferSize ].type     = 0x00; // Normal key
    535e:	2100      	movs	r1, #0
			printHex( scanCode );
			print( NL );
			return;
		}

		macroTriggerListBuffer[ macroTriggerListBufferSize ].scanCode = scanCode;
    5360:	70b4      	strb	r4, [r6, #2]
		macroTriggerListBuffer[ macroTriggerListBufferSize ].state    = state;
		macroTriggerListBuffer[ macroTriggerListBufferSize ].type     = 0x00; // Normal key
    5362:	5429      	strb	r1, [r5, r0]
		macroTriggerListBufferSize++;
    5364:	701a      	strb	r2, [r3, #0]
    5366:	bd70      	pop	{r4, r5, r6, pc}
    5368:	1fff92d6 	.word	0x1fff92d6
    536c:	000098a8 	.word	0x000098a8
    5370:	0000bafb 	.word	0x0000bafb
    5374:	1fff92de 	.word	0x1fff92de
    5378:	1fffa13e 	.word	0x1fffa13e

0000537c <cliFunc_keyHold>:
		}
	}
}

void cliFunc_keyHold( char* args )
{
    537c:	b507      	push	{r0, r1, r2, lr}
	// Parse codes from arguments
	char* curArgs;
	char* arg1Ptr;
	char* arg2Ptr = args;
    537e:	9001      	str	r0, [sp, #4]

	// Process all args
	for ( ;; )
	{
		curArgs = arg2Ptr;
		CLI_argumentIsolation( curArgs, &arg1Ptr, &arg2Ptr );
    5380:	9801      	ldr	r0, [sp, #4]
    5382:	4669      	mov	r1, sp
    5384:	aa01      	add	r2, sp, #4
    5386:	f001 ff8b 	bl	72a0 <CLI_argumentIsolation>

		// Stop processing args if no more are found
		if ( *arg1Ptr == '\0' )
    538a:	9800      	ldr	r0, [sp, #0]
    538c:	7803      	ldrb	r3, [r0, #0]
    538e:	b14b      	cbz	r3, 53a4 <cliFunc_keyHold+0x28>
			break;

		// Ignore non-Scancode numbers
		switch ( arg1Ptr[0] )
    5390:	2b53      	cmp	r3, #83	; 0x53
    5392:	d1f5      	bne.n	5380 <cliFunc_keyHold+0x4>
		{
		// Scancode
		case 'S':
			Macro_keyState( (uint8_t)numToInt( &arg1Ptr[1] ), 0x02 ); // Hold scancode
    5394:	3001      	adds	r0, #1
    5396:	f002 fb13 	bl	79c0 <numToInt>
    539a:	2102      	movs	r1, #2
    539c:	b2c0      	uxtb	r0, r0
    539e:	f7ff ffbd 	bl	531c <Macro_keyState>
			break;
    53a2:	e7ed      	b.n	5380 <cliFunc_keyHold+0x4>
		}
	}
}
    53a4:	b003      	add	sp, #12
    53a6:	f85d fb04 	ldr.w	pc, [sp], #4

000053aa <cliFunc_keyPress>:

void cliFunc_keyPress( char* args )
{
    53aa:	b507      	push	{r0, r1, r2, lr}
	// Parse codes from arguments
	char* curArgs;
	char* arg1Ptr;
	char* arg2Ptr = args;
    53ac:	9001      	str	r0, [sp, #4]

	// Process all args
	for ( ;; )
	{
		curArgs = arg2Ptr;
		CLI_argumentIsolation( curArgs, &arg1Ptr, &arg2Ptr );
    53ae:	9801      	ldr	r0, [sp, #4]
    53b0:	4669      	mov	r1, sp
    53b2:	aa01      	add	r2, sp, #4
    53b4:	f001 ff74 	bl	72a0 <CLI_argumentIsolation>

		// Stop processing args if no more are found
		if ( *arg1Ptr == '\0' )
    53b8:	9800      	ldr	r0, [sp, #0]
    53ba:	7803      	ldrb	r3, [r0, #0]
    53bc:	b14b      	cbz	r3, 53d2 <cliFunc_keyPress+0x28>
			break;

		// Ignore non-Scancode numbers
		switch ( arg1Ptr[0] )
    53be:	2b53      	cmp	r3, #83	; 0x53
    53c0:	d1f5      	bne.n	53ae <cliFunc_keyPress+0x4>
		{
		// Scancode
		case 'S':
			Macro_keyState( (uint8_t)numToInt( &arg1Ptr[1] ), 0x01 ); // Press scancode
    53c2:	3001      	adds	r0, #1
    53c4:	f002 fafc 	bl	79c0 <numToInt>
    53c8:	2101      	movs	r1, #1
    53ca:	b2c0      	uxtb	r0, r0
    53cc:	f7ff ffa6 	bl	531c <Macro_keyState>
			break;
    53d0:	e7ed      	b.n	53ae <cliFunc_keyPress+0x4>
		}
	}
}
    53d2:	b003      	add	sp, #12
    53d4:	f85d fb04 	ldr.w	pc, [sp], #4

000053d8 <cliFunc_keyRelease>:

void cliFunc_keyRelease( char* args )
{
    53d8:	b507      	push	{r0, r1, r2, lr}
	// Parse codes from arguments
	char* curArgs;
	char* arg1Ptr;
	char* arg2Ptr = args;
    53da:	9001      	str	r0, [sp, #4]

	// Process all args
	for ( ;; )
	{
		curArgs = arg2Ptr;
		CLI_argumentIsolation( curArgs, &arg1Ptr, &arg2Ptr );
    53dc:	9801      	ldr	r0, [sp, #4]
    53de:	4669      	mov	r1, sp
    53e0:	aa01      	add	r2, sp, #4
    53e2:	f001 ff5d 	bl	72a0 <CLI_argumentIsolation>

		// Stop processing args if no more are found
		if ( *arg1Ptr == '\0' )
    53e6:	9800      	ldr	r0, [sp, #0]
    53e8:	7803      	ldrb	r3, [r0, #0]
    53ea:	b14b      	cbz	r3, 5400 <cliFunc_keyRelease+0x28>
			break;

		// Ignore non-Scancode numbers
		switch ( arg1Ptr[0] )
    53ec:	2b53      	cmp	r3, #83	; 0x53
    53ee:	d1f5      	bne.n	53dc <cliFunc_keyRelease+0x4>
		{
		// Scancode
		case 'S':
			Macro_keyState( (uint8_t)numToInt( &arg1Ptr[1] ), 0x03 ); // Release scancode
    53f0:	3001      	adds	r0, #1
    53f2:	f002 fae5 	bl	79c0 <numToInt>
    53f6:	2103      	movs	r1, #3
    53f8:	b2c0      	uxtb	r0, r0
    53fa:	f7ff ff8f 	bl	531c <Macro_keyState>
			break;
    53fe:	e7ed      	b.n	53dc <cliFunc_keyRelease+0x4>
		}
	}
}
    5400:	b003      	add	sp, #12
    5402:	f85d fb04 	ldr.w	pc, [sp], #4
    5406:	0000      	movs	r0, r0

00005408 <Macro_evalTriggerMacro>:
}


// Evaluate/Update TriggerMacro
TriggerMacroEval Macro_evalTriggerMacro( var_uint_t triggerMacroIndex )
{
    5408:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	// Lookup TriggerMacro
	const TriggerMacro *macro = &TriggerMacroList[ triggerMacroIndex ];
	TriggerMacroRecord *record = &TriggerMacroRecordList[ triggerMacroIndex ];
    540c:	f8df 8234 	ldr.w	r8, [pc, #564]	; 5644 <Macro_evalTriggerMacro+0x23c>

// Evaluate/Update TriggerMacro
TriggerMacroEval Macro_evalTriggerMacro( var_uint_t triggerMacroIndex )
{
	// Lookup TriggerMacro
	const TriggerMacro *macro = &TriggerMacroList[ triggerMacroIndex ];
    5410:	4f84      	ldr	r7, [pc, #528]	; (5624 <Macro_evalTriggerMacro+0x21c>)
	TriggerMacroRecord *record = &TriggerMacroRecordList[ triggerMacroIndex ];
    5412:	eb08 0640 	add.w	r6, r8, r0, lsl #1
}


// Evaluate/Update TriggerMacro
TriggerMacroEval Macro_evalTriggerMacro( var_uint_t triggerMacroIndex )
{
    5416:	b087      	sub	sp, #28
	// Lookup TriggerMacro
	const TriggerMacro *macro = &TriggerMacroList[ triggerMacroIndex ];
	TriggerMacroRecord *record = &TriggerMacroRecordList[ triggerMacroIndex ];

	// Check if macro has finished and should be incremented sequence elements
	if ( record->state == TriggerMacro_Release )
    5418:	7872      	ldrb	r2, [r6, #1]

// Evaluate/Update TriggerMacro
TriggerMacroEval Macro_evalTriggerMacro( var_uint_t triggerMacroIndex )
{
	// Lookup TriggerMacro
	const TriggerMacro *macro = &TriggerMacroList[ triggerMacroIndex ];
    541a:	eb07 03c0 	add.w	r3, r7, r0, lsl #3
	TriggerMacroRecord *record = &TriggerMacroRecordList[ triggerMacroIndex ];

	// Check if macro has finished and should be incremented sequence elements
	if ( record->state == TriggerMacro_Release )
    541e:	2a01      	cmp	r2, #1
}


// Evaluate/Update TriggerMacro
TriggerMacroEval Macro_evalTriggerMacro( var_uint_t triggerMacroIndex )
{
    5420:	4682      	mov	sl, r0
	// Lookup TriggerMacro
	const TriggerMacro *macro = &TriggerMacroList[ triggerMacroIndex ];
    5422:	9303      	str	r3, [sp, #12]
	TriggerMacroRecord *record = &TriggerMacroRecordList[ triggerMacroIndex ];

	// Check if macro has finished and should be incremented sequence elements
	if ( record->state == TriggerMacro_Release )
    5424:	d10c      	bne.n	5440 <Macro_evalTriggerMacro+0x38>
	{
		record->state = TriggerMacro_Waiting;
    5426:	2202      	movs	r2, #2
    5428:	7072      	strb	r2, [r6, #1]
		record->pos = record->pos + macro->guide[ record->pos ] * TriggerGuideSize + 1;
    542a:	f857 103a 	ldr.w	r1, [r7, sl, lsl #3]
    542e:	f818 2010 	ldrb.w	r2, [r8, r0, lsl #1]
    5432:	1c50      	adds	r0, r2, #1
    5434:	5c8a      	ldrb	r2, [r1, r2]
    5436:	2103      	movs	r1, #3
    5438:	fb01 0202 	mla	r2, r1, r2, r0
    543c:	f808 201a 	strb.w	r2, [r8, sl, lsl #1]
	}

	// Current Macro position
	var_uint_t pos = record->pos;
    5440:	f818 301a 	ldrb.w	r3, [r8, sl, lsl #1]

	// Length of the combo being processed
	uint8_t comboLength = macro->guide[ pos ] * TriggerGuideSize;
    5444:	f857 203a 	ldr.w	r2, [r7, sl, lsl #3]
		record->state = TriggerMacro_Waiting;
		record->pos = record->pos + macro->guide[ record->pos ] * TriggerGuideSize + 1;
	}

	// Current Macro position
	var_uint_t pos = record->pos;
    5448:	9301      	str	r3, [sp, #4]

	// Length of the combo being processed
	uint8_t comboLength = macro->guide[ pos ] * TriggerGuideSize;
    544a:	5cd0      	ldrb	r0, [r2, r3]
    544c:	2103      	movs	r1, #3
    544e:	4348      	muls	r0, r1

	// If no combo items are left, remove the TriggerMacro from the pending list
	if ( comboLength == 0 )
    5450:	f010 00ff 	ands.w	r0, r0, #255	; 0xff
    5454:	9004      	str	r0, [sp, #16]
    5456:	d101      	bne.n	545c <Macro_evalTriggerMacro+0x54>
	{
		return TriggerMacroEval_Remove;
    5458:	2003      	movs	r0, #3
    545a:	e0df      	b.n	561c <Macro_evalTriggerMacro+0x214>
inline uint8_t Macro_isLongTriggerMacro( const TriggerMacro *macro )
{
	// Check the second sequence combo length
	// If non-zero return non-zero (long sequence)
	// 0 otherwise (short sequence)
	return macro->guide[ macro->guide[0] * TriggerGuideSize + 1 ];
    545c:	7810      	ldrb	r0, [r2, #0]
	// TODO Add support for system LED states (NumLock, CapsLock, etc.)
	// TODO Add support for analog key states
	// TODO Add support for 0x00 Key state (not pressing a key, not all that useful in general)
	// TODO Add support for Press/Hold/Release differentiation when evaluating (not sure if useful)
	TriggerMacroVote overallVote = TriggerMacroVote_Invalid;
	for ( uint8_t comboItem = pos + 1; comboItem < pos + comboLength + 1; comboItem += TriggerGuideSize )
    545e:	9b01      	ldr	r3, [sp, #4]
inline uint8_t Macro_isLongTriggerMacro( const TriggerMacro *macro )
{
	// Check the second sequence combo length
	// If non-zero return non-zero (long sequence)
	// 0 otherwise (short sequence)
	return macro->guide[ macro->guide[0] * TriggerGuideSize + 1 ];
    5460:	fb01 2200 	mla	r2, r1, r0, r2
	// TODO Add support for system LED states (NumLock, CapsLock, etc.)
	// TODO Add support for analog key states
	// TODO Add support for 0x00 Key state (not pressing a key, not all that useful in general)
	// TODO Add support for Press/Hold/Release differentiation when evaluating (not sure if useful)
	TriggerMacroVote overallVote = TriggerMacroVote_Invalid;
	for ( uint8_t comboItem = pos + 1; comboItem < pos + comboLength + 1; comboItem += TriggerGuideSize )
    5464:	f103 0b01 	add.w	fp, r3, #1
inline uint8_t Macro_isLongTriggerMacro( const TriggerMacro *macro )
{
	// Check the second sequence combo length
	// If non-zero return non-zero (long sequence)
	// 0 otherwise (short sequence)
	return macro->guide[ macro->guide[0] * TriggerGuideSize + 1 ];
    5468:	7855      	ldrb	r5, [r2, #1]
	// TODO Add support for system LED states (NumLock, CapsLock, etc.)
	// TODO Add support for analog key states
	// TODO Add support for 0x00 Key state (not pressing a key, not all that useful in general)
	// TODO Add support for Press/Hold/Release differentiation when evaluating (not sure if useful)
	TriggerMacroVote overallVote = TriggerMacroVote_Invalid;
	for ( uint8_t comboItem = pos + 1; comboItem < pos + comboLength + 1; comboItem += TriggerGuideSize )
    546a:	fa5f fb8b 	uxtb.w	fp, fp
	// On scan after position increment, change to TriggerMacro_Waiting state
	// TODO Add support for system LED states (NumLock, CapsLock, etc.)
	// TODO Add support for analog key states
	// TODO Add support for 0x00 Key state (not pressing a key, not all that useful in general)
	// TODO Add support for Press/Hold/Release differentiation when evaluating (not sure if useful)
	TriggerMacroVote overallVote = TriggerMacroVote_Invalid;
    546e:	2400      	movs	r4, #0
	for ( uint8_t comboItem = pos + 1; comboItem < pos + comboLength + 1; comboItem += TriggerGuideSize )
    5470:	9901      	ldr	r1, [sp, #4]
    5472:	9b04      	ldr	r3, [sp, #16]
    5474:	4419      	add	r1, r3
    5476:	4559      	cmp	r1, fp
    5478:	db74      	blt.n	5564 <Macro_evalTriggerMacro+0x15c>
	{
		// Assign TriggerGuide element (key type, state and scancode)
		TriggerGuide *guide = (TriggerGuide*)(&macro->guide[ comboItem ]);
    547a:	9b03      	ldr	r3, [sp, #12]
    547c:	681a      	ldr	r2, [r3, #0]

		TriggerMacroVote vote = TriggerMacroVote_Invalid;
		// Iterate through the key buffer, comparing to each key in the combo
		for ( uint8_t key = 0; key < macroTriggerListBufferSize; key++ )
    547e:	f04f 0900 	mov.w	r9, #0
	// TODO Add support for Press/Hold/Release differentiation when evaluating (not sure if useful)
	TriggerMacroVote overallVote = TriggerMacroVote_Invalid;
	for ( uint8_t comboItem = pos + 1; comboItem < pos + comboLength + 1; comboItem += TriggerGuideSize )
	{
		// Assign TriggerGuide element (key type, state and scancode)
		TriggerGuide *guide = (TriggerGuide*)(&macro->guide[ comboItem ]);
    5482:	445a      	add	r2, fp
    5484:	9202      	str	r2, [sp, #8]

		TriggerMacroVote vote = TriggerMacroVote_Invalid;
    5486:	464a      	mov	r2, r9
		// Iterate through the key buffer, comparing to each key in the combo
		for ( uint8_t key = 0; key < macroTriggerListBufferSize; key++ )
    5488:	4967      	ldr	r1, [pc, #412]	; (5628 <Macro_evalTriggerMacro+0x220>)
    548a:	7809      	ldrb	r1, [r1, #0]
    548c:	4549      	cmp	r1, r9
    548e:	d95e      	bls.n	554e <Macro_evalTriggerMacro+0x146>
		{
			// Lookup key information
			TriggerGuide *keyInfo = &macroTriggerListBuffer[ key ];
    5490:	4966      	ldr	r1, [pc, #408]	; (562c <Macro_evalTriggerMacro+0x224>)
    5492:	9b02      	ldr	r3, [sp, #8]

			// If vote is a pass (>= 0x08, no more keys in the combo need to be looked at)
			// Also mask all of the non-passing votes
			vote |= longMacro
    5494:	b2d2      	uxtb	r2, r2
		TriggerMacroVote vote = TriggerMacroVote_Invalid;
		// Iterate through the key buffer, comparing to each key in the combo
		for ( uint8_t key = 0; key < macroTriggerListBufferSize; key++ )
		{
			// Lookup key information
			TriggerGuide *keyInfo = &macroTriggerListBuffer[ key ];
    5496:	2003      	movs	r0, #3

			// If vote is a pass (>= 0x08, no more keys in the combo need to be looked at)
			// Also mask all of the non-passing votes
			vote |= longMacro
    5498:	9205      	str	r2, [sp, #20]
		TriggerMacroVote vote = TriggerMacroVote_Invalid;
		// Iterate through the key buffer, comparing to each key in the combo
		for ( uint8_t key = 0; key < macroTriggerListBufferSize; key++ )
		{
			// Lookup key information
			TriggerGuide *keyInfo = &macroTriggerListBuffer[ key ];
    549a:	fb00 1109 	mla	r1, r0, r9, r1
    549e:	781a      	ldrb	r2, [r3, #0]

			// If vote is a pass (>= 0x08, no more keys in the combo need to be looked at)
			// Also mask all of the non-passing votes
			vote |= longMacro
    54a0:	b335      	cbz	r5, 54f0 <Macro_evalTriggerMacro+0xe8>
// Votes on the given key vs. guide, long macros
// A long macro is defined as a guide with more than 1 combo
inline TriggerMacroVote Macro_evalLongTriggerMacroVote( TriggerGuide *key, TriggerGuide *guide )
{
	// Depending on key type
	switch ( guide->type )
    54a2:	2a01      	cmp	r2, #1
    54a4:	d01d      	beq.n	54e2 <Macro_evalTriggerMacro+0xda>
    54a6:	d303      	bcc.n	54b0 <Macro_evalTriggerMacro+0xa8>
    54a8:	2a02      	cmp	r2, #2
    54aa:	d11c      	bne.n	54e6 <Macro_evalTriggerMacro+0xde>
		erro_print("LED State Type - Not implemented...");
		break;

	// Analog State Type
	case 0x02:
		erro_print("Analog State Type - Not implemented...");
    54ac:	4860      	ldr	r0, [pc, #384]	; (5630 <Macro_evalTriggerMacro+0x228>)
    54ae:	e01b      	b.n	54e8 <Macro_evalTriggerMacro+0xe0>
	{
	// Normal State Type
	case 0x00:
		// Depending on the state of the buffered key, make voting decision
		// Incorrect key
		if ( guide->scanCode != key->scanCode )
    54b0:	9b02      	ldr	r3, [sp, #8]
    54b2:	788a      	ldrb	r2, [r1, #2]
    54b4:	7898      	ldrb	r0, [r3, #2]
    54b6:	4290      	cmp	r0, r2
    54b8:	784a      	ldrb	r2, [r1, #1]
    54ba:	d009      	beq.n	54d0 <Macro_evalTriggerMacro+0xc8>
		{
			switch ( key->state )
    54bc:	2a02      	cmp	r2, #2
    54be:	d039      	beq.n	5534 <Macro_evalTriggerMacro+0x12c>
    54c0:	2a03      	cmp	r2, #3
    54c2:	d003      	beq.n	54cc <Macro_evalTriggerMacro+0xc4>
		erro_print("Invalid State Type. This is a bug.");
		break;
	}

	// XXX Shouldn't reach here
	return TriggerMacroVote_Invalid;
    54c4:	1e51      	subs	r1, r2, #1
    54c6:	424a      	negs	r2, r1
    54c8:	414a      	adcs	r2, r1
    54ca:	e033      	b.n	5534 <Macro_evalTriggerMacro+0x12c>
			case 0x02:
				return TriggerMacroVote_DoNothing;

			// Wrong key released, fail out if pos == 0
			case 0x03:
				return TriggerMacroVote_DoNothing | TriggerMacroVote_DoNothingRelease;
    54cc:	2206      	movs	r2, #6
    54ce:	e031      	b.n	5534 <Macro_evalTriggerMacro+0x12c>
		}

		// Correct key
		else
		{
			switch ( key->state )
    54d0:	2a02      	cmp	r2, #2
    54d2:	d02e      	beq.n	5532 <Macro_evalTriggerMacro+0x12a>
    54d4:	2a03      	cmp	r2, #3
    54d6:	d021      	beq.n	551c <Macro_evalTriggerMacro+0x114>
		erro_print("Invalid State Type. This is a bug.");
		break;
	}

	// XXX Shouldn't reach here
	return TriggerMacroVote_Invalid;
    54d8:	2a01      	cmp	r2, #1
    54da:	bf0c      	ite	eq
    54dc:	2208      	moveq	r2, #8
    54de:	2200      	movne	r2, #0
    54e0:	e028      	b.n	5534 <Macro_evalTriggerMacro+0x12c>

		break;

	// LED State Type
	case 0x01:
		erro_print("LED State Type - Not implemented...");
    54e2:	4854      	ldr	r0, [pc, #336]	; (5634 <Macro_evalTriggerMacro+0x22c>)
    54e4:	e000      	b.n	54e8 <Macro_evalTriggerMacro+0xe0>
		erro_print("Analog State Type - Not implemented...");
		break;

	// Invalid State Type
	default:
		erro_print("Invalid State Type. This is a bug.");
    54e6:	4854      	ldr	r0, [pc, #336]	; (5638 <Macro_evalTriggerMacro+0x230>)
    54e8:	f002 f98c 	bl	7804 <_print>
		break;
	}

	// XXX Shouldn't reach here
	return TriggerMacroVote_Invalid;
    54ec:	2200      	movs	r2, #0
    54ee:	e021      	b.n	5534 <Macro_evalTriggerMacro+0x12c>

// Votes on the given key vs. guide, short macros
inline TriggerMacroVote Macro_evalShortTriggerMacroVote( TriggerGuide *key, TriggerGuide *guide )
{
	// Depending on key type
	switch ( guide->type )
    54f0:	2a01      	cmp	r2, #1
    54f2:	d015      	beq.n	5520 <Macro_evalTriggerMacro+0x118>
    54f4:	d303      	bcc.n	54fe <Macro_evalTriggerMacro+0xf6>
    54f6:	2a02      	cmp	r2, #2
    54f8:	d114      	bne.n	5524 <Macro_evalTriggerMacro+0x11c>
		erro_print("LED State Type - Not implemented...");
		break;

	// Analog State Type
	case 0x02:
		erro_print("Analog State Type - Not implemented...");
    54fa:	484d      	ldr	r0, [pc, #308]	; (5630 <Macro_evalTriggerMacro+0x228>)
    54fc:	e013      	b.n	5526 <Macro_evalTriggerMacro+0x11e>
	switch ( guide->type )
	{
	// Normal State Type
	case 0x00:
		// For short TriggerMacros completely ignore incorrect keys
		if ( guide->scanCode == key->scanCode )
    54fe:	9b02      	ldr	r3, [sp, #8]
    5500:	788a      	ldrb	r2, [r1, #2]
    5502:	7898      	ldrb	r0, [r3, #2]
    5504:	4290      	cmp	r0, r2
    5506:	d112      	bne.n	552e <Macro_evalTriggerMacro+0x126>
		{
			switch ( key->state )
    5508:	784a      	ldrb	r2, [r1, #1]
    550a:	2a02      	cmp	r2, #2
    550c:	d011      	beq.n	5532 <Macro_evalTriggerMacro+0x12a>
    550e:	2a03      	cmp	r2, #3
    5510:	d004      	beq.n	551c <Macro_evalTriggerMacro+0x114>
			case 0x03:
				return TriggerMacroVote_Release;
			}
		}

		return TriggerMacroVote_DoNothing;
    5512:	2a01      	cmp	r2, #1
    5514:	bf0c      	ite	eq
    5516:	2208      	moveq	r2, #8
    5518:	2202      	movne	r2, #2
    551a:	e00b      	b.n	5534 <Macro_evalTriggerMacro+0x12c>
			case 0x02:
				return TriggerMacroVote_PassRelease;

			// Correct key, released, possible release
			case 0x03:
				return TriggerMacroVote_Release;
    551c:	2210      	movs	r2, #16
    551e:	e009      	b.n	5534 <Macro_evalTriggerMacro+0x12c>

		return TriggerMacroVote_DoNothing;

	// LED State Type
	case 0x01:
		erro_print("LED State Type - Not implemented...");
    5520:	4844      	ldr	r0, [pc, #272]	; (5634 <Macro_evalTriggerMacro+0x22c>)
    5522:	e000      	b.n	5526 <Macro_evalTriggerMacro+0x11e>
		erro_print("Analog State Type - Not implemented...");
		break;

	// Invalid State Type
	default:
		erro_print("Invalid State Type. This is a bug.");
    5524:	4844      	ldr	r0, [pc, #272]	; (5638 <Macro_evalTriggerMacro+0x230>)
    5526:	f002 f96d 	bl	7804 <_print>
		break;
	}

	// XXX Shouldn't reach here
	return TriggerMacroVote_Invalid;
    552a:	462a      	mov	r2, r5
    552c:	e002      	b.n	5534 <Macro_evalTriggerMacro+0x12c>
			case 0x03:
				return TriggerMacroVote_Release;
			}
		}

		return TriggerMacroVote_DoNothing;
    552e:	2202      	movs	r2, #2
    5530:	e000      	b.n	5534 <Macro_evalTriggerMacro+0x12c>
			case 0x01:
				return TriggerMacroVote_Pass;

			// Correct key, held, possible passing or release
			case 0x02:
				return TriggerMacroVote_PassRelease;
    5532:	2218      	movs	r2, #24
			// Lookup key information
			TriggerGuide *keyInfo = &macroTriggerListBuffer[ key ];

			// If vote is a pass (>= 0x08, no more keys in the combo need to be looked at)
			// Also mask all of the non-passing votes
			vote |= longMacro
    5534:	9b05      	ldr	r3, [sp, #20]
    5536:	b2d2      	uxtb	r2, r2
    5538:	431a      	orrs	r2, r3
				? Macro_evalLongTriggerMacroVote( keyInfo, guide )
				: Macro_evalShortTriggerMacroVote( keyInfo, guide );
			if ( vote >= TriggerMacroVote_Pass )
    553a:	2a07      	cmp	r2, #7
    553c:	d902      	bls.n	5544 <Macro_evalTriggerMacro+0x13c>
			{
				vote &= TriggerMacroVote_Release | TriggerMacroVote_PassRelease | TriggerMacroVote_Pass;
    553e:	f002 0218 	and.w	r2, r2, #24
				break;
    5542:	e004      	b.n	554e <Macro_evalTriggerMacro+0x146>
		// Assign TriggerGuide element (key type, state and scancode)
		TriggerGuide *guide = (TriggerGuide*)(&macro->guide[ comboItem ]);

		TriggerMacroVote vote = TriggerMacroVote_Invalid;
		// Iterate through the key buffer, comparing to each key in the combo
		for ( uint8_t key = 0; key < macroTriggerListBufferSize; key++ )
    5544:	f109 0901 	add.w	r9, r9, #1
    5548:	fa5f f989 	uxtb.w	r9, r9
    554c:	e79c      	b.n	5488 <Macro_evalTriggerMacro+0x80>
			}
		}

		// If no pass vote was found after scanning all of the keys
		// Fail the combo, if this is a short macro (long macros already will have a fail vote)
		if ( !longMacro && vote < TriggerMacroVote_Pass )
    554e:	b91d      	cbnz	r5, 5558 <Macro_evalTriggerMacro+0x150>
    5550:	2a07      	cmp	r2, #7
			vote |= TriggerMacroVote_Fail;
    5552:	bf98      	it	ls
    5554:	f042 0201 	orrls.w	r2, r2, #1
	// TODO Add support for system LED states (NumLock, CapsLock, etc.)
	// TODO Add support for analog key states
	// TODO Add support for 0x00 Key state (not pressing a key, not all that useful in general)
	// TODO Add support for Press/Hold/Release differentiation when evaluating (not sure if useful)
	TriggerMacroVote overallVote = TriggerMacroVote_Invalid;
	for ( uint8_t comboItem = pos + 1; comboItem < pos + comboLength + 1; comboItem += TriggerGuideSize )
    5558:	f10b 0b03 	add.w	fp, fp, #3
		// Fail the combo, if this is a short macro (long macros already will have a fail vote)
		if ( !longMacro && vote < TriggerMacroVote_Pass )
			vote |= TriggerMacroVote_Fail;

		// After voting, append to overall vote
		overallVote |= vote;
    555c:	4314      	orrs	r4, r2
	// TODO Add support for system LED states (NumLock, CapsLock, etc.)
	// TODO Add support for analog key states
	// TODO Add support for 0x00 Key state (not pressing a key, not all that useful in general)
	// TODO Add support for Press/Hold/Release differentiation when evaluating (not sure if useful)
	TriggerMacroVote overallVote = TriggerMacroVote_Invalid;
	for ( uint8_t comboItem = pos + 1; comboItem < pos + comboLength + 1; comboItem += TriggerGuideSize )
    555e:	fa5f fb8b 	uxtb.w	fp, fp
    5562:	e785      	b.n	5470 <Macro_evalTriggerMacro+0x68>
		overallVote |= vote;
	}

	// If no pass vote was found after scanning the entire combo
	// And this is the first position in the combo, just remove it (nothing important happened)
	if ( longMacro && overallVote & TriggerMacroVote_DoNothingRelease && pos == 0 )
    5564:	b12d      	cbz	r5, 5572 <Macro_evalTriggerMacro+0x16a>
    5566:	0762      	lsls	r2, r4, #29
    5568:	d503      	bpl.n	5572 <Macro_evalTriggerMacro+0x16a>
    556a:	9b01      	ldr	r3, [sp, #4]
    556c:	b90b      	cbnz	r3, 5572 <Macro_evalTriggerMacro+0x16a>
		overallVote |= TriggerMacroVote_Fail;
    556e:	f044 0401 	orr.w	r4, r4, #1

	// Decide new state of macro after voting
	// Fail macro, remove from pending list
	if ( overallVote & TriggerMacroVote_Fail )
    5572:	07e3      	lsls	r3, r4, #31
    5574:	f53f af70 	bmi.w	5458 <Macro_evalTriggerMacro+0x50>
	{
		return TriggerMacroEval_Remove;
	}
	// Do nothing, incorrect key is being held or released
	else if ( overallVote & TriggerMacroVote_DoNothing && longMacro )
    5578:	07a0      	lsls	r0, r4, #30
    557a:	d502      	bpl.n	5582 <Macro_evalTriggerMacro+0x17a>
    557c:	b10d      	cbz	r5, 5582 <Macro_evalTriggerMacro+0x17a>
	// If this is a short macro, just remove it
	// The state can be rebuilt on the next iteration
	if ( !longMacro )
		return TriggerMacroEval_Remove;

	return TriggerMacroEval_DoNothing;
    557e:	2000      	movs	r0, #0
    5580:	e04c      	b.n	561c <Macro_evalTriggerMacro+0x214>
	{
		// Just doing nothing :)
	}
	// If ready for transition and in Press state, set to Waiting and increment combo position
	// Position is incremented (and possibly remove the macro from the pending list) on the next iteration
	else if ( overallVote & TriggerMacroVote_Release && record->state == TriggerMacro_Press )
    5582:	f004 0210 	and.w	r2, r4, #16
    5586:	f002 00ff 	and.w	r0, r2, #255	; 0xff
    558a:	b1c2      	cbz	r2, 55be <Macro_evalTriggerMacro+0x1b6>
    558c:	7872      	ldrb	r2, [r6, #1]
    558e:	b9b2      	cbnz	r2, 55be <Macro_evalTriggerMacro+0x1b6>
	{
		record->state = TriggerMacro_Release;
    5590:	2201      	movs	r2, #1
    5592:	7072      	strb	r2, [r6, #1]

		// If this is the last combo in the sequence, remove from the pending list
		if ( macro->guide[ record->pos + macro->guide[ record->pos ] * TriggerGuideSize + 1 ] == 0 )
    5594:	f857 303a 	ldr.w	r3, [r7, sl, lsl #3]
    5598:	f818 201a 	ldrb.w	r2, [r8, sl, lsl #1]
    559c:	5c98      	ldrb	r0, [r3, r2]
    559e:	1c51      	adds	r1, r2, #1
    55a0:	2203      	movs	r2, #3
    55a2:	fb12 1200 	smlabb	r2, r2, r0, r1
    55a6:	5c9b      	ldrb	r3, [r3, r2]
    55a8:	b13b      	cbz	r3, 55ba <Macro_evalTriggerMacro+0x1b2>
		return TriggerMacroEval_DoResultAndRemove;
	}

	// If this is a short macro, just remove it
	// The state can be rebuilt on the next iteration
	if ( !longMacro )
    55aa:	2d00      	cmp	r5, #0
    55ac:	f43f af54 	beq.w	5458 <Macro_evalTriggerMacro+0x50>
    55b0:	e7e5      	b.n	557e <Macro_evalTriggerMacro+0x176>
		// If this result macro has more than 1 key, only send once
		// TODO Add option to have long macro repeat rate
		if ( macro->guide[ pos + comboLength + 1 ] == 0 )
		{
			// Long result macro (more than 1 combo)
			if ( Macro_isLongResultMacro( &ResultMacroList[ macro->result ] ) )
    55b2:	5ccb      	ldrb	r3, [r1, r3]
    55b4:	b333      	cbz	r3, 5604 <Macro_evalTriggerMacro+0x1fc>
			{
				// Only ever trigger result once, on press
				if ( overallVote == TriggerMacroVote_Pass )
    55b6:	2c08      	cmp	r4, #8
    55b8:	d1f7      	bne.n	55aa <Macro_evalTriggerMacro+0x1a2>
	{
		record->state = TriggerMacro_Release;

		// If this is the last combo in the sequence, remove from the pending list
		if ( macro->guide[ record->pos + macro->guide[ record->pos ] * TriggerGuideSize + 1 ] == 0 )
			return TriggerMacroEval_DoResultAndRemove;
    55ba:	2002      	movs	r0, #2
    55bc:	e02e      	b.n	561c <Macro_evalTriggerMacro+0x214>
	}
	// If passing and in Waiting state, set macro state to Press
	else if ( overallVote & TriggerMacroVote_Pass
    55be:	0722      	lsls	r2, r4, #28
    55c0:	d529      	bpl.n	5616 <Macro_evalTriggerMacro+0x20e>
		&& ( record->state == TriggerMacro_Waiting || record->state == TriggerMacro_Press ) )
    55c2:	7872      	ldrb	r2, [r6, #1]
    55c4:	f012 02fd 	ands.w	r2, r2, #253	; 0xfd
    55c8:	d125      	bne.n	5616 <Macro_evalTriggerMacro+0x20e>
	{
		record->state = TriggerMacro_Press;
    55ca:	7072      	strb	r2, [r6, #1]

		// If in press state, and this is the final combo, send request for ResultMacro
		// Check to see if the result macro only has a single element
		// If this result macro has more than 1 key, only send once
		// TODO Add option to have long macro repeat rate
		if ( macro->guide[ pos + comboLength + 1 ] == 0 )
    55cc:	f857 203a 	ldr.w	r2, [r7, sl, lsl #3]
    55d0:	4411      	add	r1, r2
    55d2:	7848      	ldrb	r0, [r1, #1]
    55d4:	2800      	cmp	r0, #0
    55d6:	d1e8      	bne.n	55aa <Macro_evalTriggerMacro+0x1a2>
		{
			// Long result macro (more than 1 combo)
			if ( Macro_isLongResultMacro( &ResultMacroList[ macro->result ] ) )
    55d8:	9b03      	ldr	r3, [sp, #12]
    55da:	7919      	ldrb	r1, [r3, #4]
{
	// Check the second sequence combo length
	// If non-zero return non-zero (long sequence)
	// 0 otherwise (short sequence)
	var_uint_t position = 1;
	for ( var_uint_t result = 0; result < macro->guide[0]; result++ )
    55dc:	4b17      	ldr	r3, [pc, #92]	; (563c <Macro_evalTriggerMacro+0x234>)
    55de:	f853 1021 	ldr.w	r1, [r3, r1, lsl #2]
    55e2:	780e      	ldrb	r6, [r1, #0]
inline uint8_t Macro_isLongResultMacro( const ResultMacro *macro )
{
	// Check the second sequence combo length
	// If non-zero return non-zero (long sequence)
	// 0 otherwise (short sequence)
	var_uint_t position = 1;
    55e4:	2301      	movs	r3, #1
	for ( var_uint_t result = 0; result < macro->guide[0]; result++ )
    55e6:	42b0      	cmp	r0, r6
    55e8:	d0e3      	beq.n	55b2 <Macro_evalTriggerMacro+0x1aa>
		position += ResultGuideSize( (ResultGuide*)&macro->guide[ position ] );
    55ea:	f811 c003 	ldrb.w	ip, [r1, r3]
    55ee:	4f14      	ldr	r7, [pc, #80]	; (5640 <Macro_evalTriggerMacro+0x238>)
    55f0:	eb07 07cc 	add.w	r7, r7, ip, lsl #3
{
	// Check the second sequence combo length
	// If non-zero return non-zero (long sequence)
	// 0 otherwise (short sequence)
	var_uint_t position = 1;
	for ( var_uint_t result = 0; result < macro->guide[0]; result++ )
    55f4:	3001      	adds	r0, #1
		position += ResultGuideSize( (ResultGuide*)&macro->guide[ position ] );
    55f6:	793f      	ldrb	r7, [r7, #4]
    55f8:	3701      	adds	r7, #1
    55fa:	fa53 f387 	uxtab	r3, r3, r7
    55fe:	b2db      	uxtb	r3, r3
{
	// Check the second sequence combo length
	// If non-zero return non-zero (long sequence)
	// 0 otherwise (short sequence)
	var_uint_t position = 1;
	for ( var_uint_t result = 0; result < macro->guide[0]; result++ )
    5600:	b2c0      	uxtb	r0, r0
    5602:	e7f0      	b.n	55e6 <Macro_evalTriggerMacro+0x1de>
inline uint8_t Macro_isLongTriggerMacro( const TriggerMacro *macro )
{
	// Check the second sequence combo length
	// If non-zero return non-zero (long sequence)
	// 0 otherwise (short sequence)
	return macro->guide[ macro->guide[0] * TriggerGuideSize + 1 ];
    5604:	7813      	ldrb	r3, [r2, #0]
    5606:	2001      	movs	r0, #1
    5608:	2103      	movs	r1, #3
    560a:	fb11 0303 	smlabb	r3, r1, r3, r0
			}
			// Short result macro
			else
			{
				// Only trigger result once, on press, if long trigger (more than 1 combo)
				if ( Macro_isLongTriggerMacro( macro ) )
    560e:	5cd3      	ldrb	r3, [r2, r3]
    5610:	2b00      	cmp	r3, #0
    5612:	d1d2      	bne.n	55ba <Macro_evalTriggerMacro+0x1b2>
    5614:	e002      	b.n	561c <Macro_evalTriggerMacro+0x214>
			}
		}
	}
	// Otherwise, just remove the macro on key release
	// One more result has to be called to indicate to the ResultMacro that the key transitioned to the release state
	else if ( overallVote & TriggerMacroVote_Release )
    5616:	2800      	cmp	r0, #0
    5618:	d1cf      	bne.n	55ba <Macro_evalTriggerMacro+0x1b2>
    561a:	e7c6      	b.n	55aa <Macro_evalTriggerMacro+0x1a2>
	// The state can be rebuilt on the next iteration
	if ( !longMacro )
		return TriggerMacroEval_Remove;

	return TriggerMacroEval_DoNothing;
}
    561c:	b007      	add	sp, #28
    561e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    5622:	bf00      	nop
    5624:	0000a408 	.word	0x0000a408
    5628:	1fff92de 	.word	0x1fff92de
    562c:	1fffa13e 	.word	0x1fffa13e
    5630:	0000991f 	.word	0x0000991f
    5634:	000098e4 	.word	0x000098e4
    5638:	0000995d 	.word	0x0000995d
    563c:	00009ebc 	.word	0x00009ebc
    5640:	0000a1f8 	.word	0x0000a1f8
    5644:	1fffa501 	.word	0x1fffa501

00005648 <Macro_process>:


// Macro Procesing Loop
// Called once per USB buffer send
inline void Macro_process()
{
    5648:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
#if defined(ConnectEnabled_define)
	// Only compile in if a Connect node module is available
	// If this is a interconnect slave node, send all scancodes to master node
	if ( !Connect_master )
    564c:	4ba4      	ldr	r3, [pc, #656]	; (58e0 <Macro_process+0x298>)
    564e:	781d      	ldrb	r5, [r3, #0]


// Macro Procesing Loop
// Called once per USB buffer send
inline void Macro_process()
{
    5650:	b085      	sub	sp, #20
#if defined(ConnectEnabled_define)
	// Only compile in if a Connect node module is available
	// If this is a interconnect slave node, send all scancodes to master node
	if ( !Connect_master )
    5652:	b95d      	cbnz	r5, 566c <Macro_process+0x24>
	{
		if ( macroTriggerListBufferSize > 0 )
    5654:	4ca3      	ldr	r4, [pc, #652]	; (58e4 <Macro_process+0x29c>)
    5656:	7822      	ldrb	r2, [r4, #0]
    5658:	2a00      	cmp	r2, #0
    565a:	f000 81c3 	beq.w	59e4 <Macro_process+0x39c>
		{
			Connect_send_ScanCode( Connect_id, macroTriggerListBuffer, macroTriggerListBufferSize );
    565e:	4ba2      	ldr	r3, [pc, #648]	; (58e8 <Macro_process+0x2a0>)
    5660:	49a2      	ldr	r1, [pc, #648]	; (58ec <Macro_process+0x2a4>)
    5662:	7818      	ldrb	r0, [r3, #0]
    5664:	f7fe fe28 	bl	42b8 <Connect_send_ScanCode>
			macroTriggerListBufferSize = 0;
    5668:	7025      	strb	r5, [r4, #0]
    566a:	e1bb      	b.n	59e4 <Macro_process+0x39c>
		return;
	}
#endif

	// Only do one round of macro processing between Output Module timer sends
	if ( USBKeys_Sent != 0 )
    566c:	4ba0      	ldr	r3, [pc, #640]	; (58f0 <Macro_process+0x2a8>)
    566e:	781a      	ldrb	r2, [r3, #0]
    5670:	2a00      	cmp	r2, #0
    5672:	f040 81b7 	bne.w	59e4 <Macro_process+0x39c>
		return;

#if defined(ConnectEnabled_define)
	// Check if there are any ScanCodes in the interconnect cache to process
	if ( Connect_master && macroInterconnectCacheSize > 0 )
    5676:	4c9f      	ldr	r4, [pc, #636]	; (58f4 <Macro_process+0x2ac>)
    5678:	7825      	ldrb	r5, [r4, #0]
    567a:	b91d      	cbnz	r5, 5684 <Macro_process+0x3c>
		}
	}
#endif

	// If the pause flag is set, only process if the step counter is non-zero
	if ( macroPauseMode )
    567c:	4b9e      	ldr	r3, [pc, #632]	; (58f8 <Macro_process+0x2b0>)
    567e:	781b      	ldrb	r3, [r3, #0]
    5680:	bb83      	cbnz	r3, 56e4 <Macro_process+0x9c>
    5682:	e039      	b.n	56f8 <Macro_process+0xb0>
	// Check if there are any ScanCodes in the interconnect cache to process
	if ( Connect_master && macroInterconnectCacheSize > 0 )
	{
		// Iterate over all the cache ScanCodes
		uint8_t currentInterconnectCacheSize = macroInterconnectCacheSize;
		macroInterconnectCacheSize = 0;
    5684:	7022      	strb	r2, [r4, #0]
		for ( uint8_t c = 0; c < currentInterconnectCacheSize; c++ )
    5686:	4610      	mov	r0, r2
		{
			// Add to the trigger list
			macroTriggerListBuffer[ macroTriggerListBufferSize++ ] = macroInterconnectCache[ c ];
    5688:	4b96      	ldr	r3, [pc, #600]	; (58e4 <Macro_process+0x29c>)
    568a:	f8df c260 	ldr.w	ip, [pc, #608]	; 58ec <Macro_process+0x2a4>
    568e:	781e      	ldrb	r6, [r3, #0]
    5690:	1c71      	adds	r1, r6, #1
    5692:	7019      	strb	r1, [r3, #0]
    5694:	4999      	ldr	r1, [pc, #612]	; (58fc <Macro_process+0x2b4>)
    5696:	1853      	adds	r3, r2, r1
    5698:	2703      	movs	r7, #3
    569a:	437e      	muls	r6, r7
    569c:	f8b3 9000 	ldrh.w	r9, [r3]
    56a0:	eb0c 0806 	add.w	r8, ip, r6
    56a4:	f82c 9006 	strh.w	r9, [ip, r6]
    56a8:	789e      	ldrb	r6, [r3, #2]
    56aa:	f888 6002 	strb.w	r6, [r8, #2]

			// TODO Handle other TriggerGuide types (e.g. analog)
			switch ( macroInterconnectCache[ c ].type )
    56ae:	5c56      	ldrb	r6, [r2, r1]
    56b0:	b98e      	cbnz	r6, 56d6 <Macro_process+0x8e>
			{
			// Normal (Press/Hold/Release)
			case 0x00:
				// Decide what to do based on the current state
				switch ( macroInterconnectCache[ c ].state )
    56b2:	785e      	ldrb	r6, [r3, #1]
    56b4:	2e01      	cmp	r6, #1
    56b6:	d10e      	bne.n	56d6 <Macro_process+0x8e>
				{
				// Re-add to interconnect cache in hold state
				case 0x01: // Press
				//case 0x02: // Hold // XXX Why does this not work? -HaaTa
					macroInterconnectCache[ c ].state = 0x02;
    56b8:	2602      	movs	r6, #2
    56ba:	705e      	strb	r6, [r3, #1]
					macroInterconnectCache[ macroInterconnectCacheSize++ ] = macroInterconnectCache[ c ];
    56bc:	7826      	ldrb	r6, [r4, #0]
    56be:	f106 0c01 	add.w	ip, r6, #1
    56c2:	f884 c000 	strb.w	ip, [r4]
    56c6:	437e      	muls	r6, r7
    56c8:	f8b3 c000 	ldrh.w	ip, [r3]
    56cc:	f821 c006 	strh.w	ip, [r1, r6]
    56d0:	198f      	adds	r7, r1, r6
    56d2:	789b      	ldrb	r3, [r3, #2]
    56d4:	70bb      	strb	r3, [r7, #2]
	if ( Connect_master && macroInterconnectCacheSize > 0 )
	{
		// Iterate over all the cache ScanCodes
		uint8_t currentInterconnectCacheSize = macroInterconnectCacheSize;
		macroInterconnectCacheSize = 0;
		for ( uint8_t c = 0; c < currentInterconnectCacheSize; c++ )
    56d6:	3001      	adds	r0, #1
    56d8:	b2c0      	uxtb	r0, r0
    56da:	42a8      	cmp	r0, r5
    56dc:	f102 0203 	add.w	r2, r2, #3
    56e0:	d1d2      	bne.n	5688 <Macro_process+0x40>
    56e2:	e7cb      	b.n	567c <Macro_process+0x34>
#endif

	// If the pause flag is set, only process if the step counter is non-zero
	if ( macroPauseMode )
	{
		if ( macroStepCounter == 0 )
    56e4:	4b86      	ldr	r3, [pc, #536]	; (5900 <Macro_process+0x2b8>)
    56e6:	881a      	ldrh	r2, [r3, #0]
    56e8:	2a00      	cmp	r2, #0
    56ea:	f000 817b 	beq.w	59e4 <Macro_process+0x39c>
			return;

		// Proceed, decrementing the step counter
		macroStepCounter--;
    56ee:	3a01      	subs	r2, #1
		dbug_print("Macro Step");
    56f0:	4884      	ldr	r0, [pc, #528]	; (5904 <Macro_process+0x2bc>)
	{
		if ( macroStepCounter == 0 )
			return;

		// Proceed, decrementing the step counter
		macroStepCounter--;
    56f2:	801a      	strh	r2, [r3, #0]
		dbug_print("Macro Step");
    56f4:	f002 f886 	bl	7804 <_print>
		// Number of Triggers in list
		nat_ptr_t triggerListSize = triggerList[0];

		// Iterate over triggerList to see if any TriggerMacros need to be added
		// First item is the number of items in the TriggerList
		for ( var_uint_t macro = 1; macro < triggerListSize + 1; macro++ )
    56f8:	2400      	movs	r4, #0

// Update pending trigger list
inline void Macro_updateTriggerMacroPendingList()
{
	// Iterate over the macroTriggerListBuffer to add any new Trigger Macros to the pending list
	for ( uint8_t key = 0; key < macroTriggerListBufferSize; key++ )
    56fa:	4e7a      	ldr	r6, [pc, #488]	; (58e4 <Macro_process+0x29c>)
    56fc:	7833      	ldrb	r3, [r6, #0]
    56fe:	42a3      	cmp	r3, r4
    5700:	d939      	bls.n	5776 <Macro_process+0x12e>
	{
		// TODO LED States
		// TODO Analog Switches
		// Only add TriggerMacro to pending list if key was pressed (not held, released or off)
		if ( macroTriggerListBuffer[ key ].state == 0x00 && macroTriggerListBuffer[ key ].state != 0x01 )
    5702:	4b7a      	ldr	r3, [pc, #488]	; (58ec <Macro_process+0x2a4>)
    5704:	2003      	movs	r0, #3
    5706:	fb00 3004 	mla	r0, r0, r4, r3
    570a:	7841      	ldrb	r1, [r0, #1]
    570c:	b381      	cbz	r1, 5770 <Macro_process+0x128>
		// TODO Analog
		// If this is a release case, indicate to layer lookup for possible latch expiry
		uint8_t latch_expire = macroTriggerListBuffer[ key ].state == 0x03;

		// Lookup Trigger List
		nat_ptr_t *triggerList = Macro_layerLookup( &macroTriggerListBuffer[ key ], latch_expire );
    570e:	1ecd      	subs	r5, r1, #3
    5710:	4269      	negs	r1, r5
    5712:	4169      	adcs	r1, r5
    5714:	f7ff fd14 	bl	5140 <Macro_layerLookup>

		// If there was an error during lookup, skip
		if ( triggerList == 0 )
    5718:	b350      	cbz	r0, 5770 <Macro_process+0x128>
    571a:	4e7b      	ldr	r6, [pc, #492]	; (5908 <Macro_process+0x2c0>)
			continue;

		// Number of Triggers in list
		nat_ptr_t triggerListSize = triggerList[0];
    571c:	6807      	ldr	r7, [r0, #0]
    571e:	8833      	ldrh	r3, [r6, #0]

		// Iterate over triggerList to see if any TriggerMacros need to be added
		// First item is the number of items in the TriggerList
		for ( var_uint_t macro = 1; macro < triggerListSize + 1; macro++ )
    5720:	2101      	movs	r1, #1
    5722:	1c7a      	adds	r2, r7, #1
    5724:	4291      	cmp	r1, r2
    5726:	d222      	bcs.n	576e <Macro_process+0x126>
		{
			// Lookup trigger macro index
			var_uint_t triggerMacroIndex = triggerList[ macro ];
    5728:	f810 5021 	ldrb.w	r5, [r0, r1, lsl #2]

			// Iterate over macroTriggerMacroPendingList to see if any macro in the scancode's
			//  triggerList needs to be added
			var_uint_t pending = 0;
    572c:	2200      	movs	r2, #0
			for ( ; pending < macroTriggerMacroPendingListSize; pending++ )
    572e:	429a      	cmp	r2, r3
    5730:	d205      	bcs.n	573e <Macro_process+0xf6>
			{
				// Stop scanning if the trigger macro index is found in the pending list
				if ( macroTriggerMacroPendingList[ pending ] == triggerMacroIndex )
    5732:	f8df e1dc 	ldr.w	lr, [pc, #476]	; 5910 <Macro_process+0x2c8>
    5736:	f83e e012 	ldrh.w	lr, [lr, r2, lsl #1]
    573a:	45ae      	cmp	lr, r5
    573c:	d111      	bne.n	5762 <Macro_process+0x11a>
					break;
			}

			// If the triggerMacroIndex (macro) was not found in the macroTriggerMacroPendingList
			// Add it to the list
			if ( pending == macroTriggerMacroPendingListSize )
    573e:	429a      	cmp	r2, r3
    5740:	d112      	bne.n	5768 <Macro_process+0x120>
			{
				macroTriggerMacroPendingList[ macroTriggerMacroPendingListSize++ ] = triggerMacroIndex;
    5742:	f8df e1cc 	ldr.w	lr, [pc, #460]	; 5910 <Macro_process+0x2c8>
    5746:	1c5a      	adds	r2, r3, #1
    5748:	f82e 5013 	strh.w	r5, [lr, r3, lsl #1]

				// Reset macro position
				TriggerMacroRecordList[ triggerMacroIndex ].pos   = 0;
    574c:	4b6f      	ldr	r3, [pc, #444]	; (590c <Macro_process+0x2c4>)
    574e:	f04f 0e00 	mov.w	lr, #0
    5752:	f803 e015 	strb.w	lr, [r3, r5, lsl #1]
				TriggerMacroRecordList[ triggerMacroIndex ].state = TriggerMacro_Waiting;
    5756:	eb03 0545 	add.w	r5, r3, r5, lsl #1
    575a:	2302      	movs	r3, #2
    575c:	706b      	strb	r3, [r5, #1]

			// If the triggerMacroIndex (macro) was not found in the macroTriggerMacroPendingList
			// Add it to the list
			if ( pending == macroTriggerMacroPendingListSize )
			{
				macroTriggerMacroPendingList[ macroTriggerMacroPendingListSize++ ] = triggerMacroIndex;
    575e:	b293      	uxth	r3, r2
    5760:	e002      	b.n	5768 <Macro_process+0x120>
			var_uint_t triggerMacroIndex = triggerList[ macro ];

			// Iterate over macroTriggerMacroPendingList to see if any macro in the scancode's
			//  triggerList needs to be added
			var_uint_t pending = 0;
			for ( ; pending < macroTriggerMacroPendingListSize; pending++ )
    5762:	3201      	adds	r2, #1
    5764:	b2d2      	uxtb	r2, r2
    5766:	e7e2      	b.n	572e <Macro_process+0xe6>
		// Number of Triggers in list
		nat_ptr_t triggerListSize = triggerList[0];

		// Iterate over triggerList to see if any TriggerMacros need to be added
		// First item is the number of items in the TriggerList
		for ( var_uint_t macro = 1; macro < triggerListSize + 1; macro++ )
    5768:	3101      	adds	r1, #1
    576a:	b2c9      	uxtb	r1, r1
    576c:	e7d9      	b.n	5722 <Macro_process+0xda>
    576e:	8033      	strh	r3, [r6, #0]

// Update pending trigger list
inline void Macro_updateTriggerMacroPendingList()
{
	// Iterate over the macroTriggerListBuffer to add any new Trigger Macros to the pending list
	for ( uint8_t key = 0; key < macroTriggerListBufferSize; key++ )
    5770:	3401      	adds	r4, #1
    5772:	b2e4      	uxtb	r4, r4
    5774:	e7c1      	b.n	56fa <Macro_process+0xb2>
    5776:	2400      	movs	r4, #0
    5778:	4627      	mov	r7, r4
	// Tail pointer for macroTriggerMacroPendingList
	// Macros must be explicitly re-added
	var_uint_t macroTriggerMacroPendingListTail = 0;

	// Iterate through the pending TriggerMacros, processing each of them
	for ( var_uint_t macro = 0; macro < macroTriggerMacroPendingListSize; macro++ )
    577a:	4b63      	ldr	r3, [pc, #396]	; (5908 <Macro_process+0x2c0>)
    577c:	881a      	ldrh	r2, [r3, #0]
    577e:	42a2      	cmp	r2, r4
    5780:	f240 80d0 	bls.w	5924 <Macro_process+0x2dc>
	{
		switch ( Macro_evalTriggerMacro( macroTriggerMacroPendingList[ macro ] ) )
    5784:	4d62      	ldr	r5, [pc, #392]	; (5910 <Macro_process+0x2c8>)
    5786:	f815 0014 	ldrb.w	r0, [r5, r4, lsl #1]
    578a:	f7ff fe3d 	bl	5408 <Macro_evalTriggerMacro>
    578e:	2802      	cmp	r0, #2
    5790:	d059      	beq.n	5846 <Macro_process+0x1fe>
    5792:	2803      	cmp	r0, #3
    5794:	f000 80a1 	beq.w	58da <Macro_process+0x292>
    5798:	2801      	cmp	r0, #1
    579a:	d14d      	bne.n	5838 <Macro_process+0x1f0>
		{
		// Trigger Result Macro (purposely falling through)
		case TriggerMacroEval_DoResult:
			// Append ResultMacro to PendingList
			Macro_appendResultMacroToPendingList( &TriggerMacroList[ macroTriggerMacroPendingList[ macro ] ] );
    579c:	485d      	ldr	r0, [pc, #372]	; (5914 <Macro_process+0x2cc>)
    579e:	f835 e014 	ldrh.w	lr, [r5, r4, lsl #1]
{
	// Lookup result macro index
	var_uint_t resultMacroIndex = triggerMacro->result;

	// Iterate through result macro pending list, making sure this macro hasn't been added yet
	for ( var_uint_t macro = 0; macro < macroResultMacroPendingListSize; macro++ )
    57a2:	f8df 8178 	ldr.w	r8, [pc, #376]	; 591c <Macro_process+0x2d4>
		switch ( Macro_evalTriggerMacro( macroTriggerMacroPendingList[ macro ] ) )
		{
		// Trigger Result Macro (purposely falling through)
		case TriggerMacroEval_DoResult:
			// Append ResultMacro to PendingList
			Macro_appendResultMacroToPendingList( &TriggerMacroList[ macroTriggerMacroPendingList[ macro ] ] );
    57a6:	eb00 03ce 	add.w	r3, r0, lr, lsl #3
{
	// Lookup result macro index
	var_uint_t resultMacroIndex = triggerMacro->result;

	// Iterate through result macro pending list, making sure this macro hasn't been added yet
	for ( var_uint_t macro = 0; macro < macroResultMacroPendingListSize; macro++ )
    57aa:	f8b8 1000 	ldrh.w	r1, [r8]
// Append result macro to pending list, checking for duplicates
// Do nothing if duplicate
inline void Macro_appendResultMacroToPendingList( const TriggerMacro *triggerMacro )
{
	// Lookup result macro index
	var_uint_t resultMacroIndex = triggerMacro->result;
    57ae:	791a      	ldrb	r2, [r3, #4]

	// Iterate through result macro pending list, making sure this macro hasn't been added yet
	for ( var_uint_t macro = 0; macro < macroResultMacroPendingListSize; macro++ )
    57b0:	2300      	movs	r3, #0
    57b2:	428b      	cmp	r3, r1
    57b4:	f8df c168 	ldr.w	ip, [pc, #360]	; 5920 <Macro_process+0x2d8>
    57b8:	d206      	bcs.n	57c8 <Macro_process+0x180>
	{
		// If duplicate found, do nothing
		if ( macroResultMacroPendingList[ macro ] == resultMacroIndex )
    57ba:	f83c c013 	ldrh.w	ip, [ip, r3, lsl #1]
    57be:	4594      	cmp	ip, r2
    57c0:	d03a      	beq.n	5838 <Macro_process+0x1f0>
{
	// Lookup result macro index
	var_uint_t resultMacroIndex = triggerMacro->result;

	// Iterate through result macro pending list, making sure this macro hasn't been added yet
	for ( var_uint_t macro = 0; macro < macroResultMacroPendingListSize; macro++ )
    57c2:	3301      	adds	r3, #1
    57c4:	b2db      	uxtb	r3, r3
    57c6:	e7f4      	b.n	57b2 <Macro_process+0x16a>
		if ( macroResultMacroPendingList[ macro ] == resultMacroIndex )
			return;
	}

	// No duplicates found, add to pending list
	macroResultMacroPendingList[ macroResultMacroPendingListSize++ ] = resultMacroIndex;
    57c8:	1c4b      	adds	r3, r1, #1
    57ca:	f82c 2011 	strh.w	r2, [ip, r1, lsl #1]

	// Lookup scanCode of the last key in the last combo
	var_uint_t pos = 0;
	for ( uint8_t comboLength = triggerMacro->guide[0]; comboLength > 0; )
    57ce:	f850 003e 	ldr.w	r0, [r0, lr, lsl #3]
		if ( macroResultMacroPendingList[ macro ] == resultMacroIndex )
			return;
	}

	// No duplicates found, add to pending list
	macroResultMacroPendingList[ macroResultMacroPendingListSize++ ] = resultMacroIndex;
    57d2:	f8a8 3000 	strh.w	r3, [r8]

	// Lookup scanCode of the last key in the last combo
	var_uint_t pos = 0;
	for ( uint8_t comboLength = triggerMacro->guide[0]; comboLength > 0; )
    57d6:	7803      	ldrb	r3, [r0, #0]

	// No duplicates found, add to pending list
	macroResultMacroPendingList[ macroResultMacroPendingListSize++ ] = resultMacroIndex;

	// Lookup scanCode of the last key in the last combo
	var_uint_t pos = 0;
    57d8:	2100      	movs	r1, #0
	for ( uint8_t comboLength = triggerMacro->guide[0]; comboLength > 0; )
    57da:	b13b      	cbz	r3, 57ec <Macro_process+0x1a4>
	{
		pos += TriggerGuideSize * comboLength + 1;
    57dc:	f04f 0e03 	mov.w	lr, #3
    57e0:	fb0e 1103 	mla	r1, lr, r3, r1
    57e4:	3101      	adds	r1, #1
    57e6:	b2c9      	uxtb	r1, r1
		comboLength = triggerMacro->guide[ pos ];
    57e8:	5c43      	ldrb	r3, [r0, r1]
    57ea:	e7f6      	b.n	57da <Macro_process+0x192>
	}

	uint8_t scanCode = ((TriggerGuide*)&triggerMacro->guide[ pos - TriggerGuideSize ])->scanCode;
    57ec:	4401      	add	r1, r0

	// Lookup scanCode in buffer list for the current state and stateType
	for ( uint8_t keyIndex = 0; keyIndex < macroTriggerListBufferSize; keyIndex++ )
    57ee:	f896 8000 	ldrb.w	r8, [r6]
	{
		pos += TriggerGuideSize * comboLength + 1;
		comboLength = triggerMacro->guide[ pos ];
	}

	uint8_t scanCode = ((TriggerGuide*)&triggerMacro->guide[ pos - TriggerGuideSize ])->scanCode;
    57f2:	f811 9c01 	ldrb.w	r9, [r1, #-1]

	// Lookup scanCode in buffer list for the current state and stateType
	for ( uint8_t keyIndex = 0; keyIndex < macroTriggerListBufferSize; keyIndex++ )
    57f6:	4619      	mov	r1, r3
    57f8:	4541      	cmp	r1, r8
    57fa:	d018      	beq.n	582e <Macro_process+0x1e6>
    57fc:	f8df e0ec 	ldr.w	lr, [pc, #236]	; 58ec <Macro_process+0x2a4>
    5800:	eb03 0c0e 	add.w	ip, r3, lr
	{
		if ( macroTriggerListBuffer[ keyIndex ].scanCode == scanCode )
    5804:	f89c 0002 	ldrb.w	r0, [ip, #2]
    5808:	4548      	cmp	r0, r9
    580a:	d10c      	bne.n	5826 <Macro_process+0x1de>
		{
			ResultMacroRecordList[ resultMacroIndex ].state     = macroTriggerListBuffer[ keyIndex ].state;
    580c:	4842      	ldr	r0, [pc, #264]	; (5918 <Macro_process+0x2d0>)
    580e:	f89c c001 	ldrb.w	ip, [ip, #1]
			ResultMacroRecordList[ resultMacroIndex ].stateType = macroTriggerListBuffer[ keyIndex ].type;
    5812:	f813 e00e 	ldrb.w	lr, [r3, lr]
	// Lookup scanCode in buffer list for the current state and stateType
	for ( uint8_t keyIndex = 0; keyIndex < macroTriggerListBufferSize; keyIndex++ )
	{
		if ( macroTriggerListBuffer[ keyIndex ].scanCode == scanCode )
		{
			ResultMacroRecordList[ resultMacroIndex ].state     = macroTriggerListBuffer[ keyIndex ].state;
    5816:	f04f 0a03 	mov.w	sl, #3
    581a:	fb0a 0002 	mla	r0, sl, r2, r0
    581e:	f880 c001 	strb.w	ip, [r0, #1]
			ResultMacroRecordList[ resultMacroIndex ].stateType = macroTriggerListBuffer[ keyIndex ].type;
    5822:	f880 e002 	strb.w	lr, [r0, #2]
	}

	uint8_t scanCode = ((TriggerGuide*)&triggerMacro->guide[ pos - TriggerGuideSize ])->scanCode;

	// Lookup scanCode in buffer list for the current state and stateType
	for ( uint8_t keyIndex = 0; keyIndex < macroTriggerListBufferSize; keyIndex++ )
    5826:	3101      	adds	r1, #1
    5828:	b2c9      	uxtb	r1, r1
    582a:	3303      	adds	r3, #3
    582c:	e7e4      	b.n	57f8 <Macro_process+0x1b0>
			ResultMacroRecordList[ resultMacroIndex ].stateType = macroTriggerListBuffer[ keyIndex ].type;
		}
	}

	// Reset the macro position
	ResultMacroRecordList[ resultMacroIndex ].pos = 0;
    582e:	2303      	movs	r3, #3
    5830:	435a      	muls	r2, r3
    5832:	4b39      	ldr	r3, [pc, #228]	; (5918 <Macro_process+0x2d0>)
    5834:	2100      	movs	r1, #0
    5836:	5499      	strb	r1, [r3, r2]
		case TriggerMacroEval_DoResult:
			// Append ResultMacro to PendingList
			Macro_appendResultMacroToPendingList( &TriggerMacroList[ macroTriggerMacroPendingList[ macro ] ] );

		default:
			macroTriggerMacroPendingList[ macroTriggerMacroPendingListTail++ ] = macroTriggerMacroPendingList[ macro ];
    5838:	f835 2014 	ldrh.w	r2, [r5, r4, lsl #1]
    583c:	1c7b      	adds	r3, r7, #1
    583e:	f825 2017 	strh.w	r2, [r5, r7, lsl #1]
    5842:	b2df      	uxtb	r7, r3
			break;
    5844:	e049      	b.n	58da <Macro_process+0x292>

		// Trigger Result Macro and Remove (purposely falling through)
		case TriggerMacroEval_DoResultAndRemove:
			// Append ResultMacro to PendingList
			Macro_appendResultMacroToPendingList( &TriggerMacroList[ macroTriggerMacroPendingList[ macro ] ] );
    5846:	4833      	ldr	r0, [pc, #204]	; (5914 <Macro_process+0x2cc>)
    5848:	f835 5014 	ldrh.w	r5, [r5, r4, lsl #1]
{
	// Lookup result macro index
	var_uint_t resultMacroIndex = triggerMacro->result;

	// Iterate through result macro pending list, making sure this macro hasn't been added yet
	for ( var_uint_t macro = 0; macro < macroResultMacroPendingListSize; macro++ )
    584c:	f8df c0cc 	ldr.w	ip, [pc, #204]	; 591c <Macro_process+0x2d4>
			break;

		// Trigger Result Macro and Remove (purposely falling through)
		case TriggerMacroEval_DoResultAndRemove:
			// Append ResultMacro to PendingList
			Macro_appendResultMacroToPendingList( &TriggerMacroList[ macroTriggerMacroPendingList[ macro ] ] );
    5850:	eb00 03c5 	add.w	r3, r0, r5, lsl #3
{
	// Lookup result macro index
	var_uint_t resultMacroIndex = triggerMacro->result;

	// Iterate through result macro pending list, making sure this macro hasn't been added yet
	for ( var_uint_t macro = 0; macro < macroResultMacroPendingListSize; macro++ )
    5854:	f8bc 1000 	ldrh.w	r1, [ip]
// Append result macro to pending list, checking for duplicates
// Do nothing if duplicate
inline void Macro_appendResultMacroToPendingList( const TriggerMacro *triggerMacro )
{
	// Lookup result macro index
	var_uint_t resultMacroIndex = triggerMacro->result;
    5858:	791a      	ldrb	r2, [r3, #4]

	// Iterate through result macro pending list, making sure this macro hasn't been added yet
	for ( var_uint_t macro = 0; macro < macroResultMacroPendingListSize; macro++ )
    585a:	2300      	movs	r3, #0
    585c:	428b      	cmp	r3, r1
    585e:	f8df e0c0 	ldr.w	lr, [pc, #192]	; 5920 <Macro_process+0x2d8>
    5862:	d206      	bcs.n	5872 <Macro_process+0x22a>
	{
		// If duplicate found, do nothing
		if ( macroResultMacroPendingList[ macro ] == resultMacroIndex )
    5864:	f83e e013 	ldrh.w	lr, [lr, r3, lsl #1]
    5868:	4596      	cmp	lr, r2
    586a:	d036      	beq.n	58da <Macro_process+0x292>
{
	// Lookup result macro index
	var_uint_t resultMacroIndex = triggerMacro->result;

	// Iterate through result macro pending list, making sure this macro hasn't been added yet
	for ( var_uint_t macro = 0; macro < macroResultMacroPendingListSize; macro++ )
    586c:	3301      	adds	r3, #1
    586e:	b2db      	uxtb	r3, r3
    5870:	e7f4      	b.n	585c <Macro_process+0x214>
		if ( macroResultMacroPendingList[ macro ] == resultMacroIndex )
			return;
	}

	// No duplicates found, add to pending list
	macroResultMacroPendingList[ macroResultMacroPendingListSize++ ] = resultMacroIndex;
    5872:	1c4b      	adds	r3, r1, #1
    5874:	f82e 2011 	strh.w	r2, [lr, r1, lsl #1]

	// Lookup scanCode of the last key in the last combo
	var_uint_t pos = 0;
	for ( uint8_t comboLength = triggerMacro->guide[0]; comboLength > 0; )
    5878:	f850 0035 	ldr.w	r0, [r0, r5, lsl #3]
		if ( macroResultMacroPendingList[ macro ] == resultMacroIndex )
			return;
	}

	// No duplicates found, add to pending list
	macroResultMacroPendingList[ macroResultMacroPendingListSize++ ] = resultMacroIndex;
    587c:	f8ac 3000 	strh.w	r3, [ip]

	// Lookup scanCode of the last key in the last combo
	var_uint_t pos = 0;
	for ( uint8_t comboLength = triggerMacro->guide[0]; comboLength > 0; )
    5880:	7803      	ldrb	r3, [r0, #0]

	// No duplicates found, add to pending list
	macroResultMacroPendingList[ macroResultMacroPendingListSize++ ] = resultMacroIndex;

	// Lookup scanCode of the last key in the last combo
	var_uint_t pos = 0;
    5882:	2100      	movs	r1, #0
	for ( uint8_t comboLength = triggerMacro->guide[0]; comboLength > 0; )
    5884:	b133      	cbz	r3, 5894 <Macro_process+0x24c>
	{
		pos += TriggerGuideSize * comboLength + 1;
    5886:	2503      	movs	r5, #3
    5888:	fb05 1103 	mla	r1, r5, r3, r1
    588c:	3101      	adds	r1, #1
    588e:	b2c9      	uxtb	r1, r1
		comboLength = triggerMacro->guide[ pos ];
    5890:	5c43      	ldrb	r3, [r0, r1]
    5892:	e7f7      	b.n	5884 <Macro_process+0x23c>
	}

	uint8_t scanCode = ((TriggerGuide*)&triggerMacro->guide[ pos - TriggerGuideSize ])->scanCode;
    5894:	4401      	add	r1, r0

	// Lookup scanCode in buffer list for the current state and stateType
	for ( uint8_t keyIndex = 0; keyIndex < macroTriggerListBufferSize; keyIndex++ )
    5896:	f896 c000 	ldrb.w	ip, [r6]
	{
		pos += TriggerGuideSize * comboLength + 1;
		comboLength = triggerMacro->guide[ pos ];
	}

	uint8_t scanCode = ((TriggerGuide*)&triggerMacro->guide[ pos - TriggerGuideSize ])->scanCode;
    589a:	f811 8c01 	ldrb.w	r8, [r1, #-1]

	// Lookup scanCode in buffer list for the current state and stateType
	for ( uint8_t keyIndex = 0; keyIndex < macroTriggerListBufferSize; keyIndex++ )
    589e:	4619      	mov	r1, r3
    58a0:	4561      	cmp	r1, ip
    58a2:	d015      	beq.n	58d0 <Macro_process+0x288>
    58a4:	4d11      	ldr	r5, [pc, #68]	; (58ec <Macro_process+0x2a4>)
    58a6:	eb03 0e05 	add.w	lr, r3, r5
	{
		if ( macroTriggerListBuffer[ keyIndex ].scanCode == scanCode )
    58aa:	f89e 0002 	ldrb.w	r0, [lr, #2]
    58ae:	4540      	cmp	r0, r8
    58b0:	d10a      	bne.n	58c8 <Macro_process+0x280>
		{
			ResultMacroRecordList[ resultMacroIndex ].state     = macroTriggerListBuffer[ keyIndex ].state;
    58b2:	4819      	ldr	r0, [pc, #100]	; (5918 <Macro_process+0x2d0>)
    58b4:	f89e e001 	ldrb.w	lr, [lr, #1]
			ResultMacroRecordList[ resultMacroIndex ].stateType = macroTriggerListBuffer[ keyIndex ].type;
    58b8:	5d5d      	ldrb	r5, [r3, r5]
	// Lookup scanCode in buffer list for the current state and stateType
	for ( uint8_t keyIndex = 0; keyIndex < macroTriggerListBufferSize; keyIndex++ )
	{
		if ( macroTriggerListBuffer[ keyIndex ].scanCode == scanCode )
		{
			ResultMacroRecordList[ resultMacroIndex ].state     = macroTriggerListBuffer[ keyIndex ].state;
    58ba:	f04f 0903 	mov.w	r9, #3
    58be:	fb09 0002 	mla	r0, r9, r2, r0
    58c2:	f880 e001 	strb.w	lr, [r0, #1]
			ResultMacroRecordList[ resultMacroIndex ].stateType = macroTriggerListBuffer[ keyIndex ].type;
    58c6:	7085      	strb	r5, [r0, #2]
	}

	uint8_t scanCode = ((TriggerGuide*)&triggerMacro->guide[ pos - TriggerGuideSize ])->scanCode;

	// Lookup scanCode in buffer list for the current state and stateType
	for ( uint8_t keyIndex = 0; keyIndex < macroTriggerListBufferSize; keyIndex++ )
    58c8:	3101      	adds	r1, #1
    58ca:	b2c9      	uxtb	r1, r1
    58cc:	3303      	adds	r3, #3
    58ce:	e7e7      	b.n	58a0 <Macro_process+0x258>
			ResultMacroRecordList[ resultMacroIndex ].stateType = macroTriggerListBuffer[ keyIndex ].type;
		}
	}

	// Reset the macro position
	ResultMacroRecordList[ resultMacroIndex ].pos = 0;
    58d0:	2303      	movs	r3, #3
    58d2:	435a      	muls	r2, r3
    58d4:	4b10      	ldr	r3, [pc, #64]	; (5918 <Macro_process+0x2d0>)
    58d6:	2100      	movs	r1, #0
    58d8:	5499      	strb	r1, [r3, r2]
	// Tail pointer for macroTriggerMacroPendingList
	// Macros must be explicitly re-added
	var_uint_t macroTriggerMacroPendingListTail = 0;

	// Iterate through the pending TriggerMacros, processing each of them
	for ( var_uint_t macro = 0; macro < macroTriggerMacroPendingListSize; macro++ )
    58da:	3401      	adds	r4, #1
    58dc:	b2e4      	uxtb	r4, r4
    58de:	e74c      	b.n	577a <Macro_process+0x132>
    58e0:	1fff92d6 	.word	0x1fff92d6
    58e4:	1fff92de 	.word	0x1fff92de
    58e8:	1fff89c5 	.word	0x1fff89c5
    58ec:	1fffa13e 	.word	0x1fffa13e
    58f0:	1fff94f3 	.word	0x1fff94f3
    58f4:	1fff9404 	.word	0x1fff9404
    58f8:	1fff92df 	.word	0x1fff92df
    58fc:	1fffa3f6 	.word	0x1fffa3f6
    5900:	1fff92da 	.word	0x1fff92da
    5904:	00009997 	.word	0x00009997
    5908:	1fff940a 	.word	0x1fff940a
    590c:	1fffa501 	.word	0x1fffa501
    5910:	1fff92e0 	.word	0x1fff92e0
    5914:	0000a408 	.word	0x0000a408
    5918:	1fffa249 	.word	0x1fffa249
    591c:	1fff9406 	.word	0x1fff9406
    5920:	1fff940e 	.word	0x1fff940e
	// Tail pointer for macroResultMacroPendingList
	// Macros must be explicitly re-added
	var_uint_t macroResultMacroPendingListTail = 0;

	// Iterate through the pending ResultMacros, processing each of them
	for ( var_uint_t macro = 0; macro < macroResultMacroPendingListSize; macro++ )
    5924:	2500      	movs	r5, #0
			break;
		}
	}

	// Update the macroTriggerMacroPendingListSize with the tail pointer
	macroTriggerMacroPendingListSize = macroTriggerMacroPendingListTail;
    5926:	801f      	strh	r7, [r3, #0]


	// Tail pointer for macroResultMacroPendingList
	// Macros must be explicitly re-added
	var_uint_t macroResultMacroPendingListTail = 0;
    5928:	462f      	mov	r7, r5

	// Iterate through the pending ResultMacros, processing each of them
	for ( var_uint_t macro = 0; macro < macroResultMacroPendingListSize; macro++ )
    592a:	4b30      	ldr	r3, [pc, #192]	; (59ec <Macro_process+0x3a4>)
    592c:	881a      	ldrh	r2, [r3, #0]
    592e:	42aa      	cmp	r2, r5
    5930:	d942      	bls.n	59b8 <Macro_process+0x370>

// Evaluate/Update ResultMacro
inline ResultMacroEval Macro_evalResultMacro( var_uint_t resultMacroIndex )
{
	// Lookup ResultMacro
	const ResultMacro *macro = &ResultMacroList[ resultMacroIndex ];
    5932:	4b2f      	ldr	r3, [pc, #188]	; (59f0 <Macro_process+0x3a8>)
    5934:	4a2f      	ldr	r2, [pc, #188]	; (59f4 <Macro_process+0x3ac>)
    5936:	f813 3015 	ldrb.w	r3, [r3, r5, lsl #1]
	ResultMacroRecord *record = &ResultMacroRecordList[ resultMacroIndex ];
    593a:	f8df 80cc 	ldr.w	r8, [pc, #204]	; 5a08 <Macro_process+0x3c0>
    593e:	f04f 0903 	mov.w	r9, #3
    5942:	fb09 f903 	mul.w	r9, r9, r3

// Evaluate/Update ResultMacro
inline ResultMacroEval Macro_evalResultMacro( var_uint_t resultMacroIndex )
{
	// Lookup ResultMacro
	const ResultMacro *macro = &ResultMacroList[ resultMacroIndex ];
    5946:	eb02 0b83 	add.w	fp, r2, r3, lsl #2
	ResultMacroRecord *record = &ResultMacroRecordList[ resultMacroIndex ];

	// Current Macro position
	var_uint_t pos = record->pos;
    594a:	f819 4008 	ldrb.w	r4, [r9, r8]

	// Length of combo being processed
	uint8_t comboLength = macro->guide[ pos ];
    594e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    5952:	5d1b      	ldrb	r3, [r3, r4]
// Evaluate/Update ResultMacro
inline ResultMacroEval Macro_evalResultMacro( var_uint_t resultMacroIndex )
{
	// Lookup ResultMacro
	const ResultMacro *macro = &ResultMacroList[ resultMacroIndex ];
	ResultMacroRecord *record = &ResultMacroRecordList[ resultMacroIndex ];
    5954:	eb09 0108 	add.w	r1, r9, r8

	// Function Counter, used to keep track of the combo items processed
	var_uint_t funcCount = 0;

	// Combo Item Position within the guide
	var_uint_t comboItem = pos + 1;
    5958:	3401      	adds	r4, #1
// Evaluate/Update ResultMacro
inline ResultMacroEval Macro_evalResultMacro( var_uint_t resultMacroIndex )
{
	// Lookup ResultMacro
	const ResultMacro *macro = &ResultMacroList[ resultMacroIndex ];
	ResultMacroRecord *record = &ResultMacroRecordList[ resultMacroIndex ];
    595a:	9102      	str	r1, [sp, #8]

	// Current Macro position
	var_uint_t pos = record->pos;

	// Length of combo being processed
	uint8_t comboLength = macro->guide[ pos ];
    595c:	9303      	str	r3, [sp, #12]

	// Function Counter, used to keep track of the combo items processed
	var_uint_t funcCount = 0;

	// Combo Item Position within the guide
	var_uint_t comboItem = pos + 1;
    595e:	b2e4      	uxtb	r4, r4

	// Length of combo being processed
	uint8_t comboLength = macro->guide[ pos ];

	// Function Counter, used to keep track of the combo items processed
	var_uint_t funcCount = 0;
    5960:	f04f 0a00 	mov.w	sl, #0

	// Combo Item Position within the guide
	var_uint_t comboItem = pos + 1;

	// Iterate through the Result Combo
	while ( funcCount < comboLength )
    5964:	9b03      	ldr	r3, [sp, #12]
    5966:	f8db 1000 	ldr.w	r1, [fp]
    596a:	459a      	cmp	sl, r3
    596c:	d01b      	beq.n	59a6 <Macro_process+0x35e>
	{
		// Assign TriggerGuide element (key type, state and scancode)
		ResultGuide *guide = (ResultGuide*)(&macro->guide[ comboItem ]);
    596e:	eb01 0e04 	add.w	lr, r1, r4

		// Do lookup on capability function
		void (*capability)(uint8_t, uint8_t, uint8_t*) = (void(*)(uint8_t, uint8_t, uint8_t*))(CapabilitiesList[ guide->index ].func);
    5972:	4b21      	ldr	r3, [pc, #132]	; (59f8 <Macro_process+0x3b0>)
    5974:	5d09      	ldrb	r1, [r1, r4]

		// Call capability
		capability( record->state, record->stateType, &guide->args );
    5976:	9a02      	ldr	r2, [sp, #8]
    5978:	f853 c031 	ldr.w	ip, [r3, r1, lsl #3]
    597c:	7850      	ldrb	r0, [r2, #1]
    597e:	7891      	ldrb	r1, [r2, #2]
    5980:	9301      	str	r3, [sp, #4]
    5982:	f10e 0201 	add.w	r2, lr, #1
    5986:	47e0      	blx	ip

		// Increment counters
		funcCount++;
		comboItem += ResultGuideSize( (ResultGuide*)(&macro->guide[ comboItem ]) );
    5988:	f8db 2000 	ldr.w	r2, [fp]
    598c:	9b01      	ldr	r3, [sp, #4]
    598e:	5d12      	ldrb	r2, [r2, r4]
    5990:	eb03 03c2 	add.w	r3, r3, r2, lsl #3

		// Call capability
		capability( record->state, record->stateType, &guide->args );

		// Increment counters
		funcCount++;
    5994:	f10a 0a01 	add.w	sl, sl, #1
		comboItem += ResultGuideSize( (ResultGuide*)(&macro->guide[ comboItem ]) );
    5998:	791b      	ldrb	r3, [r3, #4]
    599a:	3301      	adds	r3, #1
    599c:	441c      	add	r4, r3

		// Call capability
		capability( record->state, record->stateType, &guide->args );

		// Increment counters
		funcCount++;
    599e:	fa5f fa8a 	uxtb.w	sl, sl
		comboItem += ResultGuideSize( (ResultGuide*)(&macro->guide[ comboItem ]) );
    59a2:	b2e4      	uxtb	r4, r4
    59a4:	e7de      	b.n	5964 <Macro_process+0x31c>
	}

	// Move to next item in the sequence
	record->pos = comboItem;
    59a6:	f809 4008 	strb.w	r4, [r9, r8]

	// If the ResultMacro is finished, remove
	if ( macro->guide[ comboItem ] == 0 )
    59aa:	5d0b      	ldrb	r3, [r1, r4]
    59ac:	b993      	cbnz	r3, 59d4 <Macro_process+0x38c>
	{
		record->pos = 0;
    59ae:	f809 3008 	strb.w	r3, [r9, r8]
	// Tail pointer for macroResultMacroPendingList
	// Macros must be explicitly re-added
	var_uint_t macroResultMacroPendingListTail = 0;

	// Iterate through the pending ResultMacros, processing each of them
	for ( var_uint_t macro = 0; macro < macroResultMacroPendingListSize; macro++ )
    59b2:	3501      	adds	r5, #1
    59b4:	b2ed      	uxtb	r5, r5
    59b6:	e7b8      	b.n	592a <Macro_process+0x2e2>

	// Update the macroResultMacroPendingListSize with the tail pointer
	macroResultMacroPendingListSize = macroResultMacroPendingListTail;

	// Signal buffer that we've used it
	Scan_finishedWithMacro( macroTriggerListBufferSize );
    59b8:	7830      	ldrb	r0, [r6, #0]
			break;
		}
	}

	// Update the macroResultMacroPendingListSize with the tail pointer
	macroResultMacroPendingListSize = macroResultMacroPendingListTail;
    59ba:	801f      	strh	r7, [r3, #0]

	// Signal buffer that we've used it
	Scan_finishedWithMacro( macroTriggerListBufferSize );
    59bc:	f7ff f88c 	bl	4ad8 <Scan_finishedWithMacro>

	// Reset TriggerList buffer
	macroTriggerListBufferSize = 0;

	// If Macro debug mode is set, clear the USB Buffer
	if ( macroDebugMode )
    59c0:	4a0e      	ldr	r2, [pc, #56]	; (59fc <Macro_process+0x3b4>)
    59c2:	7812      	ldrb	r2, [r2, #0]

	// Signal buffer that we've used it
	Scan_finishedWithMacro( macroTriggerListBufferSize );

	// Reset TriggerList buffer
	macroTriggerListBufferSize = 0;
    59c4:	2300      	movs	r3, #0
    59c6:	7033      	strb	r3, [r6, #0]

	// If Macro debug mode is set, clear the USB Buffer
	if ( macroDebugMode )
    59c8:	b162      	cbz	r2, 59e4 <Macro_process+0x39c>
	{
		USBKeys_Modifiers = 0;
    59ca:	4a0d      	ldr	r2, [pc, #52]	; (5a00 <Macro_process+0x3b8>)
		USBKeys_Sent = 0;
    59cc:	490d      	ldr	r1, [pc, #52]	; (5a04 <Macro_process+0x3bc>)
	macroTriggerListBufferSize = 0;

	// If Macro debug mode is set, clear the USB Buffer
	if ( macroDebugMode )
	{
		USBKeys_Modifiers = 0;
    59ce:	7013      	strb	r3, [r2, #0]
		USBKeys_Sent = 0;
    59d0:	700b      	strb	r3, [r1, #0]
    59d2:	e007      	b.n	59e4 <Macro_process+0x39c>
		switch ( Macro_evalResultMacro( macroResultMacroPendingList[ macro ] ) )
		{
		// Re-add macros to pending list
		case ResultMacroEval_DoNothing:
		default:
			macroResultMacroPendingList[ macroResultMacroPendingListTail++ ] = macroResultMacroPendingList[ macro ];
    59d4:	4b06      	ldr	r3, [pc, #24]	; (59f0 <Macro_process+0x3a8>)
    59d6:	f833 1015 	ldrh.w	r1, [r3, r5, lsl #1]
    59da:	1c7a      	adds	r2, r7, #1
    59dc:	f823 1017 	strh.w	r1, [r3, r7, lsl #1]
    59e0:	b2d7      	uxtb	r7, r2
			break;
    59e2:	e7e6      	b.n	59b2 <Macro_process+0x36a>
	if ( macroDebugMode )
	{
		USBKeys_Modifiers = 0;
		USBKeys_Sent = 0;
	}
}
    59e4:	b005      	add	sp, #20
    59e6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    59ea:	bf00      	nop
    59ec:	1fff9406 	.word	0x1fff9406
    59f0:	1fff940e 	.word	0x1fff940e
    59f4:	00009ebc 	.word	0x00009ebc
    59f8:	0000a1f8 	.word	0x0000a1f8
    59fc:	1fff940c 	.word	0x1fff940c
    5a00:	1fff94ef 	.word	0x1fff94ef
    5a04:	1fff94f3 	.word	0x1fff94f3
    5a08:	1fffa249 	.word	0x1fffa249

00005a0c <Macro_setup>:


inline void Macro_setup()
{
    5a0c:	b508      	push	{r3, lr}
	// Register Macro CLI dictionary
	CLI_registerDictionary( macroCLIDict, macroCLIDictName );
    5a0e:	4812      	ldr	r0, [pc, #72]	; (5a58 <Macro_setup+0x4c>)
    5a10:	4912      	ldr	r1, [pc, #72]	; (5a5c <Macro_setup+0x50>)
    5a12:	f001 fcb9 	bl	7388 <CLI_registerDictionary>

	// Disable Macro debug mode
	macroDebugMode = 0;
    5a16:	4a12      	ldr	r2, [pc, #72]	; (5a60 <Macro_setup+0x54>)
    5a18:	2300      	movs	r3, #0
    5a1a:	7013      	strb	r3, [r2, #0]

	// Disable Macro pause flag
	macroPauseMode = 0;
    5a1c:	4a11      	ldr	r2, [pc, #68]	; (5a64 <Macro_setup+0x58>)
    5a1e:	7013      	strb	r3, [r2, #0]

	// Set Macro step counter to zero
	macroStepCounter = 0;
    5a20:	4a11      	ldr	r2, [pc, #68]	; (5a68 <Macro_setup+0x5c>)
    5a22:	8013      	strh	r3, [r2, #0]

	// Make sure macro trigger buffer is empty
	macroTriggerListBufferSize = 0;
    5a24:	4a11      	ldr	r2, [pc, #68]	; (5a6c <Macro_setup+0x60>)
    5a26:	7013      	strb	r3, [r2, #0]

	// Set the current rotated layer to 0
	Macro_rotationLayer = 0;
    5a28:	4a11      	ldr	r2, [pc, #68]	; (5a70 <Macro_setup+0x64>)
    5a2a:	8013      	strh	r3, [r2, #0]

	// Initialize TriggerMacro states
	for ( var_uint_t macro = 0; macro < TriggerMacroNum; macro++ )
	{
		TriggerMacroRecordList[ macro ].pos   = 0;
    5a2c:	4911      	ldr	r1, [pc, #68]	; (5a74 <Macro_setup+0x68>)
    5a2e:	2200      	movs	r2, #0
    5a30:	1858      	adds	r0, r3, r1
    5a32:	545a      	strb	r2, [r3, r1]
		TriggerMacroRecordList[ macro ].state = TriggerMacro_Waiting;
    5a34:	2102      	movs	r1, #2
    5a36:	440b      	add	r3, r1

	// Set the current rotated layer to 0
	Macro_rotationLayer = 0;

	// Initialize TriggerMacro states
	for ( var_uint_t macro = 0; macro < TriggerMacroNum; macro++ )
    5a38:	f5b3 7f8d 	cmp.w	r3, #282	; 0x11a
	{
		TriggerMacroRecordList[ macro ].pos   = 0;
		TriggerMacroRecordList[ macro ].state = TriggerMacro_Waiting;
    5a3c:	7041      	strb	r1, [r0, #1]

	// Set the current rotated layer to 0
	Macro_rotationLayer = 0;

	// Initialize TriggerMacro states
	for ( var_uint_t macro = 0; macro < TriggerMacroNum; macro++ )
    5a3e:	d1f5      	bne.n	5a2c <Macro_setup+0x20>
    5a40:	4613      	mov	r3, r2
	}

	// Initialize ResultMacro states
	for ( var_uint_t macro = 0; macro < ResultMacroNum; macro++ )
	{
		ResultMacroRecordList[ macro ].pos       = 0;
    5a42:	480d      	ldr	r0, [pc, #52]	; (5a78 <Macro_setup+0x6c>)
    5a44:	2200      	movs	r2, #0
    5a46:	1819      	adds	r1, r3, r0
    5a48:	541a      	strb	r2, [r3, r0]
    5a4a:	3303      	adds	r3, #3
		TriggerMacroRecordList[ macro ].pos   = 0;
		TriggerMacroRecordList[ macro ].state = TriggerMacro_Waiting;
	}

	// Initialize ResultMacro states
	for ( var_uint_t macro = 0; macro < ResultMacroNum; macro++ )
    5a4c:	f5b3 7fa8 	cmp.w	r3, #336	; 0x150
	{
		ResultMacroRecordList[ macro ].pos       = 0;
		ResultMacroRecordList[ macro ].state     = 0;
    5a50:	704a      	strb	r2, [r1, #1]
		ResultMacroRecordList[ macro ].stateType = 0;
    5a52:	708a      	strb	r2, [r1, #2]
		TriggerMacroRecordList[ macro ].pos   = 0;
		TriggerMacroRecordList[ macro ].state = TriggerMacro_Waiting;
	}

	// Initialize ResultMacro states
	for ( var_uint_t macro = 0; macro < ResultMacroNum; macro++ )
    5a54:	d1f5      	bne.n	5a42 <Macro_setup+0x36>
	{
		ResultMacroRecordList[ macro ].pos       = 0;
		ResultMacroRecordList[ macro ].state     = 0;
		ResultMacroRecordList[ macro ].stateType = 0;
	}
}
    5a56:	bd08      	pop	{r3, pc}
    5a58:	00009d64 	.word	0x00009d64
    5a5c:	00009b64 	.word	0x00009b64
    5a60:	1fff940c 	.word	0x1fff940c
    5a64:	1fff92df 	.word	0x1fff92df
    5a68:	1fff92da 	.word	0x1fff92da
    5a6c:	1fff92de 	.word	0x1fff92de
    5a70:	1fffa13c 	.word	0x1fffa13c
    5a74:	1fffa501 	.word	0x1fffa501
    5a78:	1fffa249 	.word	0x1fffa249

00005a7c <macroDebugShowTrigger>:
}

void macroDebugShowTrigger( var_uint_t index )
{
	// Only proceed if the macro exists
	if ( index >= TriggerMacroNum )
    5a7c:	288c      	cmp	r0, #140	; 0x8c
	info_msg("Macro Processing Mode: ");
	printInt8( macroPauseMode );
}

void macroDebugShowTrigger( var_uint_t index )
{
    5a7e:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    5a82:	4605      	mov	r5, r0
	// Only proceed if the macro exists
	if ( index >= TriggerMacroNum )
    5a84:	d867      	bhi.n	5b56 <macroDebugShowTrigger+0xda>
		return;

	// Trigger Macro Show
	const TriggerMacro *macro = &TriggerMacroList[ index ];
    5a86:	4c35      	ldr	r4, [pc, #212]	; (5b5c <macroDebugShowTrigger+0xe0>)
	TriggerMacroRecord *record = &TriggerMacroRecordList[ index ];
    5a88:	f8df 9100 	ldr.w	r9, [pc, #256]	; 5b8c <macroDebugShowTrigger+0x110>
	// Only proceed if the macro exists
	if ( index >= TriggerMacroNum )
		return;

	// Trigger Macro Show
	const TriggerMacro *macro = &TriggerMacroList[ index ];
    5a8c:	eb04 08c0 	add.w	r8, r4, r0, lsl #3
	TriggerMacroRecord *record = &TriggerMacroRecordList[ index ];
    5a90:	eb09 0a40 	add.w	sl, r9, r0, lsl #1

	print( NL );
    5a94:	4832      	ldr	r0, [pc, #200]	; (5b60 <macroDebugShowTrigger+0xe4>)
    5a96:	f001 feb5 	bl	7804 <_print>
	info_msg("Trigger Macro Index: ");
    5a9a:	4832      	ldr	r0, [pc, #200]	; (5b64 <macroDebugShowTrigger+0xe8>)
    5a9c:	f001 feb2 	bl	7804 <_print>
	printInt16( (uint16_t)index ); // Hopefully large enough :P (can't assume 32-bit)
    5aa0:	4628      	mov	r0, r5
    5aa2:	f001 ff01 	bl	78a8 <printInt16>
	print( NL );
    5aa6:	482e      	ldr	r0, [pc, #184]	; (5b60 <macroDebugShowTrigger+0xe4>)
    5aa8:	f001 feac 	bl	7804 <_print>

	// Read the comboLength for combo in the sequence (sequence of combos)
	var_uint_t pos = 0;
	uint8_t comboLength = macro->guide[ pos ];
    5aac:	f854 3035 	ldr.w	r3, [r4, r5, lsl #3]
    5ab0:	781e      	ldrb	r6, [r3, #0]
	info_msg("Trigger Macro Index: ");
	printInt16( (uint16_t)index ); // Hopefully large enough :P (can't assume 32-bit)
	print( NL );

	// Read the comboLength for combo in the sequence (sequence of combos)
	var_uint_t pos = 0;
    5ab2:	2400      	movs	r4, #0
	uint8_t comboLength = macro->guide[ pos ];

	// Iterate through and interpret the guide
	while ( comboLength != 0 )
    5ab4:	b366      	cbz	r6, 5b10 <macroDebugShowTrigger+0x94>
	{
		// Initial position of the combo
		var_uint_t comboPos = ++pos;
    5ab6:	3401      	adds	r4, #1
    5ab8:	b2e4      	uxtb	r4, r4

		// Iterate through the combo
		while ( pos < comboLength * TriggerGuideSize + comboPos )
    5aba:	2303      	movs	r3, #3
    5abc:	fb13 4606 	smlabb	r6, r3, r6, r4
    5ac0:	42b4      	cmp	r4, r6
    5ac2:	f8d8 7000 	ldr.w	r7, [r8]
    5ac6:	d21d      	bcs.n	5b04 <macroDebugShowTrigger+0x88>
		{
			// Assign TriggerGuide element (key type, state and scancode)
			TriggerGuide *guide = (TriggerGuide*)(&macro->guide[ pos ]);
    5ac8:	eb07 0b04 	add.w	fp, r7, r4

			// Display guide information about trigger key
			printHex( guide->scanCode );
    5acc:	2101      	movs	r1, #1
    5ace:	f89b 0002 	ldrb.w	r0, [fp, #2]
    5ad2:	f001 ff20 	bl	7916 <printHex_op>
			print("|");
    5ad6:	4824      	ldr	r0, [pc, #144]	; (5b68 <macroDebugShowTrigger+0xec>)
    5ad8:	f001 fe94 	bl	7804 <_print>
			printHex( guide->type );
    5adc:	5d38      	ldrb	r0, [r7, r4]
    5ade:	2101      	movs	r1, #1
    5ae0:	f001 ff19 	bl	7916 <printHex_op>
			print("|");
			printHex( guide->state );

			// Increment position
			pos += TriggerGuideSize;
    5ae4:	3403      	adds	r4, #3

			// Display guide information about trigger key
			printHex( guide->scanCode );
			print("|");
			printHex( guide->type );
			print("|");
    5ae6:	4820      	ldr	r0, [pc, #128]	; (5b68 <macroDebugShowTrigger+0xec>)
    5ae8:	f001 fe8c 	bl	7804 <_print>
			printHex( guide->state );

			// Increment position
			pos += TriggerGuideSize;
    5aec:	b2e4      	uxtb	r4, r4
			// Display guide information about trigger key
			printHex( guide->scanCode );
			print("|");
			printHex( guide->type );
			print("|");
			printHex( guide->state );
    5aee:	f89b 0001 	ldrb.w	r0, [fp, #1]
    5af2:	2101      	movs	r1, #1
    5af4:	f001 ff0f 	bl	7916 <printHex_op>

			// Increment position
			pos += TriggerGuideSize;

			// Only show combo separator if there are combos left in the sequence element
			if ( pos < comboLength * TriggerGuideSize + comboPos )
    5af8:	42b4      	cmp	r4, r6
    5afa:	d2e1      	bcs.n	5ac0 <macroDebugShowTrigger+0x44>
				print("+");
    5afc:	481b      	ldr	r0, [pc, #108]	; (5b6c <macroDebugShowTrigger+0xf0>)
    5afe:	f001 fe81 	bl	7804 <_print>
    5b02:	e7dd      	b.n	5ac0 <macroDebugShowTrigger+0x44>
		}

		// Read the next comboLength
		comboLength = macro->guide[ pos ];
    5b04:	5d3e      	ldrb	r6, [r7, r4]

		// Only show sequence separator if there is another combo to process
		if ( comboLength != 0 )
    5b06:	b11e      	cbz	r6, 5b10 <macroDebugShowTrigger+0x94>
			print(";");
    5b08:	4819      	ldr	r0, [pc, #100]	; (5b70 <macroDebugShowTrigger+0xf4>)
    5b0a:	f001 fe7b 	bl	7804 <_print>
    5b0e:	e7d1      	b.n	5ab4 <macroDebugShowTrigger+0x38>
	}

	// Display current position
	print( NL "Position: " );
    5b10:	4818      	ldr	r0, [pc, #96]	; (5b74 <macroDebugShowTrigger+0xf8>)
    5b12:	f001 fe77 	bl	7804 <_print>
	printInt16( (uint16_t)record->pos ); // Hopefully large enough :P (can't assume 32-bit)
    5b16:	f819 0015 	ldrb.w	r0, [r9, r5, lsl #1]
    5b1a:	f001 fec5 	bl	78a8 <printInt16>

	// Display result macro index
	print( NL "Result Macro Index: " );
    5b1e:	4816      	ldr	r0, [pc, #88]	; (5b78 <macroDebugShowTrigger+0xfc>)
    5b20:	f001 fe70 	bl	7804 <_print>
	printInt16( (uint16_t)macro->result ); // Hopefully large enough :P (can't assume 32-bit)
    5b24:	f898 0004 	ldrb.w	r0, [r8, #4]
    5b28:	f001 febe 	bl	78a8 <printInt16>

	// Display trigger macro state
	print( NL "Trigger Macro State: " );
    5b2c:	4813      	ldr	r0, [pc, #76]	; (5b7c <macroDebugShowTrigger+0x100>)
    5b2e:	f001 fe69 	bl	7804 <_print>
	switch ( record->state )
    5b32:	f89a 3001 	ldrb.w	r3, [sl, #1]
    5b36:	2b01      	cmp	r3, #1
    5b38:	d006      	beq.n	5b48 <macroDebugShowTrigger+0xcc>
    5b3a:	d303      	bcc.n	5b44 <macroDebugShowTrigger+0xc8>
    5b3c:	2b02      	cmp	r3, #2
    5b3e:	d005      	beq.n	5b4c <macroDebugShowTrigger+0xd0>
    5b40:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	{
	case TriggerMacro_Press:   print("Press");   break;
    5b44:	480e      	ldr	r0, [pc, #56]	; (5b80 <macroDebugShowTrigger+0x104>)
    5b46:	e002      	b.n	5b4e <macroDebugShowTrigger+0xd2>
	case TriggerMacro_Release: print("Release"); break;
    5b48:	480e      	ldr	r0, [pc, #56]	; (5b84 <macroDebugShowTrigger+0x108>)
    5b4a:	e000      	b.n	5b4e <macroDebugShowTrigger+0xd2>
	case TriggerMacro_Waiting: print("Waiting"); break;
    5b4c:	480e      	ldr	r0, [pc, #56]	; (5b88 <macroDebugShowTrigger+0x10c>)
	}
}
    5b4e:	e8bd 4ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	print( NL "Trigger Macro State: " );
	switch ( record->state )
	{
	case TriggerMacro_Press:   print("Press");   break;
	case TriggerMacro_Release: print("Release"); break;
	case TriggerMacro_Waiting: print("Waiting"); break;
    5b52:	f001 be57 	b.w	7804 <_print>
    5b56:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    5b5a:	bf00      	nop
    5b5c:	0000a408 	.word	0x0000a408
    5b60:	0000bafb 	.word	0x0000bafb
    5b64:	000099b7 	.word	0x000099b7
    5b68:	000099df 	.word	0x000099df
    5b6c:	00008f2e 	.word	0x00008f2e
    5b70:	000099e1 	.word	0x000099e1
    5b74:	000099e3 	.word	0x000099e3
    5b78:	000099f0 	.word	0x000099f0
    5b7c:	00009a07 	.word	0x00009a07
    5b80:	00009a94 	.word	0x00009a94
    5b84:	00009a9d 	.word	0x00009a9d
    5b88:	00009a1f 	.word	0x00009a1f
    5b8c:	1fffa501 	.word	0x1fffa501

00005b90 <macroDebugShowResult>:
}

void macroDebugShowResult( var_uint_t index )
{
	// Only proceed if the macro exists
	if ( index >= ResultMacroNum )
    5b90:	286f      	cmp	r0, #111	; 0x6f
	case TriggerMacro_Waiting: print("Waiting"); break;
	}
}

void macroDebugShowResult( var_uint_t index )
{
    5b92:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    5b96:	4604      	mov	r4, r0
	// Only proceed if the macro exists
	if ( index >= ResultMacroNum )
    5b98:	f200 8097 	bhi.w	5cca <macroDebugShowResult+0x13a>
		return;

	// Trigger Macro Show
	const ResultMacro *macro = &ResultMacroList[ index ];
    5b9c:	4d4c      	ldr	r5, [pc, #304]	; (5cd0 <macroDebugShowResult+0x140>)
	ResultMacroRecord *record = &ResultMacroRecordList[ index ];
    5b9e:	4b4d      	ldr	r3, [pc, #308]	; (5cd4 <macroDebugShowResult+0x144>)
    5ba0:	f04f 0903 	mov.w	r9, #3
    5ba4:	fb09 f900 	mul.w	r9, r9, r0
    5ba8:	444b      	add	r3, r9
	// Only proceed if the macro exists
	if ( index >= ResultMacroNum )
		return;

	// Trigger Macro Show
	const ResultMacro *macro = &ResultMacroList[ index ];
    5baa:	eb05 0880 	add.w	r8, r5, r0, lsl #2
	ResultMacroRecord *record = &ResultMacroRecordList[ index ];

	print( NL );
    5bae:	484a      	ldr	r0, [pc, #296]	; (5cd8 <macroDebugShowResult+0x148>)
	if ( index >= ResultMacroNum )
		return;

	// Trigger Macro Show
	const ResultMacro *macro = &ResultMacroList[ index ];
	ResultMacroRecord *record = &ResultMacroRecordList[ index ];
    5bb0:	9301      	str	r3, [sp, #4]

	print( NL );
    5bb2:	f001 fe27 	bl	7804 <_print>
	info_msg("Result Macro Index: ");
    5bb6:	4849      	ldr	r0, [pc, #292]	; (5cdc <macroDebugShowResult+0x14c>)
    5bb8:	f001 fe24 	bl	7804 <_print>
	printInt16( (uint16_t)index ); // Hopefully large enough :P (can't assume 32-bit)
    5bbc:	4620      	mov	r0, r4
    5bbe:	f001 fe73 	bl	78a8 <printInt16>
	print( NL );
    5bc2:	4845      	ldr	r0, [pc, #276]	; (5cd8 <macroDebugShowResult+0x148>)
    5bc4:	f001 fe1e 	bl	7804 <_print>

	// Read the comboLength for combo in the sequence (sequence of combos)
	var_uint_t pos = 0;
	uint8_t comboLength = macro->guide[ pos++ ];
    5bc8:	f855 3024 	ldr.w	r3, [r5, r4, lsl #2]
    5bcc:	781d      	ldrb	r5, [r3, #0]
    5bce:	2601      	movs	r6, #1

	// Iterate through and interpret the guide
	while ( comboLength != 0 )
    5bd0:	b9d5      	cbnz	r5, 5c08 <macroDebugShowResult+0x78>
		if ( comboLength != 0 )
			print(";");
	}

	// Display current position
	print( NL "Position: " );
    5bd2:	4843      	ldr	r0, [pc, #268]	; (5ce0 <macroDebugShowResult+0x150>)
    5bd4:	f001 fe16 	bl	7804 <_print>
	printInt16( (uint16_t)record->pos ); // Hopefully large enough :P (can't assume 32-bit)
    5bd8:	493e      	ldr	r1, [pc, #248]	; (5cd4 <macroDebugShowResult+0x144>)
    5bda:	f811 0009 	ldrb.w	r0, [r1, r9]
    5bde:	f001 fe63 	bl	78a8 <printInt16>

	// Display final trigger state/type
	print( NL "Final Trigger State (State/Type): " );
    5be2:	4840      	ldr	r0, [pc, #256]	; (5ce4 <macroDebugShowResult+0x154>)
    5be4:	f001 fe0e 	bl	7804 <_print>
	printHex( record->state );
    5be8:	9b01      	ldr	r3, [sp, #4]
    5bea:	2101      	movs	r1, #1
    5bec:	7858      	ldrb	r0, [r3, #1]
    5bee:	f001 fe92 	bl	7916 <printHex_op>
	print("/");
    5bf2:	483d      	ldr	r0, [pc, #244]	; (5ce8 <macroDebugShowResult+0x158>)
    5bf4:	f001 fe06 	bl	7804 <_print>
	printHex( record->stateType );
    5bf8:	9b01      	ldr	r3, [sp, #4]
    5bfa:	7898      	ldrb	r0, [r3, #2]
    5bfc:	2101      	movs	r1, #1
}
    5bfe:	b003      	add	sp, #12
    5c00:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}

	// Display final trigger state/type
	print( NL "Final Trigger State (State/Type): " );
	printHex( record->state );
	print("/");
	printHex( record->stateType );
    5c04:	f001 be87 	b.w	7916 <printHex_op>
	// Read the comboLength for combo in the sequence (sequence of combos)
	var_uint_t pos = 0;
	uint8_t comboLength = macro->guide[ pos++ ];

	// Iterate through and interpret the guide
	while ( comboLength != 0 )
    5c08:	4634      	mov	r4, r6
    5c0a:	2600      	movs	r6, #0

		// Iterate through the combo
		while ( funcCount < comboLength )
		{
			// Assign TriggerGuide element (key type, state and scancode)
			ResultGuide *guide = (ResultGuide*)(&macro->guide[ pos ]);
    5c0c:	f8d8 a000 	ldr.w	sl, [r8]
			// Display Function Index
			printHex( guide->index );
			print("|");

			// Display Function Ptr Address
			printHex( (nat_ptr_t)CapabilitiesList[ guide->index ].func );
    5c10:	f8df b0f0 	ldr.w	fp, [pc, #240]	; 5d04 <macroDebugShowResult+0x174>
		{
			// Assign TriggerGuide element (key type, state and scancode)
			ResultGuide *guide = (ResultGuide*)(&macro->guide[ pos ]);

			// Display Function Index
			printHex( guide->index );
    5c14:	f81a 0004 	ldrb.w	r0, [sl, r4]
    5c18:	2101      	movs	r1, #1
    5c1a:	f001 fe7c 	bl	7916 <printHex_op>
			print("|");
    5c1e:	4833      	ldr	r0, [pc, #204]	; (5cec <macroDebugShowResult+0x15c>)
    5c20:	f001 fdf0 	bl	7804 <_print>

			// Display Function Ptr Address
			printHex( (nat_ptr_t)CapabilitiesList[ guide->index ].func );
    5c24:	f81a 2004 	ldrb.w	r2, [sl, r4]
    5c28:	2101      	movs	r1, #1
    5c2a:	f83b 0032 	ldrh.w	r0, [fp, r2, lsl #3]
    5c2e:	f001 fe72 	bl	7916 <printHex_op>
			print("|");
    5c32:	482e      	ldr	r0, [pc, #184]	; (5cec <macroDebugShowResult+0x15c>)
    5c34:	f001 fde6 	bl	7804 <_print>

			// Display/Lookup Capability Name (utilize debug mode of capability)
			void (*capability)(uint8_t, uint8_t, uint8_t*) = (void(*)(uint8_t, uint8_t, uint8_t*))(CapabilitiesList[ guide->index ].func);
    5c38:	f81a 3004 	ldrb.w	r3, [sl, r4]
			capability( 0xFF, 0xFF, 0 );
    5c3c:	20ff      	movs	r0, #255	; 0xff
    5c3e:	f85b 3033 	ldr.w	r3, [fp, r3, lsl #3]
    5c42:	4601      	mov	r1, r0
    5c44:	2200      	movs	r2, #0
    5c46:	4798      	blx	r3

			// Display Argument(s)
			print("(");
    5c48:	4829      	ldr	r0, [pc, #164]	; (5cf0 <macroDebugShowResult+0x160>)
    5c4a:	f001 fddb 	bl	7804 <_print>

		// Iterate through the combo
		while ( funcCount < comboLength )
		{
			// Assign TriggerGuide element (key type, state and scancode)
			ResultGuide *guide = (ResultGuide*)(&macro->guide[ pos ]);
    5c4e:	eb0a 0704 	add.w	r7, sl, r4
			void (*capability)(uint8_t, uint8_t, uint8_t*) = (void(*)(uint8_t, uint8_t, uint8_t*))(CapabilitiesList[ guide->index ].func);
			capability( 0xFF, 0xFF, 0 );

			// Display Argument(s)
			print("(");
			for ( var_uint_t arg = 0; arg < CapabilitiesList[ guide->index ].argCount; arg++ )
    5c52:	2300      	movs	r3, #0
    5c54:	f8df b0ac 	ldr.w	fp, [pc, #172]	; 5d04 <macroDebugShowResult+0x174>
    5c58:	783a      	ldrb	r2, [r7, #0]
    5c5a:	eb0b 02c2 	add.w	r2, fp, r2, lsl #3
    5c5e:	7912      	ldrb	r2, [r2, #4]
    5c60:	429a      	cmp	r2, r3
    5c62:	d914      	bls.n	5c8e <macroDebugShowResult+0xfe>
			{
				// Arguments are only 8 bit values
				printHex( (&guide->args)[ arg ] );
    5c64:	18fa      	adds	r2, r7, r3
    5c66:	2101      	movs	r1, #1
    5c68:	7850      	ldrb	r0, [r2, #1]
    5c6a:	9300      	str	r3, [sp, #0]
    5c6c:	f001 fe53 	bl	7916 <printHex_op>

				// Only show arg separator if there are args left
				if ( arg + 1 < CapabilitiesList[ guide->index ].argCount )
    5c70:	783a      	ldrb	r2, [r7, #0]
    5c72:	9b00      	ldr	r3, [sp, #0]
    5c74:	eb0b 02c2 	add.w	r2, fp, r2, lsl #3
    5c78:	3301      	adds	r3, #1
    5c7a:	7912      	ldrb	r2, [r2, #4]
    5c7c:	4293      	cmp	r3, r2
    5c7e:	da04      	bge.n	5c8a <macroDebugShowResult+0xfa>
					print(",");
    5c80:	481c      	ldr	r0, [pc, #112]	; (5cf4 <macroDebugShowResult+0x164>)
    5c82:	9300      	str	r3, [sp, #0]
    5c84:	f001 fdbe 	bl	7804 <_print>
    5c88:	9b00      	ldr	r3, [sp, #0]
			void (*capability)(uint8_t, uint8_t, uint8_t*) = (void(*)(uint8_t, uint8_t, uint8_t*))(CapabilitiesList[ guide->index ].func);
			capability( 0xFF, 0xFF, 0 );

			// Display Argument(s)
			print("(");
			for ( var_uint_t arg = 0; arg < CapabilitiesList[ guide->index ].argCount; arg++ )
    5c8a:	b2db      	uxtb	r3, r3
    5c8c:	e7e2      	b.n	5c54 <macroDebugShowResult+0xc4>

				// Only show arg separator if there are args left
				if ( arg + 1 < CapabilitiesList[ guide->index ].argCount )
					print(",");
			}
			print(")");
    5c8e:	481a      	ldr	r0, [pc, #104]	; (5cf8 <macroDebugShowResult+0x168>)
    5c90:	f001 fdb8 	bl	7804 <_print>

			// Increment position
			pos += ResultGuideSize( guide );
    5c94:	783b      	ldrb	r3, [r7, #0]
    5c96:	eb0b 03c3 	add.w	r3, fp, r3, lsl #3

			// Increment function count
			funcCount++;
    5c9a:	3601      	adds	r6, #1
					print(",");
			}
			print(")");

			// Increment position
			pos += ResultGuideSize( guide );
    5c9c:	791b      	ldrb	r3, [r3, #4]

			// Increment function count
			funcCount++;
    5c9e:	b2f6      	uxtb	r6, r6
					print(",");
			}
			print(")");

			// Increment position
			pos += ResultGuideSize( guide );
    5ca0:	3301      	adds	r3, #1
    5ca2:	441c      	add	r4, r3

			// Increment function count
			funcCount++;

			// Only show combo separator if there are combos left in the sequence element
			if ( funcCount < comboLength )
    5ca4:	42ae      	cmp	r6, r5
					print(",");
			}
			print(")");

			// Increment position
			pos += ResultGuideSize( guide );
    5ca6:	b2e4      	uxtb	r4, r4

			// Increment function count
			funcCount++;

			// Only show combo separator if there are combos left in the sequence element
			if ( funcCount < comboLength )
    5ca8:	d202      	bcs.n	5cb0 <macroDebugShowResult+0x120>
				print("+");
    5caa:	4814      	ldr	r0, [pc, #80]	; (5cfc <macroDebugShowResult+0x16c>)
    5cac:	f001 fdaa 	bl	7804 <_print>
	{
		// Function Counter, used to keep track of the combos processed
		var_uint_t funcCount = 0;

		// Iterate through the combo
		while ( funcCount < comboLength )
    5cb0:	42ae      	cmp	r6, r5
    5cb2:	d1ab      	bne.n	5c0c <macroDebugShowResult+0x7c>
			if ( funcCount < comboLength )
				print("+");
		}

		// Read the next comboLength
		comboLength = macro->guide[ pos++ ];
    5cb4:	f8d8 3000 	ldr.w	r3, [r8]
    5cb8:	5d1d      	ldrb	r5, [r3, r4]
    5cba:	1c66      	adds	r6, r4, #1
    5cbc:	b2f6      	uxtb	r6, r6

		// Only show sequence separator if there is another combo to process
		if ( comboLength != 0 )
    5cbe:	2d00      	cmp	r5, #0
    5cc0:	d087      	beq.n	5bd2 <macroDebugShowResult+0x42>
			print(";");
    5cc2:	480f      	ldr	r0, [pc, #60]	; (5d00 <macroDebugShowResult+0x170>)
    5cc4:	f001 fd9e 	bl	7804 <_print>
    5cc8:	e782      	b.n	5bd0 <macroDebugShowResult+0x40>
	// Display final trigger state/type
	print( NL "Final Trigger State (State/Type): " );
	printHex( record->state );
	print("/");
	printHex( record->stateType );
}
    5cca:	b003      	add	sp, #12
    5ccc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    5cd0:	00009ebc 	.word	0x00009ebc
    5cd4:	1fffa249 	.word	0x1fffa249
    5cd8:	0000bafb 	.word	0x0000bafb
    5cdc:	00009a27 	.word	0x00009a27
    5ce0:	000099e3 	.word	0x000099e3
    5ce4:	00009a52 	.word	0x00009a52
    5ce8:	00008e6c 	.word	0x00008e6c
    5cec:	000099df 	.word	0x000099df
    5cf0:	00009a4e 	.word	0x00009a4e
    5cf4:	00009a50 	.word	0x00009a50
    5cf8:	0000b5ef 	.word	0x0000b5ef
    5cfc:	00008f2e 	.word	0x00008f2e
    5d00:	000099e1 	.word	0x000099e1
    5d04:	0000a1f8 	.word	0x0000a1f8

00005d08 <cliFunc_macroShow>:

void cliFunc_macroShow( char* args )
{
    5d08:	b507      	push	{r0, r1, r2, lr}
	// Parse codes from arguments
	char* curArgs;
	char* arg1Ptr;
	char* arg2Ptr = args;
    5d0a:	9001      	str	r0, [sp, #4]

	// Process all args
	for ( ;; )
	{
		curArgs = arg2Ptr;
		CLI_argumentIsolation( curArgs, &arg1Ptr, &arg2Ptr );
    5d0c:	9801      	ldr	r0, [sp, #4]
    5d0e:	4669      	mov	r1, sp
    5d10:	aa01      	add	r2, sp, #4
    5d12:	f001 fac5 	bl	72a0 <CLI_argumentIsolation>

		// Stop processing args if no more are found
		if ( *arg1Ptr == '\0' )
    5d16:	9800      	ldr	r0, [sp, #0]
    5d18:	7803      	ldrb	r3, [r0, #0]
    5d1a:	b18b      	cbz	r3, 5d40 <cliFunc_macroShow+0x38>
			break;

		// Ignore invalid codes
		switch ( arg1Ptr[0] )
    5d1c:	2b52      	cmp	r3, #82	; 0x52
    5d1e:	d008      	beq.n	5d32 <cliFunc_macroShow+0x2a>
    5d20:	2b54      	cmp	r3, #84	; 0x54
    5d22:	d1f3      	bne.n	5d0c <cliFunc_macroShow+0x4>
		{
		// Indexed Trigger Macro
		case 'T':
			macroDebugShowTrigger( numToInt( &arg1Ptr[1] ) );
    5d24:	3001      	adds	r0, #1
    5d26:	f001 fe4b 	bl	79c0 <numToInt>
    5d2a:	b2c0      	uxtb	r0, r0
    5d2c:	f7ff fea6 	bl	5a7c <macroDebugShowTrigger>
			break;
    5d30:	e7ec      	b.n	5d0c <cliFunc_macroShow+0x4>
		// Indexed Result Macro
		case 'R':
			macroDebugShowResult( numToInt( &arg1Ptr[1] ) );
    5d32:	3001      	adds	r0, #1
    5d34:	f001 fe44 	bl	79c0 <numToInt>
    5d38:	b2c0      	uxtb	r0, r0
    5d3a:	f7ff ff29 	bl	5b90 <macroDebugShowResult>
			break;
    5d3e:	e7e5      	b.n	5d0c <cliFunc_macroShow+0x4>
		}
	}
}
    5d40:	b003      	add	sp, #12
    5d42:	f85d fb04 	ldr.w	pc, [sp], #4
    5d46:	0000      	movs	r0, r0

00005d48 <cliFunc_sendKeys>:


void cliFunc_sendKeys( char* args )
{
	// Copy USBKeys_KeysCLI to USBKeys_Keys
	for ( uint8_t key = 0; key < USBKeys_SentCLI; ++key )
    5d48:	4b04      	ldr	r3, [pc, #16]	; (5d5c <cliFunc_sendKeys+0x14>)
	{
		// TODO
		//USBKeys_Keys[key] = USBKeys_KeysCLI[key];
	}
	USBKeys_Sent = USBKeys_SentCLI;
    5d4a:	781a      	ldrb	r2, [r3, #0]
    5d4c:	4b04      	ldr	r3, [pc, #16]	; (5d60 <cliFunc_sendKeys+0x18>)
    5d4e:	701a      	strb	r2, [r3, #0]

	// Set modifier byte
	USBKeys_Modifiers = USBKeys_ModifiersCLI;
    5d50:	4b04      	ldr	r3, [pc, #16]	; (5d64 <cliFunc_sendKeys+0x1c>)
    5d52:	781a      	ldrb	r2, [r3, #0]
    5d54:	4b04      	ldr	r3, [pc, #16]	; (5d68 <cliFunc_sendKeys+0x20>)
    5d56:	701a      	strb	r2, [r3, #0]
    5d58:	4770      	bx	lr
    5d5a:	bf00      	nop
    5d5c:	1fff94f4 	.word	0x1fff94f4
    5d60:	1fff94f3 	.word	0x1fff94f3
    5d64:	1fff94f6 	.word	0x1fff94f6
    5d68:	1fff94ef 	.word	0x1fff94ef

00005d6c <cliFunc_kbdProtocol>:


// ----- CLI Command Functions -----

void cliFunc_kbdProtocol( char* args )
{
    5d6c:	b508      	push	{r3, lr}
	print( NL );
    5d6e:	4806      	ldr	r0, [pc, #24]	; (5d88 <cliFunc_kbdProtocol+0x1c>)
    5d70:	f001 fd48 	bl	7804 <_print>
	info_msg("Keyboard Protocol: ");
    5d74:	4805      	ldr	r0, [pc, #20]	; (5d8c <cliFunc_kbdProtocol+0x20>)
    5d76:	f001 fd45 	bl	7804 <_print>
	printInt8( USBKeys_Protocol );
    5d7a:	4b05      	ldr	r3, [pc, #20]	; (5d90 <cliFunc_kbdProtocol+0x24>)
    5d7c:	7818      	ldrb	r0, [r3, #0]
}
    5d7e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}

void cliFunc_kbdProtocol( char* args )
{
	print( NL );
	info_msg("Keyboard Protocol: ");
	printInt8( USBKeys_Protocol );
    5d82:	f001 bd71 	b.w	7868 <printInt8>
    5d86:	bf00      	nop
    5d88:	0000bafb 	.word	0x0000bafb
    5d8c:	0000b48c 	.word	0x0000b48c
    5d90:	1fff8e51 	.word	0x1fff8e51

00005d94 <cliFunc_readLEDs>:
	}
}


void cliFunc_readLEDs( char* args )
{
    5d94:	b508      	push	{r3, lr}
	print( NL );
    5d96:	4806      	ldr	r0, [pc, #24]	; (5db0 <cliFunc_readLEDs+0x1c>)
    5d98:	f001 fd34 	bl	7804 <_print>
	info_msg("LED State: ");
    5d9c:	4805      	ldr	r0, [pc, #20]	; (5db4 <cliFunc_readLEDs+0x20>)
    5d9e:	f001 fd31 	bl	7804 <_print>
	printInt8( USBKeys_LEDs );
    5da2:	4b05      	ldr	r3, [pc, #20]	; (5db8 <cliFunc_readLEDs+0x24>)
    5da4:	7818      	ldrb	r0, [r3, #0]
}
    5da6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}

void cliFunc_readLEDs( char* args )
{
	print( NL );
	info_msg("LED State: ");
	printInt8( USBKeys_LEDs );
    5daa:	f001 bd5d 	b.w	7868 <printInt8>
    5dae:	bf00      	nop
    5db0:	0000bafb 	.word	0x0000bafb
    5db4:	0000b4b2 	.word	0x0000b4b2
    5db8:	1fff94ee 	.word	0x1fff94ee

00005dbc <cliFunc_setKeys>:
	USBKeys_Modifiers = USBKeys_ModifiersCLI;
}


void cliFunc_setKeys( char* args )
{
    5dbc:	b537      	push	{r0, r1, r2, r4, r5, lr}
	char* curArgs;
	char* arg1Ptr;
	char* arg2Ptr = args;

	// Parse up to USBKeys_MaxSize args (whichever is least)
	for ( USBKeys_SentCLI = 0; USBKeys_SentCLI < USB_BOOT_MAX_KEYS; ++USBKeys_SentCLI )
    5dbe:	4b0b      	ldr	r3, [pc, #44]	; (5dec <cliFunc_setKeys+0x30>)

void cliFunc_setKeys( char* args )
{
	char* curArgs;
	char* arg1Ptr;
	char* arg2Ptr = args;
    5dc0:	9001      	str	r0, [sp, #4]

	// Parse up to USBKeys_MaxSize args (whichever is least)
	for ( USBKeys_SentCLI = 0; USBKeys_SentCLI < USB_BOOT_MAX_KEYS; ++USBKeys_SentCLI )
    5dc2:	2200      	movs	r2, #0
    5dc4:	701a      	strb	r2, [r3, #0]
    5dc6:	461d      	mov	r5, r3
    5dc8:	782b      	ldrb	r3, [r5, #0]
    5dca:	4c08      	ldr	r4, [pc, #32]	; (5dec <cliFunc_setKeys+0x30>)
    5dcc:	2b05      	cmp	r3, #5
    5dce:	d80b      	bhi.n	5de8 <cliFunc_setKeys+0x2c>
	{
		curArgs = arg2Ptr;
		CLI_argumentIsolation( curArgs, &arg1Ptr, &arg2Ptr );
    5dd0:	aa01      	add	r2, sp, #4
    5dd2:	9801      	ldr	r0, [sp, #4]
    5dd4:	4669      	mov	r1, sp
    5dd6:	f001 fa63 	bl	72a0 <CLI_argumentIsolation>

		// Stop processing args if no more are found
		if ( *arg1Ptr == '\0' )
    5dda:	9a00      	ldr	r2, [sp, #0]
    5ddc:	7813      	ldrb	r3, [r2, #0]
    5dde:	b11b      	cbz	r3, 5de8 <cliFunc_setKeys+0x2c>
	char* curArgs;
	char* arg1Ptr;
	char* arg2Ptr = args;

	// Parse up to USBKeys_MaxSize args (whichever is least)
	for ( USBKeys_SentCLI = 0; USBKeys_SentCLI < USB_BOOT_MAX_KEYS; ++USBKeys_SentCLI )
    5de0:	7823      	ldrb	r3, [r4, #0]
    5de2:	3301      	adds	r3, #1
    5de4:	7023      	strb	r3, [r4, #0]
    5de6:	e7ef      	b.n	5dc8 <cliFunc_setKeys+0xc>

		// Add the USB code to be sent
		// TODO
		//USBKeys_KeysCLI[USBKeys_SentCLI] = numToInt( arg1Ptr );
	}
}
    5de8:	b003      	add	sp, #12
    5dea:	bd30      	pop	{r4, r5, pc}
    5dec:	1fff94f4 	.word	0x1fff94f4

00005df0 <cliFunc_outputDebug>:
	printInt8( USBKeys_Protocol );
}


void cliFunc_outputDebug( char* args )
{
    5df0:	b513      	push	{r0, r1, r4, lr}
	char* arg1Ptr;
	char* arg2Ptr;
	CLI_argumentIsolation( args, &arg1Ptr, &arg2Ptr );

	// Default to 1 if no argument is given
	Output_DebugMode = 1;
    5df2:	4c07      	ldr	r4, [pc, #28]	; (5e10 <cliFunc_outputDebug+0x20>)
{
	// Parse number from argument
	//  NOTE: Only first argument is used
	char* arg1Ptr;
	char* arg2Ptr;
	CLI_argumentIsolation( args, &arg1Ptr, &arg2Ptr );
    5df4:	4669      	mov	r1, sp
    5df6:	aa01      	add	r2, sp, #4
    5df8:	f001 fa52 	bl	72a0 <CLI_argumentIsolation>

	// Default to 1 if no argument is given
	Output_DebugMode = 1;
    5dfc:	2301      	movs	r3, #1

	if ( arg1Ptr[0] != '\0' )
    5dfe:	9800      	ldr	r0, [sp, #0]
	char* arg1Ptr;
	char* arg2Ptr;
	CLI_argumentIsolation( args, &arg1Ptr, &arg2Ptr );

	// Default to 1 if no argument is given
	Output_DebugMode = 1;
    5e00:	7023      	strb	r3, [r4, #0]

	if ( arg1Ptr[0] != '\0' )
    5e02:	7803      	ldrb	r3, [r0, #0]
    5e04:	b113      	cbz	r3, 5e0c <cliFunc_outputDebug+0x1c>
	{
		Output_DebugMode = (uint16_t)numToInt( arg1Ptr );
    5e06:	f001 fddb 	bl	79c0 <numToInt>
    5e0a:	7020      	strb	r0, [r4, #0]
	}
}
    5e0c:	b002      	add	sp, #8
    5e0e:	bd10      	pop	{r4, pc}
    5e10:	1fff94f2 	.word	0x1fff94f2

00005e14 <cliFunc_setMod>:
	}
}


void cliFunc_setMod( char* args )
{
    5e14:	b507      	push	{r0, r1, r2, lr}
	// Parse number from argument
	//  NOTE: Only first argument is used
	char* arg1Ptr;
	char* arg2Ptr;
	CLI_argumentIsolation( args, &arg1Ptr, &arg2Ptr );
    5e16:	4669      	mov	r1, sp
    5e18:	aa01      	add	r2, sp, #4
    5e1a:	f001 fa41 	bl	72a0 <CLI_argumentIsolation>

	USBKeys_ModifiersCLI = numToInt( arg1Ptr );
    5e1e:	9800      	ldr	r0, [sp, #0]
    5e20:	f001 fdce 	bl	79c0 <numToInt>
    5e24:	4b02      	ldr	r3, [pc, #8]	; (5e30 <cliFunc_setMod+0x1c>)
    5e26:	7018      	strb	r0, [r3, #0]
}
    5e28:	b003      	add	sp, #12
    5e2a:	f85d fb04 	ldr.w	pc, [sp], #4
    5e2e:	bf00      	nop
    5e30:	1fff94f6 	.word	0x1fff94f6

00005e34 <Output_consCtrlSend_capability>:

// Sends a Consumer Control code to the USB Output buffer
void Output_consCtrlSend_capability( uint8_t state, uint8_t stateType, uint8_t *args )
{
	// Display capability name
	if ( stateType == 0xFF && state == 0xFF )
    5e34:	29ff      	cmp	r1, #255	; 0xff
}


// Sends a Consumer Control code to the USB Output buffer
void Output_consCtrlSend_capability( uint8_t state, uint8_t stateType, uint8_t *args )
{
    5e36:	b530      	push	{r4, r5, lr}
	// Display capability name
	if ( stateType == 0xFF && state == 0xFF )
    5e38:	d103      	bne.n	5e42 <Output_consCtrlSend_capability+0xe>
    5e3a:	28ff      	cmp	r0, #255	; 0xff
    5e3c:	d101      	bne.n	5e42 <Output_consCtrlSend_capability+0xe>
	{
		print("Output_consCtrlSend(consCode)");
    5e3e:	480e      	ldr	r0, [pc, #56]	; (5e78 <Output_consCtrlSend_capability+0x44>)
    5e40:	e003      	b.n	5e4a <Output_consCtrlSend_capability+0x16>
		return;
	}

	// Not implemented in Boot Mode
	if ( USBKeys_Protocol == 0 )
    5e42:	4b0e      	ldr	r3, [pc, #56]	; (5e7c <Output_consCtrlSend_capability+0x48>)
    5e44:	781b      	ldrb	r3, [r3, #0]
    5e46:	b923      	cbnz	r3, 5e52 <Output_consCtrlSend_capability+0x1e>
	{
		warn_print("Consumer Control is not implemented for Boot Mode");
    5e48:	480d      	ldr	r0, [pc, #52]	; (5e80 <Output_consCtrlSend_capability+0x4c>)
		return;
	}

	// Set consumer control code
	USBKeys_ConsCtrl = *(uint16_t*)(&args[0]);
}
    5e4a:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
	}

	// Not implemented in Boot Mode
	if ( USBKeys_Protocol == 0 )
	{
		warn_print("Consumer Control is not implemented for Boot Mode");
    5e4e:	f001 bcd9 	b.w	7804 <_print>
		return;
	}

	// TODO Analog inputs
	// Only indicate USB has changed if either a press or release has occured
	if ( state == 0x01 || state == 0x03 )
    5e52:	f000 03fd 	and.w	r3, r0, #253	; 0xfd
    5e56:	2b01      	cmp	r3, #1
    5e58:	4b0a      	ldr	r3, [pc, #40]	; (5e84 <Output_consCtrlSend_capability+0x50>)
    5e5a:	d109      	bne.n	5e70 <Output_consCtrlSend_capability+0x3c>
		USBKeys_Changed |= USBKeyChangeState_Consumer;
    5e5c:	4c0a      	ldr	r4, [pc, #40]	; (5e88 <Output_consCtrlSend_capability+0x54>)
    5e5e:	7825      	ldrb	r5, [r4, #0]
    5e60:	f045 0540 	orr.w	r5, r5, #64	; 0x40
    5e64:	7025      	strb	r5, [r4, #0]

	// Only send keypresses if press or hold state
	if ( stateType == 0x00 && state == 0x03 ) // Release state
    5e66:	b919      	cbnz	r1, 5e70 <Output_consCtrlSend_capability+0x3c>
    5e68:	2803      	cmp	r0, #3
    5e6a:	d101      	bne.n	5e70 <Output_consCtrlSend_capability+0x3c>
	{
		USBKeys_ConsCtrl = 0;
    5e6c:	8019      	strh	r1, [r3, #0]
		return;
    5e6e:	bd30      	pop	{r4, r5, pc}
	}

	// Set consumer control code
	USBKeys_ConsCtrl = *(uint16_t*)(&args[0]);
    5e70:	8812      	ldrh	r2, [r2, #0]
    5e72:	801a      	strh	r2, [r3, #0]
    5e74:	bd30      	pop	{r4, r5, pc}
    5e76:	bf00      	nop
    5e78:	0000b4d0 	.word	0x0000b4d0
    5e7c:	1fff8e51 	.word	0x1fff8e51
    5e80:	0000b4ee 	.word	0x0000b4ee
    5e84:	1fffa654 	.word	0x1fffa654
    5e88:	1fff94f0 	.word	0x1fff94f0

00005e8c <Output_noneSend_capability>:
// Ignores the given key status update
// Used to prevent fall-through, this is the None keyword in KLL
void Output_noneSend_capability( uint8_t state, uint8_t stateType, uint8_t *args )
{
	// Display capability name
	if ( stateType == 0xFF && state == 0xFF )
    5e8c:	29ff      	cmp	r1, #255	; 0xff
    5e8e:	d104      	bne.n	5e9a <Output_noneSend_capability+0xe>
    5e90:	28ff      	cmp	r0, #255	; 0xff
    5e92:	d102      	bne.n	5e9a <Output_noneSend_capability+0xe>
	{
		print("Output_noneSend()");
    5e94:	4801      	ldr	r0, [pc, #4]	; (5e9c <Output_noneSend_capability+0x10>)
    5e96:	f001 bcb5 	b.w	7804 <_print>
    5e9a:	4770      	bx	lr
    5e9c:	0000b537 	.word	0x0000b537

00005ea0 <Output_sysCtrlSend_capability>:

// Sends a System Control code to the USB Output buffer
void Output_sysCtrlSend_capability( uint8_t state, uint8_t stateType, uint8_t *args )
{
	// Display capability name
	if ( stateType == 0xFF && state == 0xFF )
    5ea0:	29ff      	cmp	r1, #255	; 0xff
}


// Sends a System Control code to the USB Output buffer
void Output_sysCtrlSend_capability( uint8_t state, uint8_t stateType, uint8_t *args )
{
    5ea2:	b530      	push	{r4, r5, lr}
	// Display capability name
	if ( stateType == 0xFF && state == 0xFF )
    5ea4:	d103      	bne.n	5eae <Output_sysCtrlSend_capability+0xe>
    5ea6:	28ff      	cmp	r0, #255	; 0xff
    5ea8:	d101      	bne.n	5eae <Output_sysCtrlSend_capability+0xe>
	{
		print("Output_sysCtrlSend(sysCode)");
    5eaa:	480e      	ldr	r0, [pc, #56]	; (5ee4 <Output_sysCtrlSend_capability+0x44>)
    5eac:	e003      	b.n	5eb6 <Output_sysCtrlSend_capability+0x16>
		return;
	}

	// Not implemented in Boot Mode
	if ( USBKeys_Protocol == 0 )
    5eae:	4b0e      	ldr	r3, [pc, #56]	; (5ee8 <Output_sysCtrlSend_capability+0x48>)
    5eb0:	781b      	ldrb	r3, [r3, #0]
    5eb2:	b923      	cbnz	r3, 5ebe <Output_sysCtrlSend_capability+0x1e>
	{
		warn_print("System Control is not implemented for Boot Mode");
    5eb4:	480d      	ldr	r0, [pc, #52]	; (5eec <Output_sysCtrlSend_capability+0x4c>)
		return;
	}

	// Set system control code
	USBKeys_SysCtrl = args[0];
}
    5eb6:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
	}

	// Not implemented in Boot Mode
	if ( USBKeys_Protocol == 0 )
	{
		warn_print("System Control is not implemented for Boot Mode");
    5eba:	f001 bca3 	b.w	7804 <_print>
		return;
	}

	// TODO Analog inputs
	// Only indicate USB has changed if either a press or release has occured
	if ( state == 0x01 || state == 0x03 )
    5ebe:	f000 03fd 	and.w	r3, r0, #253	; 0xfd
    5ec2:	2b01      	cmp	r3, #1
    5ec4:	4b0a      	ldr	r3, [pc, #40]	; (5ef0 <Output_sysCtrlSend_capability+0x50>)
    5ec6:	d109      	bne.n	5edc <Output_sysCtrlSend_capability+0x3c>
		USBKeys_Changed |= USBKeyChangeState_System;
    5ec8:	4c0a      	ldr	r4, [pc, #40]	; (5ef4 <Output_sysCtrlSend_capability+0x54>)
    5eca:	7825      	ldrb	r5, [r4, #0]
    5ecc:	f045 0520 	orr.w	r5, r5, #32
    5ed0:	7025      	strb	r5, [r4, #0]

	// Only send keypresses if press or hold state
	if ( stateType == 0x00 && state == 0x03 ) // Release state
    5ed2:	b919      	cbnz	r1, 5edc <Output_sysCtrlSend_capability+0x3c>
    5ed4:	2803      	cmp	r0, #3
    5ed6:	d101      	bne.n	5edc <Output_sysCtrlSend_capability+0x3c>
	{
		USBKeys_SysCtrl = 0;
    5ed8:	7019      	strb	r1, [r3, #0]
		return;
    5eda:	bd30      	pop	{r4, r5, pc}
	}

	// Set system control code
	USBKeys_SysCtrl = args[0];
    5edc:	7812      	ldrb	r2, [r2, #0]
    5ede:	701a      	strb	r2, [r3, #0]
    5ee0:	bd30      	pop	{r4, r5, pc}
    5ee2:	bf00      	nop
    5ee4:	0000b549 	.word	0x0000b549
    5ee8:	1fff8e51 	.word	0x1fff8e51
    5eec:	0000b565 	.word	0x0000b565
    5ef0:	1fffa61c 	.word	0x1fffa61c
    5ef4:	1fff94f0 	.word	0x1fff94f0

00005ef8 <Output_flashMode_capability>:
}

void Output_flashMode_capability( uint8_t state, uint8_t stateType, uint8_t *args )
{
	// Display capability name
	if ( stateType == 0xFF && state == 0xFF )
    5ef8:	29ff      	cmp	r1, #255	; 0xff
    5efa:	d104      	bne.n	5f06 <Output_flashMode_capability+0xe>
    5efc:	28ff      	cmp	r0, #255	; 0xff
    5efe:	d102      	bne.n	5f06 <Output_flashMode_capability+0xe>
	{
		print("Output_flashMode()");
    5f00:	4802      	ldr	r0, [pc, #8]	; (5f0c <Output_flashMode_capability+0x14>)
    5f02:	f001 bc7f 	b.w	7804 <_print>


// Sets the device into firmware reload mode
inline void Output_firmwareReload()
{
	usb_device_reload();
    5f06:	f000 ba59 	b.w	63bc <usb_device_reload>
    5f0a:	bf00      	nop
    5f0c:	0000b5ac 	.word	0x0000b5ac

00005f10 <Output_flushBuffers>:

// ----- Functions -----

// Flush Key buffers
void Output_flushBuffers()
{
    5f10:	2200      	movs	r2, #0
	// Zero out USBKeys_Keys array
	for ( uint8_t c = 0; c < USB_NKRO_BITFIELD_SIZE_KEYS; c++ )
		USBKeys_Keys[ c ] = 0;
    5f12:	4906      	ldr	r1, [pc, #24]	; (5f2c <Output_flushBuffers+0x1c>)
    5f14:	2300      	movs	r3, #0
    5f16:	5453      	strb	r3, [r2, r1]
    5f18:	3201      	adds	r2, #1

// Flush Key buffers
void Output_flushBuffers()
{
	// Zero out USBKeys_Keys array
	for ( uint8_t c = 0; c < USB_NKRO_BITFIELD_SIZE_KEYS; c++ )
    5f1a:	2a1b      	cmp	r2, #27
    5f1c:	d1f9      	bne.n	5f12 <Output_flushBuffers+0x2>
		USBKeys_Keys[ c ] = 0;

	// Zero out other key buffers
	USBKeys_ConsCtrl = 0;
    5f1e:	4a04      	ldr	r2, [pc, #16]	; (5f30 <Output_flushBuffers+0x20>)
    5f20:	8013      	strh	r3, [r2, #0]
	USBKeys_Modifiers = 0;
    5f22:	4a04      	ldr	r2, [pc, #16]	; (5f34 <Output_flushBuffers+0x24>)
    5f24:	7013      	strb	r3, [r2, #0]
	USBKeys_SysCtrl = 0;
    5f26:	4a04      	ldr	r2, [pc, #16]	; (5f38 <Output_flushBuffers+0x28>)
    5f28:	7013      	strb	r3, [r2, #0]
    5f2a:	4770      	bx	lr
    5f2c:	1fffa61d 	.word	0x1fffa61d
    5f30:	1fffa654 	.word	0x1fffa654
    5f34:	1fff94ef 	.word	0x1fff94ef
    5f38:	1fffa61c 	.word	0x1fffa61c

00005f3c <Output_kbdProtocolBoot_capability>:

// Set Boot Keyboard Protocol
void Output_kbdProtocolBoot_capability( uint8_t state, uint8_t stateType, uint8_t *args )
{
	// Display capability name
	if ( stateType == 0xFF && state == 0xFF )
    5f3c:	29ff      	cmp	r1, #255	; 0xff

// ----- Capabilities -----

// Set Boot Keyboard Protocol
void Output_kbdProtocolBoot_capability( uint8_t state, uint8_t stateType, uint8_t *args )
{
    5f3e:	b510      	push	{r4, lr}
	// Display capability name
	if ( stateType == 0xFF && state == 0xFF )
    5f40:	d106      	bne.n	5f50 <Output_kbdProtocolBoot_capability+0x14>
    5f42:	28ff      	cmp	r0, #255	; 0xff
    5f44:	d104      	bne.n	5f50 <Output_kbdProtocolBoot_capability+0x14>
	{
		print("Output_kbdProtocolBoot()");
    5f46:	4807      	ldr	r0, [pc, #28]	; (5f64 <Output_kbdProtocolBoot_capability+0x28>)
	// Flush the key buffers
	Output_flushBuffers();

	// Set the keyboard protocol to Boot Mode
	USBKeys_Protocol = 0;
}
    5f48:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
void Output_kbdProtocolBoot_capability( uint8_t state, uint8_t stateType, uint8_t *args )
{
	// Display capability name
	if ( stateType == 0xFF && state == 0xFF )
	{
		print("Output_kbdProtocolBoot()");
    5f4c:	f001 bc5a 	b.w	7804 <_print>
		return;
	}

	// Only set if necessary
	if ( USBKeys_Protocol == 0 )
    5f50:	4c05      	ldr	r4, [pc, #20]	; (5f68 <Output_kbdProtocolBoot_capability+0x2c>)
    5f52:	7823      	ldrb	r3, [r4, #0]
    5f54:	b12b      	cbz	r3, 5f62 <Output_kbdProtocolBoot_capability+0x26>
		return;

	// TODO Analog inputs
	// Only set on key press
	if ( stateType != 0x01 )
    5f56:	2901      	cmp	r1, #1
    5f58:	d103      	bne.n	5f62 <Output_kbdProtocolBoot_capability+0x26>
		return;

	// Flush the key buffers
	Output_flushBuffers();
    5f5a:	f7ff ffd9 	bl	5f10 <Output_flushBuffers>

	// Set the keyboard protocol to Boot Mode
	USBKeys_Protocol = 0;
    5f5e:	2300      	movs	r3, #0
    5f60:	7023      	strb	r3, [r4, #0]
    5f62:	bd10      	pop	{r4, pc}
    5f64:	0000b5bf 	.word	0x0000b5bf
    5f68:	1fff8e51 	.word	0x1fff8e51

00005f6c <Output_kbdProtocolNKRO_capability>:

// Set NKRO Keyboard Protocol
void Output_kbdProtocolNKRO_capability( uint8_t state, uint8_t stateType, uint8_t *args )
{
	// Display capability name
	if ( stateType == 0xFF && state == 0xFF )
    5f6c:	29ff      	cmp	r1, #255	; 0xff
}


// Set NKRO Keyboard Protocol
void Output_kbdProtocolNKRO_capability( uint8_t state, uint8_t stateType, uint8_t *args )
{
    5f6e:	b538      	push	{r3, r4, r5, lr}
    5f70:	460c      	mov	r4, r1
	// Display capability name
	if ( stateType == 0xFF && state == 0xFF )
    5f72:	d106      	bne.n	5f82 <Output_kbdProtocolNKRO_capability+0x16>
    5f74:	28ff      	cmp	r0, #255	; 0xff
    5f76:	d104      	bne.n	5f82 <Output_kbdProtocolNKRO_capability+0x16>
	{
		print("Output_kbdProtocolNKRO()");
    5f78:	4807      	ldr	r0, [pc, #28]	; (5f98 <Output_kbdProtocolNKRO_capability+0x2c>)
	// Flush the key buffers
	Output_flushBuffers();

	// Set the keyboard protocol to NKRO Mode
	USBKeys_Protocol = 1;
}
    5f7a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
void Output_kbdProtocolNKRO_capability( uint8_t state, uint8_t stateType, uint8_t *args )
{
	// Display capability name
	if ( stateType == 0xFF && state == 0xFF )
	{
		print("Output_kbdProtocolNKRO()");
    5f7e:	f001 bc41 	b.w	7804 <_print>
		return;
	}

	// Only set if necessary
	if ( USBKeys_Protocol == 1 )
    5f82:	4d06      	ldr	r5, [pc, #24]	; (5f9c <Output_kbdProtocolNKRO_capability+0x30>)
    5f84:	782b      	ldrb	r3, [r5, #0]
    5f86:	2b01      	cmp	r3, #1
    5f88:	d004      	beq.n	5f94 <Output_kbdProtocolNKRO_capability+0x28>
		return;

	// TODO Analog inputs
	// Only set on key press
	if ( stateType != 0x01 )
    5f8a:	2c01      	cmp	r4, #1
    5f8c:	d102      	bne.n	5f94 <Output_kbdProtocolNKRO_capability+0x28>
		return;

	// Flush the key buffers
	Output_flushBuffers();
    5f8e:	f7ff ffbf 	bl	5f10 <Output_flushBuffers>

	// Set the keyboard protocol to NKRO Mode
	USBKeys_Protocol = 1;
    5f92:	702c      	strb	r4, [r5, #0]
    5f94:	bd38      	pop	{r3, r4, r5, pc}
    5f96:	bf00      	nop
    5f98:	0000b5d8 	.word	0x0000b5d8
    5f9c:	1fff8e51 	.word	0x1fff8e51

00005fa0 <Output_usbCodeSend_capability>:
// Adds a single USB Code to the USB Output buffer
// Argument #1: USB Code
void Output_usbCodeSend_capability( uint8_t state, uint8_t stateType, uint8_t *args )
{
	// Display capability name
	if ( stateType == 0xFF && state == 0xFF )
    5fa0:	29ff      	cmp	r1, #255	; 0xff


// Adds a single USB Code to the USB Output buffer
// Argument #1: USB Code
void Output_usbCodeSend_capability( uint8_t state, uint8_t stateType, uint8_t *args )
{
    5fa2:	b570      	push	{r4, r5, r6, lr}
	// Display capability name
	if ( stateType == 0xFF && state == 0xFF )
    5fa4:	d103      	bne.n	5fae <Output_usbCodeSend_capability+0xe>
    5fa6:	28ff      	cmp	r0, #255	; 0xff
    5fa8:	d101      	bne.n	5fae <Output_usbCodeSend_capability+0xe>
	{
		print("Output_usbCodeSend(usbCode)");
    5faa:	4864      	ldr	r0, [pc, #400]	; (613c <Output_usbCodeSend_capability+0x19c>)
    5fac:	e0ad      	b.n	610a <Output_usbCodeSend_capability+0x16a>
		return;
	}

	// Depending on which mode the keyboard is in the USB needs Press/Hold/Release events
	uint8_t keyPress = 0; // Default to key release, only used for NKRO
	switch ( USBKeys_Protocol )
    5fae:	4c64      	ldr	r4, [pc, #400]	; (6140 <Output_usbCodeSend_capability+0x1a0>)
    5fb0:	7823      	ldrb	r3, [r4, #0]
    5fb2:	4625      	mov	r5, r4
    5fb4:	f003 06ff 	and.w	r6, r3, #255	; 0xff
    5fb8:	b113      	cbz	r3, 5fc0 <Output_usbCodeSend_capability+0x20>
    5fba:	2e01      	cmp	r6, #1
    5fbc:	d00b      	beq.n	5fd6 <Output_usbCodeSend_capability+0x36>
    5fbe:	e012      	b.n	5fe6 <Output_usbCodeSend_capability+0x46>
	{
	case 0: // Boot Mode
		// TODO Analog inputs
		// Only indicate USB has changed if either a press or release has occured
		if ( state == 0x01 || state == 0x03 )
    5fc0:	f000 03fd 	and.w	r3, r0, #253	; 0xfd
    5fc4:	2b01      	cmp	r3, #1
    5fc6:	d10e      	bne.n	5fe6 <Output_usbCodeSend_capability+0x46>
			USBKeys_Changed = USBKeyChangeState_MainKeys;
    5fc8:	4b5e      	ldr	r3, [pc, #376]	; (6144 <Output_usbCodeSend_capability+0x1a4>)
    5fca:	2402      	movs	r4, #2
    5fcc:	701c      	strb	r4, [r3, #0]

		// Only send keypresses if press or hold state
		if ( stateType == 0x00 && state == 0x03 ) // Release state
    5fce:	b951      	cbnz	r1, 5fe6 <Output_usbCodeSend_capability+0x46>
    5fd0:	2803      	cmp	r0, #3
    5fd2:	d108      	bne.n	5fe6 <Output_usbCodeSend_capability+0x46>
    5fd4:	bd70      	pop	{r4, r5, r6, pc}
			return;
		break;
	case 1: // NKRO Mode
		// Only send press and release events
		if ( stateType == 0x00 && state == 0x02 ) // Hold state
    5fd6:	b931      	cbnz	r1, 5fe6 <Output_usbCodeSend_capability+0x46>
    5fd8:	2802      	cmp	r0, #2
    5fda:	f000 80ad 	beq.w	6138 <Output_usbCodeSend_capability+0x198>
		print("Output_usbCodeSend(usbCode)");
		return;
	}

	// Depending on which mode the keyboard is in the USB needs Press/Hold/Release events
	uint8_t keyPress = 0; // Default to key release, only used for NKRO
    5fde:	1e43      	subs	r3, r0, #1
    5fe0:	4258      	negs	r0, r3
    5fe2:	4158      	adcs	r0, r3
    5fe4:	e000      	b.n	5fe8 <Output_usbCodeSend_capability+0x48>
    5fe6:	2000      	movs	r0, #0
	//  Bits  48 - 161 (bytes  6 - 20) correspond to USB Codes  51 - 164 (Secondary)
	//  Bits 168 - 213 (bytes 21 - 26) correspond to USB Codes 176 - 221 (Tertiary)
	//  Bits 214 - 216                 unused
	uint8_t bytePosition = 0;
	uint8_t byteShift = 0;
	switch ( USBKeys_Protocol )
    5fe8:	782b      	ldrb	r3, [r5, #0]
			keyPress = 1;
		break;
	}

	// Get the keycode from arguments
	uint8_t key = args[0];
    5fea:	7814      	ldrb	r4, [r2, #0]
	//  Bits  48 - 161 (bytes  6 - 20) correspond to USB Codes  51 - 164 (Secondary)
	//  Bits 168 - 213 (bytes 21 - 26) correspond to USB Codes 176 - 221 (Tertiary)
	//  Bits 214 - 216                 unused
	uint8_t bytePosition = 0;
	uint8_t byteShift = 0;
	switch ( USBKeys_Protocol )
    5fec:	f003 05ff 	and.w	r5, r3, #255	; 0xff
    5ff0:	b113      	cbz	r3, 5ff8 <Output_usbCodeSend_capability+0x58>
    5ff2:	2d01      	cmp	r5, #1
    5ff4:	d021      	beq.n	603a <Output_usbCodeSend_capability+0x9a>
    5ff6:	bd70      	pop	{r4, r5, r6, pc}
	{
	case 0: // Boot Mode
		// Set the modifier bit if this key is a modifier
		if ( (key & 0xE0) == 0xE0 ) // AND with 0xE0 (Left Ctrl, first modifier)
    5ff8:	f004 03e0 	and.w	r3, r4, #224	; 0xe0
    5ffc:	2be0      	cmp	r3, #224	; 0xe0
    5ffe:	d109      	bne.n	6014 <Output_usbCodeSend_capability+0x74>
		{
			USBKeys_Modifiers |= 1 << (key ^ 0xE0); // Left shift 1 by key XOR 0xE0
    6000:	4b51      	ldr	r3, [pc, #324]	; (6148 <Output_usbCodeSend_capability+0x1a8>)
    6002:	2201      	movs	r2, #1
    6004:	f084 04e0 	eor.w	r4, r4, #224	; 0xe0
    6008:	fa02 f404 	lsl.w	r4, r2, r4
    600c:	781a      	ldrb	r2, [r3, #0]
    600e:	4314      	orrs	r4, r2
    6010:	701c      	strb	r4, [r3, #0]
    6012:	bd70      	pop	{r4, r5, r6, pc}
		}
		// Normal USB Code
		else
		{
			// USB Key limit reached
			if ( USBKeys_Sent >= USB_BOOT_MAX_KEYS )
    6014:	4a4d      	ldr	r2, [pc, #308]	; (614c <Output_usbCodeSend_capability+0x1ac>)
    6016:	7813      	ldrb	r3, [r2, #0]
    6018:	2b05      	cmp	r3, #5
    601a:	d901      	bls.n	6020 <Output_usbCodeSend_capability+0x80>
			{
				warn_print("USB Key limit reached");
    601c:	484c      	ldr	r0, [pc, #304]	; (6150 <Output_usbCodeSend_capability+0x1b0>)
    601e:	e074      	b.n	610a <Output_usbCodeSend_capability+0x16a>
				return;
			}

			// Make sure key is within the USB HID range
			if ( key <= 104 )
    6020:	2c68      	cmp	r4, #104	; 0x68
    6022:	d804      	bhi.n	602e <Output_usbCodeSend_capability+0x8e>
			{
				USBKeys_Keys[USBKeys_Sent++] = key;
    6024:	1c59      	adds	r1, r3, #1
    6026:	7011      	strb	r1, [r2, #0]
    6028:	4a4a      	ldr	r2, [pc, #296]	; (6154 <Output_usbCodeSend_capability+0x1b4>)
    602a:	54d4      	strb	r4, [r2, r3]
    602c:	bd70      	pop	{r4, r5, r6, pc}
			}
			// Invalid key
			else
			{
				warn_msg("USB Code above 104/0x68 in Boot Mode: ");
    602e:	484a      	ldr	r0, [pc, #296]	; (6158 <Output_usbCodeSend_capability+0x1b8>)
    6030:	f001 fbe8 	bl	7804 <_print>
				printHex( key );
    6034:	4620      	mov	r0, r4
    6036:	2101      	movs	r1, #1
    6038:	e064      	b.n	6104 <Output_usbCodeSend_capability+0x164>
		}
		break;

	case 1: // NKRO Mode
		// Set the modifier bit if this key is a modifier
		if ( (key & 0xE0) == 0xE0 ) // AND with 0xE0 (Left Ctrl, first modifier)
    603a:	f004 03e0 	and.w	r3, r4, #224	; 0xe0
    603e:	2be0      	cmp	r3, #224	; 0xe0
    6040:	d112      	bne.n	6068 <Output_usbCodeSend_capability+0xc8>
    6042:	f084 041f 	eor.w	r4, r4, #31
    6046:	4b40      	ldr	r3, [pc, #256]	; (6148 <Output_usbCodeSend_capability+0x1a8>)
    6048:	43e4      	mvns	r4, r4
		{
			if ( keyPress )
			{
				USBKeys_Modifiers |= 1 << (key ^ 0xE0); // Left shift 1 by key XOR 0xE0
    604a:	b2e4      	uxtb	r4, r4
    604c:	40a5      	lsls	r5, r4
    604e:	781a      	ldrb	r2, [r3, #0]

	case 1: // NKRO Mode
		// Set the modifier bit if this key is a modifier
		if ( (key & 0xE0) == 0xE0 ) // AND with 0xE0 (Left Ctrl, first modifier)
		{
			if ( keyPress )
    6050:	b108      	cbz	r0, 6056 <Output_usbCodeSend_capability+0xb6>
			{
				USBKeys_Modifiers |= 1 << (key ^ 0xE0); // Left shift 1 by key XOR 0xE0
    6052:	4315      	orrs	r5, r2
    6054:	e001      	b.n	605a <Output_usbCodeSend_capability+0xba>
			}
			else // Release
			{
				USBKeys_Modifiers &= ~(1 << (key ^ 0xE0)); // Left shift 1 by key XOR 0xE0
    6056:	ea22 0505 	bic.w	r5, r2, r5
    605a:	701d      	strb	r5, [r3, #0]
			}

			USBKeys_Changed |= USBKeyChangeState_Modifiers;
    605c:	4b39      	ldr	r3, [pc, #228]	; (6144 <Output_usbCodeSend_capability+0x1a4>)
    605e:	781a      	ldrb	r2, [r3, #0]
    6060:	f042 0201 	orr.w	r2, r2, #1
    6064:	701a      	strb	r2, [r3, #0]
			break;
    6066:	bd70      	pop	{r4, r5, r6, pc}
		}
		// First 6 bytes
		else if ( key >= 4 && key <= 49 )
    6068:	1f23      	subs	r3, r4, #4
    606a:	b2db      	uxtb	r3, r3
    606c:	2b2d      	cmp	r3, #45	; 0x2d
    606e:	d80f      	bhi.n	6090 <Output_usbCodeSend_capability+0xf0>
    6070:	3c05      	subs	r4, #5
    6072:	b2e4      	uxtb	r4, r4
    6074:	2c2e      	cmp	r4, #46	; 0x2e
    6076:	d804      	bhi.n	6082 <Output_usbCodeSend_capability+0xe2>
    6078:	4b38      	ldr	r3, [pc, #224]	; (615c <Output_usbCodeSend_capability+0x1bc>)
    607a:	4a39      	ldr	r2, [pc, #228]	; (6160 <Output_usbCodeSend_capability+0x1c0>)
    607c:	5d1b      	ldrb	r3, [r3, r4]
    607e:	5d12      	ldrb	r2, [r2, r4]
    6080:	e001      	b.n	6086 <Output_usbCodeSend_capability+0xe6>
    6082:	2200      	movs	r2, #0
    6084:	4613      	mov	r3, r2
				byteLookup( 3 );
				byteLookup( 4 );
				byteLookup( 5 );
			}

			USBKeys_Changed |= USBKeyChangeState_MainKeys;
    6086:	492f      	ldr	r1, [pc, #188]	; (6144 <Output_usbCodeSend_capability+0x1a4>)
    6088:	780c      	ldrb	r4, [r1, #0]
    608a:	f044 0402 	orr.w	r4, r4, #2
    608e:	e00c      	b.n	60aa <Output_usbCodeSend_capability+0x10a>
		}
		// Next 14 bytes
		else if ( key >= 51 && key <= 155 )
    6090:	f1a4 0233 	sub.w	r2, r4, #51	; 0x33
    6094:	b2d2      	uxtb	r2, r2
    6096:	2a68      	cmp	r2, #104	; 0x68
    6098:	d809      	bhi.n	60ae <Output_usbCodeSend_capability+0x10e>
    609a:	4932      	ldr	r1, [pc, #200]	; (6164 <Output_usbCodeSend_capability+0x1c4>)
    609c:	4b32      	ldr	r3, [pc, #200]	; (6168 <Output_usbCodeSend_capability+0x1c8>)
    609e:	5c9b      	ldrb	r3, [r3, r2]
    60a0:	5c8a      	ldrb	r2, [r1, r2]
				byteLookup( 17 );
				byteLookup( 18 );
				byteLookup( 19 );
			}

			USBKeys_Changed |= USBKeyChangeState_SecondaryKeys;
    60a2:	4928      	ldr	r1, [pc, #160]	; (6144 <Output_usbCodeSend_capability+0x1a4>)
    60a4:	780c      	ldrb	r4, [r1, #0]
    60a6:	f044 0404 	orr.w	r4, r4, #4
    60aa:	700c      	strb	r4, [r1, #0]
    60ac:	e031      	b.n	6112 <Output_usbCodeSend_capability+0x172>
		}
		// Next byte
		else if ( key >= 157 && key <= 164 )
    60ae:	f104 0363 	add.w	r3, r4, #99	; 0x63
    60b2:	b2db      	uxtb	r3, r3
    60b4:	2b07      	cmp	r3, #7
    60b6:	d808      	bhi.n	60ca <Output_usbCodeSend_capability+0x12a>
    60b8:	4a2c      	ldr	r2, [pc, #176]	; (616c <Output_usbCodeSend_capability+0x1cc>)
    60ba:	5cd2      	ldrb	r2, [r2, r3]
			switch ( keyPos )
			{
				byteLookup( 20 );
			}

			USBKeys_Changed |= USBKeyChangeState_TertiaryKeys;
    60bc:	4b21      	ldr	r3, [pc, #132]	; (6144 <Output_usbCodeSend_capability+0x1a4>)
    60be:	7819      	ldrb	r1, [r3, #0]
    60c0:	f041 0108 	orr.w	r1, r1, #8
    60c4:	7019      	strb	r1, [r3, #0]
    60c6:	2314      	movs	r3, #20
    60c8:	e023      	b.n	6112 <Output_usbCodeSend_capability+0x172>
		}
		// Last 6 bytes
		else if ( key >= 176 && key <= 221 )
    60ca:	f104 0250 	add.w	r2, r4, #80	; 0x50
    60ce:	b2d2      	uxtb	r2, r2
    60d0:	2a2d      	cmp	r2, #45	; 0x2d
    60d2:	d808      	bhi.n	60e6 <Output_usbCodeSend_capability+0x146>
    60d4:	4926      	ldr	r1, [pc, #152]	; (6170 <Output_usbCodeSend_capability+0x1d0>)
    60d6:	4b27      	ldr	r3, [pc, #156]	; (6174 <Output_usbCodeSend_capability+0x1d4>)
    60d8:	5c9b      	ldrb	r3, [r3, r2]
    60da:	5c8a      	ldrb	r2, [r1, r2]
				byteLookup( 24 );
				byteLookup( 25 );
				byteLookup( 26 );
			}

			USBKeys_Changed |= USBKeyChangeState_QuartiaryKeys;
    60dc:	4919      	ldr	r1, [pc, #100]	; (6144 <Output_usbCodeSend_capability+0x1a4>)
    60de:	780c      	ldrb	r4, [r1, #0]
    60e0:	f044 0410 	orr.w	r4, r4, #16
    60e4:	e7e1      	b.n	60aa <Output_usbCodeSend_capability+0x10a>
		}
		// Received 0x00
		// This is a special USB Code that internally indicates a "break"
		// It is used to send "nothing" in order to break up sequences of USB Codes
		else if ( key == 0x00 )
    60e6:	b944      	cbnz	r4, 60fa <Output_usbCodeSend_capability+0x15a>
		{
			USBKeys_Changed |= USBKeyChangeState_MainKeys;
    60e8:	4b16      	ldr	r3, [pc, #88]	; (6144 <Output_usbCodeSend_capability+0x1a4>)
    60ea:	781a      	ldrb	r2, [r3, #0]
			USBKeys_Sent++;
		}

		break;
	}
}
    60ec:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		// Received 0x00
		// This is a special USB Code that internally indicates a "break"
		// It is used to send "nothing" in order to break up sequences of USB Codes
		else if ( key == 0x00 )
		{
			USBKeys_Changed |= USBKeyChangeState_MainKeys;
    60f0:	f042 0202 	orr.w	r2, r2, #2
    60f4:	701a      	strb	r2, [r3, #0]

			// Also flush out buffers just in case
			Output_flushBuffers();
    60f6:	f7ff bf0b 	b.w	5f10 <Output_flushBuffers>
			break;
		}
		// Invalid key
		else
		{
			warn_msg("USB Code not within 4-49 (0x4-0x31), 51-155 (0x33-0x9B), 157-164 (0x9D-0xA4), 176-221 (0xB0-0xDD) or 224-231 (0xE0-0xE7) NKRO Mode: ");
    60fa:	481f      	ldr	r0, [pc, #124]	; (6178 <Output_usbCodeSend_capability+0x1d8>)
    60fc:	f001 fb82 	bl	7804 <_print>
			printHex( key );
    6100:	4620      	mov	r0, r4
    6102:	4629      	mov	r1, r5
    6104:	f001 fc07 	bl	7916 <printHex_op>
			print( NL );
    6108:	481c      	ldr	r0, [pc, #112]	; (617c <Output_usbCodeSend_capability+0x1dc>)
			USBKeys_Sent++;
		}

		break;
	}
}
    610a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		// Invalid key
		else
		{
			warn_msg("USB Code not within 4-49 (0x4-0x31), 51-155 (0x33-0x9B), 157-164 (0x9D-0xA4), 176-221 (0xB0-0xDD) or 224-231 (0xE0-0xE7) NKRO Mode: ");
			printHex( key );
			print( NL );
    610e:	f001 bb79 	b.w	7804 <_print>
    6112:	2501      	movs	r5, #1
    6114:	490d      	ldr	r1, [pc, #52]	; (614c <Output_usbCodeSend_capability+0x1ac>)
    6116:	4c0f      	ldr	r4, [pc, #60]	; (6154 <Output_usbCodeSend_capability+0x1b4>)
		}

		// Set/Unset
		if ( keyPress )
		{
			USBKeys_Keys[bytePosition] |= (1 << byteShift);
    6118:	fa05 f202 	lsl.w	r2, r5, r2
			print( NL );
			break;
		}

		// Set/Unset
		if ( keyPress )
    611c:	b128      	cbz	r0, 612a <Output_usbCodeSend_capability+0x18a>
		{
			USBKeys_Keys[bytePosition] |= (1 << byteShift);
    611e:	5ce0      	ldrb	r0, [r4, r3]
    6120:	4302      	orrs	r2, r0
    6122:	54e2      	strb	r2, [r4, r3]
			USBKeys_Sent++;
    6124:	780b      	ldrb	r3, [r1, #0]
    6126:	442b      	add	r3, r5
    6128:	e005      	b.n	6136 <Output_usbCodeSend_capability+0x196>
		}
		else // Release
		{
			USBKeys_Keys[bytePosition] &= ~(1 << byteShift);
    612a:	5ce0      	ldrb	r0, [r4, r3]
    612c:	ea20 0202 	bic.w	r2, r0, r2
    6130:	54e2      	strb	r2, [r4, r3]
			USBKeys_Sent++;
    6132:	780b      	ldrb	r3, [r1, #0]
    6134:	3301      	adds	r3, #1
    6136:	700b      	strb	r3, [r1, #0]
    6138:	bd70      	pop	{r4, r5, r6, pc}
    613a:	bf00      	nop
    613c:	0000b5f1 	.word	0x0000b5f1
    6140:	1fff8e51 	.word	0x1fff8e51
    6144:	1fff94f0 	.word	0x1fff94f0
    6148:	1fff94ef 	.word	0x1fff94ef
    614c:	1fff94f3 	.word	0x1fff94f3
    6150:	0000b60d 	.word	0x0000b60d
    6154:	1fffa61d 	.word	0x1fffa61d
    6158:	0000b63a 	.word	0x0000b63a
    615c:	0000b341 	.word	0x0000b341
    6160:	0000b7a3 	.word	0x0000b7a3
    6164:	0000b842 	.word	0x0000b842
    6168:	0000b7d2 	.word	0x0000b7d2
    616c:	0000b8b2 	.word	0x0000b8b2
    6170:	0000b274 	.word	0x0000b274
    6174:	0000b370 	.word	0x0000b370
    6178:	0000b676 	.word	0x0000b676
    617c:	0000bafb 	.word	0x0000bafb

00006180 <Output_setup>:
}


// USB Module Setup
inline void Output_setup()
{
    6180:	b508      	push	{r3, lr}
	// Initialize the USB
	// If a USB connection does not exist, just ignore it
	// All usb related functions will non-fatally fail if called
	// If the USB initialization is delayed, then functionality will just be delayed
	usb_init();
    6182:	f000 fcb9 	bl	6af8 <usb_init>

	// Register USB Output CLI dictionary
	CLI_registerDictionary( outputCLIDict, outputCLIDictName );
    6186:	4804      	ldr	r0, [pc, #16]	; (6198 <Output_setup+0x18>)
    6188:	4904      	ldr	r1, [pc, #16]	; (619c <Output_setup+0x1c>)
    618a:	f001 f8fd 	bl	7388 <CLI_registerDictionary>

	// Flush key buffers
	Output_flushBuffers();
}
    618e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}

	// Register USB Output CLI dictionary
	CLI_registerDictionary( outputCLIDict, outputCLIDictName );

	// Flush key buffers
	Output_flushBuffers();
    6192:	f7ff bebd 	b.w	5f10 <Output_flushBuffers>
    6196:	bf00      	nop
    6198:	0000b3a0 	.word	0x0000b3a0
    619c:	0000b32d 	.word	0x0000b32d

000061a0 <Output_send>:
}


// USB Data Send
inline void Output_send()
{
    61a0:	b510      	push	{r4, lr}
	// Boot Mode Only, unset stale keys
	if ( USBKeys_Protocol == 0 )
    61a2:	4b12      	ldr	r3, [pc, #72]	; (61ec <Output_send+0x4c>)
    61a4:	781a      	ldrb	r2, [r3, #0]
    61a6:	461c      	mov	r4, r3
    61a8:	b94a      	cbnz	r2, 61be <Output_send+0x1e>
		for ( uint8_t c = USBKeys_Sent; c < USB_BOOT_MAX_KEYS; c++ )
    61aa:	4b11      	ldr	r3, [pc, #68]	; (61f0 <Output_send+0x50>)
    61ac:	781b      	ldrb	r3, [r3, #0]
    61ae:	2b05      	cmp	r3, #5
    61b0:	d805      	bhi.n	61be <Output_send+0x1e>
			USBKeys_Keys[c] = 0;
    61b2:	4a10      	ldr	r2, [pc, #64]	; (61f4 <Output_send+0x54>)
    61b4:	2100      	movs	r1, #0
    61b6:	54d1      	strb	r1, [r2, r3]
// USB Data Send
inline void Output_send()
{
	// Boot Mode Only, unset stale keys
	if ( USBKeys_Protocol == 0 )
		for ( uint8_t c = USBKeys_Sent; c < USB_BOOT_MAX_KEYS; c++ )
    61b8:	3301      	adds	r3, #1
    61ba:	b2db      	uxtb	r3, r3
    61bc:	e7f7      	b.n	61ae <Output_send+0xe>
			USBKeys_Keys[c] = 0;

	// Send keypresses while there are pending changes
	while ( USBKeys_Changed )
    61be:	4b0e      	ldr	r3, [pc, #56]	; (61f8 <Output_send+0x58>)
    61c0:	781b      	ldrb	r3, [r3, #0]
    61c2:	b113      	cbz	r3, 61ca <Output_send+0x2a>
		usb_keyboard_send();
    61c4:	f000 fce6 	bl	6b94 <usb_keyboard_send>
    61c8:	e7f9      	b.n	61be <Output_send+0x1e>

	// Clear keys sent
	USBKeys_Sent = 0;
    61ca:	4a09      	ldr	r2, [pc, #36]	; (61f0 <Output_send+0x50>)
    61cc:	7013      	strb	r3, [r2, #0]

	// Signal Scan Module we are finished
	switch ( USBKeys_Protocol )
    61ce:	7822      	ldrb	r2, [r4, #0]
    61d0:	f002 00ff 	and.w	r0, r2, #255	; 0xff
    61d4:	b112      	cbz	r2, 61dc <Output_send+0x3c>
    61d6:	2801      	cmp	r0, #1
    61d8:	d003      	beq.n	61e2 <Output_send+0x42>
    61da:	bd10      	pop	{r4, pc}
	{
	case 0: // Boot Mode
		// Clear modifiers only in boot mode
		USBKeys_Modifiers = 0;
    61dc:	4b07      	ldr	r3, [pc, #28]	; (61fc <Output_send+0x5c>)
    61de:	7018      	strb	r0, [r3, #0]
    61e0:	e000      	b.n	61e4 <Output_send+0x44>
		Scan_finishedWithOutput( USBKeys_Sent <= USB_BOOT_MAX_KEYS ? USBKeys_Sent : USB_BOOT_MAX_KEYS );
		break;
	case 1: // NKRO Mode
		Scan_finishedWithOutput( USBKeys_Sent );
    61e2:	4618      	mov	r0, r3
		break;
	}
}
    61e4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		// Clear modifiers only in boot mode
		USBKeys_Modifiers = 0;
		Scan_finishedWithOutput( USBKeys_Sent <= USB_BOOT_MAX_KEYS ? USBKeys_Sent : USB_BOOT_MAX_KEYS );
		break;
	case 1: // NKRO Mode
		Scan_finishedWithOutput( USBKeys_Sent );
    61e8:	f7fe bc78 	b.w	4adc <Scan_finishedWithOutput>
    61ec:	1fff8e51 	.word	0x1fff8e51
    61f0:	1fff94f3 	.word	0x1fff94f3
    61f4:	1fffa61d 	.word	0x1fffa61d
    61f8:	1fff94f0 	.word	0x1fff94f0
    61fc:	1fff94ef 	.word	0x1fff94ef

00006200 <Output_availablechar>:


// USB Input buffer available
inline unsigned int Output_availablechar()
{
	return usb_serial_available();
    6200:	f000 be90 	b.w	6f24 <usb_serial_available>

00006204 <Output_getchar>:

// USB Get Character from input buffer
inline int Output_getchar()
{
	// XXX Make sure to check output_availablechar() first! Information is lost with the cast (error codes) (AVR)
	return (int)usb_serial_getchar();
    6204:	f000 be68 	b.w	6ed8 <usb_serial_getchar>

00006208 <Output_putstr>:
inline int Output_putstr( char* str )
{
#if defined(_at90usb162_) || defined(_atmega32u4_) || defined(_at90usb646_) || defined(_at90usb1286_) // AVR
	uint16_t count = 0;
#elif defined(_mk20dx128_) || defined(_mk20dx128vlf5_) || defined(_mk20dx256_) || defined(_mk20dx256vlh7_) // ARM
	uint32_t count = 0;
    6208:	2100      	movs	r1, #0
#endif
	// Count characters until NULL character, then send the amount counted
	while ( str[count] != '\0' )
    620a:	5c43      	ldrb	r3, [r0, r1]
    620c:	b10b      	cbz	r3, 6212 <Output_putstr+0xa>
		count++;
    620e:	3101      	adds	r1, #1
    6210:	e7fb      	b.n	620a <Output_putstr+0x2>

	return usb_serial_write( str, count );
    6212:	f000 be95 	b.w	6f40 <usb_serial_write>
    6216:	0000      	movs	r0, r0

00006218 <Output_softReset>:


// Soft Chip Reset
inline void Output_softReset()
{
	usb_device_software_reset();
    6218:	4a01      	ldr	r2, [pc, #4]	; (6220 <Output_softReset+0x8>)
    621a:	4b02      	ldr	r3, [pc, #8]	; (6224 <Output_softReset+0xc>)
    621c:	601a      	str	r2, [r3, #0]
    621e:	4770      	bx	lr
    6220:	05fa0004 	.word	0x05fa0004
    6224:	e000ed0c 	.word	0xe000ed0c

00006228 <endpoint0_transmit>:
	#endif
	USB0_ENDPT0 = USB_ENDPT_EPSTALL | USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
}

static void endpoint0_transmit( const void *data, uint32_t len )
{
    6228:	b5f0      	push	{r4, r5, r6, r7, lr}
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    622a:	4b0c      	ldr	r3, [pc, #48]	; (625c <endpoint0_transmit+0x34>)
    622c:	4c0c      	ldr	r4, [pc, #48]	; (6260 <endpoint0_transmit+0x38>)
    622e:	781a      	ldrb	r2, [r3, #0]
    6230:	f042 0502 	orr.w	r5, r2, #2
    6234:	eb04 06c5 	add.w	r6, r4, r5, lsl #3
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
	ep0_tx_data_toggle ^= 1;
	ep0_tx_bdt_bank ^= 1;
    6238:	f082 0201 	eor.w	r2, r2, #1
	USB0_ENDPT0 = USB_ENDPT_EPSTALL | USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
}

static void endpoint0_transmit( const void *data, uint32_t len )
{
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    623c:	6070      	str	r0, [r6, #4]
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    623e:	4809      	ldr	r0, [pc, #36]	; (6264 <endpoint0_transmit+0x3c>)
	ep0_tx_data_toggle ^= 1;
	ep0_tx_bdt_bank ^= 1;
    6240:	701a      	strb	r2, [r3, #0]
}

static void endpoint0_transmit( const void *data, uint32_t len )
{
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    6242:	7806      	ldrb	r6, [r0, #0]
    6244:	2e00      	cmp	r6, #0
    6246:	bf0c      	ite	eq
    6248:	2788      	moveq	r7, #136	; 0x88
    624a:	27c8      	movne	r7, #200	; 0xc8
	ep0_tx_data_toggle ^= 1;
    624c:	f086 0601 	eor.w	r6, r6, #1
}

static void endpoint0_transmit( const void *data, uint32_t len )
{
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    6250:	ea47 4101 	orr.w	r1, r7, r1, lsl #16
	ep0_tx_data_toggle ^= 1;
    6254:	7006      	strb	r6, [r0, #0]
}

static void endpoint0_transmit( const void *data, uint32_t len )
{
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    6256:	f844 1035 	str.w	r1, [r4, r5, lsl #3]
	ep0_tx_data_toggle ^= 1;
	ep0_tx_bdt_bank ^= 1;
    625a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    625c:	1fff9588 	.word	0x1fff9588
    6260:	1fff8000 	.word	0x1fff8000
    6264:	1fff9620 	.word	0x1fff9620

00006268 <usb_rx>:

usb_packet_t *usb_rx( uint32_t endpoint )
{
	//print("USB RX");
	usb_packet_t *ret;
	endpoint--;
    6268:	1e43      	subs	r3, r0, #1
	if ( endpoint >= NUM_ENDPOINTS )
    626a:	2b07      	cmp	r3, #7
	}
	USB0_CTL = USB_CTL_USBENSOFEN; // clear TXSUSPENDTOKENBUSY bit
}

usb_packet_t *usb_rx( uint32_t endpoint )
{
    626c:	b510      	push	{r4, lr}
	//print("USB RX");
	usb_packet_t *ret;
	endpoint--;
	if ( endpoint >= NUM_ENDPOINTS )
    626e:	d810      	bhi.n	6292 <usb_rx+0x2a>
		return NULL;
	__disable_irq();
    6270:	b672      	cpsid	i
	ret = rx_first[endpoint];
    6272:	4a09      	ldr	r2, [pc, #36]	; (6298 <usb_rx+0x30>)
    6274:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
	if ( ret )
    6278:	b110      	cbz	r0, 6280 <usb_rx+0x18>
		rx_first[ endpoint ] = ret->next;
    627a:	6841      	ldr	r1, [r0, #4]
    627c:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
	usb_rx_byte_count_data[ endpoint ] -= ret->len;
    6280:	4a06      	ldr	r2, [pc, #24]	; (629c <usb_rx+0x34>)
    6282:	8801      	ldrh	r1, [r0, #0]
    6284:	f832 4013 	ldrh.w	r4, [r2, r3, lsl #1]
    6288:	1a61      	subs	r1, r4, r1
    628a:	f822 1013 	strh.w	r1, [r2, r3, lsl #1]
	__enable_irq();
    628e:	b662      	cpsie	i
	//serial_print("rx, epidx=");
	//serial_phex(endpoint);
	//serial_print(", packet=");
	//serial_phex32(ret);
	//serial_print("\n");
	return ret;
    6290:	bd10      	pop	{r4, pc}
{
	//print("USB RX");
	usb_packet_t *ret;
	endpoint--;
	if ( endpoint >= NUM_ENDPOINTS )
		return NULL;
    6292:	2000      	movs	r0, #0
	//serial_phex(endpoint);
	//serial_print(", packet=");
	//serial_phex32(ret);
	//serial_print("\n");
	return ret;
}
    6294:	bd10      	pop	{r4, pc}
    6296:	bf00      	nop
    6298:	1fff9568 	.word	0x1fff9568
    629c:	1fffa656 	.word	0x1fffa656

000062a0 <usb_tx_packet_count>:
uint32_t usb_tx_packet_count( uint32_t endpoint )
{
	const usb_packet_t *p;
	uint32_t count=0;

	endpoint--;
    62a0:	3801      	subs	r0, #1
	if ( endpoint >= NUM_ENDPOINTS )
    62a2:	2807      	cmp	r0, #7
    62a4:	d80a      	bhi.n	62bc <usb_tx_packet_count+0x1c>
		return 0;
	__disable_irq();
    62a6:	b672      	cpsid	i
	for ( p = tx_first[ endpoint ]; p; p = p->next )
    62a8:	4b05      	ldr	r3, [pc, #20]	; (62c0 <usb_tx_packet_count+0x20>)
    62aa:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
}

uint32_t usb_tx_packet_count( uint32_t endpoint )
{
	const usb_packet_t *p;
	uint32_t count=0;
    62ae:	2000      	movs	r0, #0

	endpoint--;
	if ( endpoint >= NUM_ENDPOINTS )
		return 0;
	__disable_irq();
	for ( p = tx_first[ endpoint ]; p; p = p->next )
    62b0:	b113      	cbz	r3, 62b8 <usb_tx_packet_count+0x18>
		count++;
    62b2:	3001      	adds	r0, #1

	endpoint--;
	if ( endpoint >= NUM_ENDPOINTS )
		return 0;
	__disable_irq();
	for ( p = tx_first[ endpoint ]; p; p = p->next )
    62b4:	685b      	ldr	r3, [r3, #4]
    62b6:	e7fb      	b.n	62b0 <usb_tx_packet_count+0x10>
		count++;
	__enable_irq();
    62b8:	b662      	cpsie	i
	return count;
    62ba:	4770      	bx	lr
	const usb_packet_t *p;
	uint32_t count=0;

	endpoint--;
	if ( endpoint >= NUM_ENDPOINTS )
		return 0;
    62bc:	2000      	movs	r0, #0
	__disable_irq();
	for ( p = tx_first[ endpoint ]; p; p = p->next )
		count++;
	__enable_irq();
	return count;
}
    62be:	4770      	bx	lr
    62c0:	1fff95cc 	.word	0x1fff95cc

000062c4 <usb_rx_memory>:
// user is creating data very quickly, their consumption could starve reception
// without this prioritization.  The packet buffer (input) is assigned to the
// first endpoint needing memory.
//
void usb_rx_memory( usb_packet_t *packet )
{
    62c4:	b510      	push	{r4, lr}
	unsigned int i;
	const uint8_t *cfg;

	cfg = usb_endpoint_config_table;
	//serial_print("rx_mem:");
	__disable_irq();
    62c6:	b672      	cpsid	i
	for ( i = 1; i <= NUM_ENDPOINTS; i++ )
    62c8:	2301      	movs	r3, #1
    62ca:	4a17      	ldr	r2, [pc, #92]	; (6328 <usb_rx_memory+0x64>)
    62cc:	441a      	add	r2, r3
	{
		if ( *cfg++ & USB_ENDPT_EPRXEN )
    62ce:	f812 2c01 	ldrb.w	r2, [r2, #-1]
    62d2:	0712      	lsls	r2, r2, #28
    62d4:	d51c      	bpl.n	6310 <usb_rx_memory+0x4c>
		{
			if ( table[ index( i, RX, EVEN ) ].desc == 0 )
    62d6:	0099      	lsls	r1, r3, #2
    62d8:	4a14      	ldr	r2, [pc, #80]	; (632c <usb_rx_memory+0x68>)
    62da:	f852 4031 	ldr.w	r4, [r2, r1, lsl #3]
    62de:	b92c      	cbnz	r4, 62ec <usb_rx_memory+0x28>
			{
				table[ index( i, RX, EVEN ) ].addr = packet->buf;
    62e0:	eb02 1343 	add.w	r3, r2, r3, lsl #5
    62e4:	3008      	adds	r0, #8
    62e6:	6058      	str	r0, [r3, #4]
				table[ index( i, RX, EVEN ) ].desc = BDT_DESC( 64, 0 );
    62e8:	4b11      	ldr	r3, [pc, #68]	; (6330 <usb_rx_memory+0x6c>)
    62ea:	e009      	b.n	6300 <usb_rx_memory+0x3c>
				__enable_irq();
				//serial_phex(i);
				//serial_print(",even\n");
				return;
			}
			if ( table[ index( i, RX, ODD ) ].desc == 0 )
    62ec:	f041 0101 	orr.w	r1, r1, #1
    62f0:	f852 4031 	ldr.w	r4, [r2, r1, lsl #3]
    62f4:	b964      	cbnz	r4, 6310 <usb_rx_memory+0x4c>
			{
				table[ index( i, RX, ODD ) ].addr = packet->buf;
    62f6:	eb02 03c1 	add.w	r3, r2, r1, lsl #3
    62fa:	3008      	adds	r0, #8
    62fc:	6058      	str	r0, [r3, #4]
				table[ index( i, RX, ODD ) ].desc = BDT_DESC( 64, 1 );
    62fe:	4b0d      	ldr	r3, [pc, #52]	; (6334 <usb_rx_memory+0x70>)
    6300:	f842 3031 	str.w	r3, [r2, r1, lsl #3]
				usb_rx_memory_needed--;
    6304:	4b0c      	ldr	r3, [pc, #48]	; (6338 <usb_rx_memory+0x74>)
    6306:	781a      	ldrb	r2, [r3, #0]
    6308:	3a01      	subs	r2, #1
    630a:	701a      	strb	r2, [r3, #0]
				__enable_irq();
    630c:	b662      	cpsie	i
				//serial_phex(i);
				//serial_print(",odd\n");
				return;
    630e:	bd10      	pop	{r4, pc}
	const uint8_t *cfg;

	cfg = usb_endpoint_config_table;
	//serial_print("rx_mem:");
	__disable_irq();
	for ( i = 1; i <= NUM_ENDPOINTS; i++ )
    6310:	3301      	adds	r3, #1
    6312:	2b09      	cmp	r3, #9
    6314:	d1d9      	bne.n	62ca <usb_rx_memory+0x6>
				//serial_print(",odd\n");
				return;
			}
		}
	}
	__enable_irq();
    6316:	b662      	cpsie	i
	// we should never reach this point.  If we get here, it means
	// usb_rx_memory_needed was set greater than zero, but no memory
	// was actually needed.
	usb_rx_memory_needed = 0;
    6318:	4b07      	ldr	r3, [pc, #28]	; (6338 <usb_rx_memory+0x74>)
    631a:	2200      	movs	r2, #0
    631c:	701a      	strb	r2, [r3, #0]
	usb_free( packet );
	return;
}
    631e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	__enable_irq();
	// we should never reach this point.  If we get here, it means
	// usb_rx_memory_needed was set greater than zero, but no memory
	// was actually needed.
	usb_rx_memory_needed = 0;
	usb_free( packet );
    6322:	f000 bdb7 	b.w	6e94 <usb_free>
    6326:	bf00      	nop
    6328:	0000b8ba 	.word	0x0000b8ba
    632c:	1fff8000 	.word	0x1fff8000
    6330:	00400088 	.word	0x00400088
    6334:	004000c8 	.word	0x004000c8
    6338:	1fff9616 	.word	0x1fff9616

0000633c <usb_tx>:
void usb_tx( uint32_t endpoint, usb_packet_t *packet )
{
	bdt_t *b = &table[ index( endpoint, TX, EVEN ) ];
	uint8_t next;

	endpoint--;
    633c:	1e43      	subs	r3, r0, #1
	if ( endpoint >= NUM_ENDPOINTS )
    633e:	2b07      	cmp	r3, #7

//#define index(endpoint, tx, odd) (((endpoint) << 2) | ((tx) << 1) | (odd))
//#define stat2bufferdescriptor(stat) (table + ((stat) >> 2))

void usb_tx( uint32_t endpoint, usb_packet_t *packet )
{
    6340:	b530      	push	{r4, r5, lr}
	bdt_t *b = &table[ index( endpoint, TX, EVEN ) ];
	uint8_t next;

	endpoint--;
	if ( endpoint >= NUM_ENDPOINTS )
    6342:	d832      	bhi.n	63aa <usb_tx+0x6e>
//#define index(endpoint, tx, odd) (((endpoint) << 2) | ((tx) << 1) | (odd))
//#define stat2bufferdescriptor(stat) (table + ((stat) >> 2))

void usb_tx( uint32_t endpoint, usb_packet_t *packet )
{
	bdt_t *b = &table[ index( endpoint, TX, EVEN ) ];
    6344:	4a19      	ldr	r2, [pc, #100]	; (63ac <usb_tx+0x70>)
    6346:	0140      	lsls	r0, r0, #5
    6348:	f040 0010 	orr.w	r0, r0, #16
    634c:	4410      	add	r0, r2
	uint8_t next;

	endpoint--;
	if ( endpoint >= NUM_ENDPOINTS )
		return;
	__disable_irq();
    634e:	b672      	cpsid	i
	//serial_print("txstate=");
	//serial_phex(tx_state[ endpoint ]);
	//serial_print("\n");
	switch ( tx_state[ endpoint ] )
    6350:	4c17      	ldr	r4, [pc, #92]	; (63b0 <usb_tx+0x74>)
    6352:	5ce2      	ldrb	r2, [r4, r3]
    6354:	2a03      	cmp	r2, #3
    6356:	d809      	bhi.n	636c <usb_tx+0x30>
    6358:	e8df f002 	tbb	[pc, r2]
    635c:	05180216 	.word	0x05180216
	{
	case TX_STATE_BOTH_FREE_EVEN_FIRST:
		next = TX_STATE_ODD_FREE;
		break;
	case TX_STATE_BOTH_FREE_ODD_FIRST:
		b++;
    6360:	3008      	adds	r0, #8
		next = TX_STATE_EVEN_FREE;
    6362:	2202      	movs	r2, #2
		break;
    6364:	e013      	b.n	638e <usb_tx+0x52>
	case TX_STATE_EVEN_FREE:
		next = TX_STATE_NONE_FREE_ODD_FIRST;
		break;
	case TX_STATE_ODD_FREE:
		b++;
    6366:	3008      	adds	r0, #8
		next = TX_STATE_NONE_FREE_EVEN_FIRST;
    6368:	2204      	movs	r2, #4
		break;
    636a:	e010      	b.n	638e <usb_tx+0x52>
	default:
		if (tx_first[ endpoint ] == NULL)
    636c:	4811      	ldr	r0, [pc, #68]	; (63b4 <usb_tx+0x78>)
    636e:	4a12      	ldr	r2, [pc, #72]	; (63b8 <usb_tx+0x7c>)
    6370:	f850 4023 	ldr.w	r4, [r0, r3, lsl #2]
    6374:	b914      	cbnz	r4, 637c <usb_tx+0x40>
		{
			tx_first[ endpoint ] = packet;
    6376:	f840 1023 	str.w	r1, [r0, r3, lsl #2]
    637a:	e002      	b.n	6382 <usb_tx+0x46>
		}
		else
		{
			tx_last[ endpoint ]->next = packet;
    637c:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
    6380:	6041      	str	r1, [r0, #4]
		}
		tx_last[ endpoint ] = packet;
    6382:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
    6386:	e00f      	b.n	63a8 <usb_tx+0x6c>
	//serial_phex(tx_state[ endpoint ]);
	//serial_print("\n");
	switch ( tx_state[ endpoint ] )
	{
	case TX_STATE_BOTH_FREE_EVEN_FIRST:
		next = TX_STATE_ODD_FREE;
    6388:	2203      	movs	r2, #3
    638a:	e000      	b.n	638e <usb_tx+0x52>
	case TX_STATE_BOTH_FREE_ODD_FIRST:
		b++;
		next = TX_STATE_EVEN_FREE;
		break;
	case TX_STATE_EVEN_FREE:
		next = TX_STATE_NONE_FREE_ODD_FIRST;
    638c:	2205      	movs	r2, #5
		tx_last[ endpoint ] = packet;
		__enable_irq();
		return;
	}

	tx_state[ endpoint ] = next;
    638e:	54e2      	strb	r2, [r4, r3]
	b->addr = packet->buf;
	b->desc = BDT_DESC( packet->len, ((uint32_t)b & 8) ? DATA1 : DATA0 );
    6390:	f010 0f08 	tst.w	r0, #8
		__enable_irq();
		return;
	}

	tx_state[ endpoint ] = next;
	b->addr = packet->buf;
    6394:	f101 0308 	add.w	r3, r1, #8
	b->desc = BDT_DESC( packet->len, ((uint32_t)b & 8) ? DATA1 : DATA0 );
    6398:	880a      	ldrh	r2, [r1, #0]
		__enable_irq();
		return;
	}

	tx_state[ endpoint ] = next;
	b->addr = packet->buf;
    639a:	6043      	str	r3, [r0, #4]
	b->desc = BDT_DESC( packet->len, ((uint32_t)b & 8) ? DATA1 : DATA0 );
    639c:	bf0c      	ite	eq
    639e:	2388      	moveq	r3, #136	; 0x88
    63a0:	23c8      	movne	r3, #200	; 0xc8
    63a2:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
    63a6:	6003      	str	r3, [r0, #0]
	__enable_irq();
    63a8:	b662      	cpsie	i
    63aa:	bd30      	pop	{r4, r5, pc}
    63ac:	1fff8000 	.word	0x1fff8000
    63b0:	1fff9520 	.word	0x1fff9520
    63b4:	1fff95cc 	.word	0x1fff95cc
    63b8:	1fff95ec 	.word	0x1fff95ec

000063bc <usb_device_reload>:
}


void usb_device_reload()
{
    63bc:	4b05      	ldr	r3, [pc, #20]	; (63d4 <usb_device_reload+0x18>)
// MCHCK
// Kiibohd mk20dx256vlh7
#if defined(_mk20dx128vlf5_) || defined(_mk20dx256vlh7_)
	// Copies variable into the VBAT register, must be identical to the variable in the bootloader to jump to the bootloader flash mode
	for ( int pos = 0; pos < sizeof(sys_reset_to_loader_magic); pos++ )
		(&VBAT)[ pos ] = sys_reset_to_loader_magic[ pos ];
    63be:	4a06      	ldr	r2, [pc, #24]	; (63d8 <usb_device_reload+0x1c>)
    63c0:	5c9a      	ldrb	r2, [r3, r2]
    63c2:	f803 2b01 	strb.w	r2, [r3], #1
{
// MCHCK
// Kiibohd mk20dx256vlh7
#if defined(_mk20dx128vlf5_) || defined(_mk20dx256vlh7_)
	// Copies variable into the VBAT register, must be identical to the variable in the bootloader to jump to the bootloader flash mode
	for ( int pos = 0; pos < sizeof(sys_reset_to_loader_magic); pos++ )
    63c6:	4a05      	ldr	r2, [pc, #20]	; (63dc <usb_device_reload+0x20>)
    63c8:	4293      	cmp	r3, r2
    63ca:	d1f8      	bne.n	63be <usb_device_reload+0x2>
		(&VBAT)[ pos ] = sys_reset_to_loader_magic[ pos ];
	SOFTWARE_RESET();
    63cc:	4a04      	ldr	r2, [pc, #16]	; (63e0 <usb_device_reload+0x24>)
    63ce:	4b05      	ldr	r3, [pc, #20]	; (63e4 <usb_device_reload+0x28>)
    63d0:	601a      	str	r2, [r3, #0]
    63d2:	4770      	bx	lr
    63d4:	4003e000 	.word	0x4003e000
    63d8:	bffc9acf 	.word	0xbffc9acf
    63dc:	4003e016 	.word	0x4003e016
    63e0:	05fa0004 	.word	0x05fa0004
    63e4:	e000ed0c 	.word	0xe000ed0c

000063e8 <usb_isr>:
#endif
}


void usb_isr()
{
    63e8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	//serial_print("isr");
	//status = USB0_ISTAT;
	//serial_phex(status);
	//serial_print("\n");
restart:
	status = USB0_ISTAT;
    63ec:	4bae      	ldr	r3, [pc, #696]	; (66a8 <usb_isr+0x2c0>)
    63ee:	781c      	ldrb	r4, [r3, #0]
    63f0:	b2e4      	uxtb	r4, r4
	print("USB ISR STATUS: ");
	printHex( status );
	print( NL );
	*/

	if ( (status & USB_INTEN_SOFTOKEN /* 04 */ ) )
    63f2:	0760      	lsls	r0, r4, #29
    63f4:	d51b      	bpl.n	642e <usb_isr+0x46>
	{
		if ( usb_configuration )
    63f6:	4bad      	ldr	r3, [pc, #692]	; (66ac <usb_isr+0x2c4>)
    63f8:	781b      	ldrb	r3, [r3, #0]
    63fa:	b1ab      	cbz	r3, 6428 <usb_isr+0x40>
		{
			t = usb_reboot_timer;
    63fc:	4aac      	ldr	r2, [pc, #688]	; (66b0 <usb_isr+0x2c8>)
    63fe:	7811      	ldrb	r1, [r2, #0]
			if ( t )
    6400:	f001 03ff 	and.w	r3, r1, #255	; 0xff
    6404:	b129      	cbz	r1, 6412 <usb_isr+0x2a>
			{
				usb_reboot_timer = --t;
    6406:	3b01      	subs	r3, #1
    6408:	b2db      	uxtb	r3, r3
    640a:	7013      	strb	r3, [r2, #0]
				if ( !t )
    640c:	b90b      	cbnz	r3, 6412 <usb_isr+0x2a>
					usb_device_reload();
    640e:	f7ff ffd5 	bl	63bc <usb_device_reload>
			}

			// CDC Interface
			t = usb_cdc_transmit_flush_timer;
    6412:	4aa8      	ldr	r2, [pc, #672]	; (66b4 <usb_isr+0x2cc>)
    6414:	7811      	ldrb	r1, [r2, #0]
			if ( t )
    6416:	f001 03ff 	and.w	r3, r1, #255	; 0xff
    641a:	b129      	cbz	r1, 6428 <usb_isr+0x40>
			{
				usb_cdc_transmit_flush_timer = --t;
    641c:	3b01      	subs	r3, #1
    641e:	b2db      	uxtb	r3, r3
    6420:	7013      	strb	r3, [r2, #0]
				if ( t == 0 )
    6422:	b90b      	cbnz	r3, 6428 <usb_isr+0x40>
					usb_serial_flush_callback();
    6424:	f000 fdf4 	bl	7010 <usb_serial_flush_callback>
			}

		}
		USB0_ISTAT = USB_INTEN_SOFTOKEN;
    6428:	4b9f      	ldr	r3, [pc, #636]	; (66a8 <usb_isr+0x2c0>)
    642a:	2204      	movs	r2, #4
    642c:	701a      	strb	r2, [r3, #0]
	}

	if ( (status & USB_ISTAT_TOKDNE /* 08 */ ) )
    642e:	f004 0308 	and.w	r3, r4, #8
    6432:	f003 02ff 	and.w	r2, r3, #255	; 0xff
    6436:	2b00      	cmp	r3, #0
    6438:	f000 8303 	beq.w	6a42 <usb_isr+0x65a>
	{
		uint8_t endpoint;
		stat = USB0_STAT;
    643c:	4b9e      	ldr	r3, [pc, #632]	; (66b8 <usb_isr+0x2d0>)
    643e:	4c9f      	ldr	r4, [pc, #636]	; (66bc <usb_isr+0x2d4>)
    6440:	781a      	ldrb	r2, [r3, #0]
    6442:	b2d2      	uxtb	r2, r2
		//serial_print("token: ep=");
		//serial_phex(stat >> 4);
		//serial_print(stat & 0x08 ? ",tx" : ",rx");
		//serial_print(stat & 0x04 ? ",odd\n" : ",even\n");
		endpoint = stat >> 4;
		if ( endpoint == 0 )
    6444:	0915      	lsrs	r5, r2, #4
    6446:	ea4f 0792 	mov.w	r7, r2, lsr #2
    644a:	f040 825a 	bne.w	6902 <usb_isr+0x51a>
	bdt_t *b;
	uint32_t pid, size;
	uint8_t *buf;
	const uint8_t *data;

	b = stat2bufferdescriptor( stat );
    644e:	eb04 03c7 	add.w	r3, r4, r7, lsl #3
	pid = BDT_PID( b->desc );
	buf = b->addr;
    6452:	685a      	ldr	r2, [r3, #4]
	uint32_t pid, size;
	uint8_t *buf;
	const uint8_t *data;

	b = stat2bufferdescriptor( stat );
	pid = BDT_PID( b->desc );
    6454:	f854 3037 	ldr.w	r3, [r4, r7, lsl #3]
    6458:	f3c3 0383 	ubfx	r3, r3, #2, #4
	print(", count:");
	printHex32(b->desc);
	print(" - ");
	#endif

	switch (pid)
    645c:	3b01      	subs	r3, #1
    645e:	2b0c      	cmp	r3, #12
    6460:	f200 824c 	bhi.w	68fc <usb_isr+0x514>
    6464:	e8df f013 	tbh	[pc, r3, lsl #1]
    6468:	01f001f0 	.word	0x01f001f0
    646c:	024a024a 	.word	0x024a024a
    6470:	024a024a 	.word	0x024a024a
    6474:	024a024a 	.word	0x024a024a
    6478:	024a0228 	.word	0x024a0228
    647c:	024a024a 	.word	0x024a024a
    6480:	000d      	.short	0x000d
	{
	case 0x0D: // Setup received from host
		//serial_print("PID=Setup\n");
		//if (count != 8) ; // panic?
		// grab the 8 byte setup info
		setup.word1 = *(uint32_t *)(buf);
    6482:	6813      	ldr	r3, [r2, #0]
    6484:	4d8e      	ldr	r5, [pc, #568]	; (66c0 <usb_isr+0x2d8>)
		setup.word2 = *(uint32_t *)(buf + 4);
    6486:	6852      	ldr	r2, [r2, #4]
	{
	case 0x0D: // Setup received from host
		//serial_print("PID=Setup\n");
		//if (count != 8) ; // panic?
		// grab the 8 byte setup info
		setup.word1 = *(uint32_t *)(buf);
    6488:	602b      	str	r3, [r5, #0]
		setup.word2 = *(uint32_t *)(buf + 4);
    648a:	606a      	str	r2, [r5, #4]

		// give the buffer back
		b->desc = BDT_DESC( EP0_SIZE, DATA1 );
    648c:	4a8d      	ldr	r2, [pc, #564]	; (66c4 <usb_isr+0x2dc>)
	volatile uint8_t *reg;
	uint8_t epconf;
	const uint8_t *cfg;
	int i;

	switch ( setup.wRequestAndType )
    648e:	b29b      	uxth	r3, r3
		// grab the 8 byte setup info
		setup.word1 = *(uint32_t *)(buf);
		setup.word2 = *(uint32_t *)(buf + 4);

		// give the buffer back
		b->desc = BDT_DESC( EP0_SIZE, DATA1 );
    6490:	f844 2037 	str.w	r2, [r4, r7, lsl #3]
		//table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 1);
		//table[index(0, RX, ODD)].desc = BDT_DESC(EP0_SIZE, 1);

		// clear any leftover pending IN transactions
		ep0_tx_ptr = NULL;
    6494:	4f8c      	ldr	r7, [pc, #560]	; (66c8 <usb_isr+0x2e0>)
			//serial_print("leftover tx odd\n");
		//}
		table[index(0, TX, EVEN)].desc = 0;
		table[index(0, TX, ODD)].desc = 0;
		// first IN after Setup is always DATA1
		ep0_tx_data_toggle = 1;
    6496:	4a8d      	ldr	r2, [pc, #564]	; (66cc <usb_isr+0x2e4>)
		b->desc = BDT_DESC( EP0_SIZE, DATA1 );
		//table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 1);
		//table[index(0, RX, ODD)].desc = BDT_DESC(EP0_SIZE, 1);

		// clear any leftover pending IN transactions
		ep0_tx_ptr = NULL;
    6498:	2100      	movs	r1, #0
			//serial_print("leftover tx odd\n");
		//}
		table[index(0, TX, EVEN)].desc = 0;
		table[index(0, TX, ODD)].desc = 0;
		// first IN after Setup is always DATA1
		ep0_tx_data_toggle = 1;
    649a:	2601      	movs	r6, #1
	volatile uint8_t *reg;
	uint8_t epconf;
	const uint8_t *cfg;
	int i;

	switch ( setup.wRequestAndType )
    649c:	f5b3 6fa0 	cmp.w	r3, #1280	; 0x500
		b->desc = BDT_DESC( EP0_SIZE, DATA1 );
		//table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 1);
		//table[index(0, RX, ODD)].desc = BDT_DESC(EP0_SIZE, 1);

		// clear any leftover pending IN transactions
		ep0_tx_ptr = NULL;
    64a0:	6039      	str	r1, [r7, #0]
			//serial_print("leftover tx even\n");
		//}
		//if (table[index(0, TX, ODD)].desc & 0x80) {
			//serial_print("leftover tx odd\n");
		//}
		table[index(0, TX, EVEN)].desc = 0;
    64a2:	6121      	str	r1, [r4, #16]
		table[index(0, TX, ODD)].desc = 0;
    64a4:	61a1      	str	r1, [r4, #24]
		// first IN after Setup is always DATA1
		ep0_tx_data_toggle = 1;
    64a6:	7016      	strb	r6, [r2, #0]
	volatile uint8_t *reg;
	uint8_t epconf;
	const uint8_t *cfg;
	int i;

	switch ( setup.wRequestAndType )
    64a8:	f000 81a5 	beq.w	67f6 <usb_isr+0x40e>
    64ac:	d82b      	bhi.n	6506 <usb_isr+0x11e>
    64ae:	f5b3 7f81 	cmp.w	r3, #258	; 0x102
    64b2:	f000 813a 	beq.w	672a <usb_isr+0x342>
    64b6:	d810      	bhi.n	64da <usb_isr+0xf2>
    64b8:	2b82      	cmp	r3, #130	; 0x82
    64ba:	f000 8129 	beq.w	6710 <usb_isr+0x328>
    64be:	d806      	bhi.n	64ce <usb_isr+0xe6>
    64c0:	2b80      	cmp	r3, #128	; 0x80
    64c2:	f040 8191 	bne.w	67e8 <usb_isr+0x400>
		datalen = 1;
		data = reply_buffer;
		goto send;

	case 0x0080: // GET_STATUS (device)
		reply_buffer[0] = 0;
    64c6:	4c82      	ldr	r4, [pc, #520]	; (66d0 <usb_isr+0x2e8>)
    64c8:	7021      	strb	r1, [r4, #0]
		reply_buffer[1] = 0;
    64ca:	7061      	strb	r1, [r4, #1]
    64cc:	e195      	b.n	67fa <usb_isr+0x412>
	volatile uint8_t *reg;
	uint8_t epconf;
	const uint8_t *cfg;
	int i;

	switch ( setup.wRequestAndType )
    64ce:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
    64d2:	f0c0 8189 	bcc.w	67e8 <usb_isr+0x400>
		goto send;

	case 0x0100: // CLEAR_FEATURE (device)
	case 0x0101: // CLEAR_FEATURE (interface)
		// TODO: Currently ignoring, perhaps useful? -HaaTa
		warn_print("CLEAR_FEATURE - Device/Interface");
    64d6:	487f      	ldr	r0, [pc, #508]	; (66d4 <usb_isr+0x2ec>)
    64d8:	e168      	b.n	67ac <usb_isr+0x3c4>
	volatile uint8_t *reg;
	uint8_t epconf;
	const uint8_t *cfg;
	int i;

	switch ( setup.wRequestAndType )
    64da:	f240 3201 	movw	r2, #769	; 0x301
    64de:	4293      	cmp	r3, r2
    64e0:	d80b      	bhi.n	64fa <usb_isr+0x112>
    64e2:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
    64e6:	f080 812f 	bcs.w	6748 <usb_isr+0x360>
    64ea:	f5a2 72b0 	sub.w	r2, r2, #352	; 0x160
    64ee:	4293      	cmp	r3, r2
    64f0:	f040 817a 	bne.w	67e8 <usb_isr+0x400>
		{
			if ( list->addr == NULL )
				break;
			if ( list->wValue != 0x2200 )
				continue;
			if ( setup.wIndex == list->wIndex )
    64f4:	88aa      	ldrh	r2, [r5, #4]
    64f6:	4b78      	ldr	r3, [pc, #480]	; (66d8 <usb_isr+0x2f0>)
    64f8:	e161      	b.n	67be <usb_isr+0x3d6>
	volatile uint8_t *reg;
	uint8_t epconf;
	const uint8_t *cfg;
	int i;

	switch ( setup.wRequestAndType )
    64fa:	f240 3202 	movw	r2, #770	; 0x302
    64fe:	4293      	cmp	r3, r2
    6500:	f000 8124 	beq.w	674c <usb_isr+0x364>
    6504:	e170      	b.n	67e8 <usb_isr+0x400>
    6506:	f640 1221 	movw	r2, #2337	; 0x921
    650a:	4293      	cmp	r3, r2
    650c:	f000 8143 	beq.w	6796 <usb_isr+0x3ae>
    6510:	d81c      	bhi.n	654c <usb_isr+0x164>
    6512:	f5b3 6f08 	cmp.w	r3, #2176	; 0x880
    6516:	f000 80c0 	beq.w	669a <usb_isr+0x2b2>
    651a:	d808      	bhi.n	652e <usb_isr+0x146>
    651c:	f5a3 63d0 	sub.w	r3, r3, #1664	; 0x680
    6520:	2b01      	cmp	r3, #1
    6522:	f200 8161 	bhi.w	67e8 <usb_isr+0x400>
		#endif
		for ( list = usb_descriptor_list; 1; list++ )
		{
			if ( list->addr == NULL )
				break;
			if ( setup.wValue == list->wValue && setup.wIndex == list->wIndex )
    6526:	886a      	ldrh	r2, [r5, #2]
    6528:	88a9      	ldrh	r1, [r5, #4]
    652a:	4b6b      	ldr	r3, [pc, #428]	; (66d8 <usb_isr+0x2f0>)
    652c:	e122      	b.n	6774 <usb_isr+0x38c>
	volatile uint8_t *reg;
	uint8_t epconf;
	const uint8_t *cfg;
	int i;

	switch ( setup.wRequestAndType )
    652e:	f5b3 6f10 	cmp.w	r3, #2304	; 0x900
    6532:	f040 8159 	bne.w	67e8 <usb_isr+0x400>

	case 0x0900: // SET_CONFIGURATION
		#ifdef UART_DEBUG
		print("CONFIGURE - ");
		#endif
		usb_configuration = setup.wValue;
    6536:	4b5d      	ldr	r3, [pc, #372]	; (66ac <usb_isr+0x2c4>)
    6538:	78aa      	ldrb	r2, [r5, #2]
    653a:	4e60      	ldr	r6, [pc, #384]	; (66bc <usb_isr+0x2d4>)
    653c:	701a      	strb	r2, [r3, #0]
		Output_Available = usb_configuration;
    653e:	781a      	ldrb	r2, [r3, #0]
    6540:	4b66      	ldr	r3, [pc, #408]	; (66dc <usb_isr+0x2f4>)
    6542:	b2d2      	uxtb	r2, r2
    6544:	701a      	strb	r2, [r3, #0]
    6546:	f506 7880 	add.w	r8, r6, #256	; 0x100
    654a:	e01e      	b.n	658a <usb_isr+0x1a2>
	volatile uint8_t *reg;
	uint8_t epconf;
	const uint8_t *cfg;
	int i;

	switch ( setup.wRequestAndType )
    654c:	f242 0221 	movw	r2, #8225	; 0x2021
    6550:	4293      	cmp	r3, r2
    6552:	f000 8176 	beq.w	6842 <usb_isr+0x45a>
    6556:	d80c      	bhi.n	6572 <usb_isr+0x18a>
    6558:	f5a2 52b0 	sub.w	r2, r2, #5632	; 0x1600
    655c:	4293      	cmp	r3, r2
    655e:	f000 813a 	beq.w	67d6 <usb_isr+0x3ee>
    6562:	f502 7280 	add.w	r2, r2, #256	; 0x100
    6566:	4293      	cmp	r3, r2
    6568:	f040 813e 	bne.w	67e8 <usb_isr+0x400>
		printHex( setup.wValue );
		print(" - ");
		printHex( setup.wValue & 0xFF );
		print(NL);
		#endif
		USBKeys_Protocol = setup.wValue & 0xFF; // 0 - Boot Mode, 1 - NKRO Mode
    656c:	78aa      	ldrb	r2, [r5, #2]
    656e:	4b5c      	ldr	r3, [pc, #368]	; (66e0 <usb_isr+0x2f8>)
    6570:	e138      	b.n	67e4 <usb_isr+0x3fc>
	volatile uint8_t *reg;
	uint8_t epconf;
	const uint8_t *cfg;
	int i;

	switch ( setup.wRequestAndType )
    6572:	f242 12a1 	movw	r2, #8609	; 0x21a1
    6576:	4293      	cmp	r3, r2
    6578:	f000 813a 	beq.w	67f0 <usb_isr+0x408>
    657c:	3280      	adds	r2, #128	; 0x80
    657e:	4293      	cmp	r3, r2
    6580:	f040 8132 	bne.w	67e8 <usb_isr+0x400>
		#endif
		endpoint0_stall();
		return;

	case 0x2221: // CDC_SET_CONTROL_LINE_STATE
		usb_cdc_line_rtsdtr = setup.wValue;
    6584:	78aa      	ldrb	r2, [r5, #2]
    6586:	4b57      	ldr	r3, [pc, #348]	; (66e4 <usb_isr+0x2fc>)
    6588:	e12c      	b.n	67e4 <usb_isr+0x3fc>
		reg = &USB0_ENDPT1;
		cfg = usb_endpoint_config_table;
		// clear all BDT entries, free any allocated memory...
		for ( i = 4; i < ( NUM_ENDPOINTS + 1) * 4; i++ )
		{
			if ( table[i].desc & BDT_OWN )
    658a:	6a33      	ldr	r3, [r6, #32]
    658c:	0619      	lsls	r1, r3, #24
    658e:	d503      	bpl.n	6598 <usb_isr+0x1b0>
			{
				usb_free( (usb_packet_t *)((uint8_t *)(table[ i ].addr) - 8) );
    6590:	6a70      	ldr	r0, [r6, #36]	; 0x24
    6592:	3808      	subs	r0, #8
    6594:	f000 fc7e 	bl	6e94 <usb_free>
    6598:	3608      	adds	r6, #8
		usb_configuration = setup.wValue;
		Output_Available = usb_configuration;
		reg = &USB0_ENDPT1;
		cfg = usb_endpoint_config_table;
		// clear all BDT entries, free any allocated memory...
		for ( i = 4; i < ( NUM_ENDPOINTS + 1) * 4; i++ )
    659a:	4546      	cmp	r6, r8
    659c:	d1f5      	bne.n	658a <usb_isr+0x1a2>
    659e:	2600      	movs	r6, #0
    65a0:	46b0      	mov	r8, r6
		}
		// free all queued packets
		for ( i = 0; i < NUM_ENDPOINTS; i++ )
		{
			usb_packet_t *p, *n;
			p = rx_first[i];
    65a2:	f8df 9164 	ldr.w	r9, [pc, #356]	; 6708 <usb_isr+0x320>
    65a6:	f856 0009 	ldr.w	r0, [r6, r9]
			while ( p )
    65aa:	b128      	cbz	r0, 65b8 <usb_isr+0x1d0>
			{
				n = p->next;
    65ac:	f8d0 a004 	ldr.w	sl, [r0, #4]
				usb_free(p);
    65b0:	f000 fc70 	bl	6e94 <usb_free>
				p = n;
    65b4:	4650      	mov	r0, sl
    65b6:	e7f8      	b.n	65aa <usb_isr+0x1c2>
			}
			rx_first[ i ] = NULL;
    65b8:	f849 0006 	str.w	r0, [r9, r6]
			rx_last[ i ] = NULL;
    65bc:	4b4a      	ldr	r3, [pc, #296]	; (66e8 <usb_isr+0x300>)
			p = tx_first[i];
    65be:	f8df 914c 	ldr.w	r9, [pc, #332]	; 670c <usb_isr+0x324>
				n = p->next;
				usb_free(p);
				p = n;
			}
			rx_first[ i ] = NULL;
			rx_last[ i ] = NULL;
    65c2:	50f0      	str	r0, [r6, r3]
			p = tx_first[i];
    65c4:	f856 0009 	ldr.w	r0, [r6, r9]
			while (p)
    65c8:	b128      	cbz	r0, 65d6 <usb_isr+0x1ee>
			{
				n = p->next;
    65ca:	f8d0 a004 	ldr.w	sl, [r0, #4]
				usb_free(p);
    65ce:	f000 fc61 	bl	6e94 <usb_free>
				p = n;
    65d2:	4650      	mov	r0, sl
    65d4:	e7f8      	b.n	65c8 <usb_isr+0x1e0>
			}
			tx_first[ i ] = NULL;
			tx_last[ i ] = NULL;
    65d6:	4b45      	ldr	r3, [pc, #276]	; (66ec <usb_isr+0x304>)
			{
				n = p->next;
				usb_free(p);
				p = n;
			}
			tx_first[ i ] = NULL;
    65d8:	f849 0006 	str.w	r0, [r9, r6]
			tx_last[ i ] = NULL;
    65dc:	50f0      	str	r0, [r6, r3]
			usb_rx_byte_count_data[i] = 0;
    65de:	4b44      	ldr	r3, [pc, #272]	; (66f0 <usb_isr+0x308>)
    65e0:	f823 0018 	strh.w	r0, [r3, r8, lsl #1]

			switch ( tx_state[ i ] )
    65e4:	4b43      	ldr	r3, [pc, #268]	; (66f4 <usb_isr+0x30c>)
    65e6:	f818 2003 	ldrb.w	r2, [r8, r3]
    65ea:	3a02      	subs	r2, #2
    65ec:	2a03      	cmp	r2, #3
    65ee:	d808      	bhi.n	6602 <usb_isr+0x21a>
    65f0:	e8df f002 	tbb	[pc, r2]
    65f4:	04020402 	.word	0x04020402
			{
			case TX_STATE_EVEN_FREE:
			case TX_STATE_NONE_FREE_EVEN_FIRST:
				tx_state[ i ] = TX_STATE_BOTH_FREE_EVEN_FIRST;
    65f8:	2200      	movs	r2, #0
    65fa:	e000      	b.n	65fe <usb_isr+0x216>
				break;
			case TX_STATE_ODD_FREE:
			case TX_STATE_NONE_FREE_ODD_FIRST:
				tx_state[ i ] = TX_STATE_BOTH_FREE_ODD_FIRST;
    65fc:	2201      	movs	r2, #1
    65fe:	f803 2008 	strb.w	r2, [r3, r8]
			{
				usb_free( (usb_packet_t *)((uint8_t *)(table[ i ].addr) - 8) );
			}
		}
		// free all queued packets
		for ( i = 0; i < NUM_ENDPOINTS; i++ )
    6602:	f108 0801 	add.w	r8, r8, #1
    6606:	f1b8 0f08 	cmp.w	r8, #8
    660a:	f106 0604 	add.w	r6, r6, #4
    660e:	d1c8      	bne.n	65a2 <usb_isr+0x1ba>
				break;
			default:
				break;
			}
		}
		usb_rx_memory_needed = 0;
    6610:	4b39      	ldr	r3, [pc, #228]	; (66f8 <usb_isr+0x310>)
    6612:	2200      	movs	r2, #0
    6614:	701a      	strb	r2, [r3, #0]
		for ( i = 1; i <= NUM_ENDPOINTS; i++ )
    6616:	2601      	movs	r6, #1
    6618:	4699      	mov	r9, r3
    661a:	4a38      	ldr	r2, [pc, #224]	; (66fc <usb_isr+0x314>)
    661c:	4b38      	ldr	r3, [pc, #224]	; (6700 <usb_isr+0x318>)
    661e:	4432      	add	r2, r6
    6620:	4433      	add	r3, r6
		{
			epconf = *cfg++;
    6622:	f812 2c01 	ldrb.w	r2, [r2, #-1]
    6626:	009b      	lsls	r3, r3, #2
			*reg = epconf;
			reg += 4;
			if ( epconf & USB_ENDPT_EPRXEN )
    6628:	f012 0f08 	tst.w	r2, #8
		}
		usb_rx_memory_needed = 0;
		for ( i = 1; i <= NUM_ENDPOINTS; i++ )
		{
			epconf = *cfg++;
			*reg = epconf;
    662c:	701a      	strb	r2, [r3, #0]
    662e:	ea4f 0886 	mov.w	r8, r6, lsl #2
			reg += 4;
			if ( epconf & USB_ENDPT_EPRXEN )
    6632:	d025      	beq.n	6680 <usb_isr+0x298>
			{
				usb_packet_t *p;
				p = usb_malloc();
    6634:	f000 fc10 	bl	6e58 <usb_malloc>
				if ( p )
    6638:	b138      	cbz	r0, 664a <usb_isr+0x262>
				{
					table[ index( i, RX, EVEN ) ].addr = p->buf;
    663a:	eb04 1346 	add.w	r3, r4, r6, lsl #5
    663e:	3008      	adds	r0, #8
    6640:	6058      	str	r0, [r3, #4]
					table[ index( i, RX, EVEN ) ].desc = BDT_DESC( 64, 0 );
    6642:	4b30      	ldr	r3, [pc, #192]	; (6704 <usb_isr+0x31c>)
    6644:	f844 3038 	str.w	r3, [r4, r8, lsl #3]
    6648:	e006      	b.n	6658 <usb_isr+0x270>
				}
				else
				{
					table[ index( i, RX, EVEN ) ].desc = 0;
					usb_rx_memory_needed++;
    664a:	f899 3000 	ldrb.w	r3, [r9]
					table[ index( i, RX, EVEN ) ].addr = p->buf;
					table[ index( i, RX, EVEN ) ].desc = BDT_DESC( 64, 0 );
				}
				else
				{
					table[ index( i, RX, EVEN ) ].desc = 0;
    664e:	f844 0038 	str.w	r0, [r4, r8, lsl #3]
					usb_rx_memory_needed++;
    6652:	3301      	adds	r3, #1
    6654:	f889 3000 	strb.w	r3, [r9]
				}
				p = usb_malloc();
    6658:	f000 fbfe 	bl	6e58 <usb_malloc>
				if ( p )
				{
					table[ index( i, RX, ODD ) ].addr = p->buf;
    665c:	f048 0301 	orr.w	r3, r8, #1
				{
					table[ index( i, RX, EVEN ) ].desc = 0;
					usb_rx_memory_needed++;
				}
				p = usb_malloc();
				if ( p )
    6660:	b138      	cbz	r0, 6672 <usb_isr+0x28a>
				{
					table[ index( i, RX, ODD ) ].addr = p->buf;
    6662:	eb04 02c3 	add.w	r2, r4, r3, lsl #3
    6666:	3008      	adds	r0, #8
    6668:	6050      	str	r0, [r2, #4]
					table[ index( i, RX, ODD ) ].desc = BDT_DESC( 64, 1 );
    666a:	4a16      	ldr	r2, [pc, #88]	; (66c4 <usb_isr+0x2dc>)
    666c:	f844 2033 	str.w	r2, [r4, r3, lsl #3]
    6670:	e006      	b.n	6680 <usb_isr+0x298>
				}
				else
				{
					table[ index( i, RX, ODD ) ].desc = 0;
    6672:	f844 0033 	str.w	r0, [r4, r3, lsl #3]
					usb_rx_memory_needed++;
    6676:	f899 3000 	ldrb.w	r3, [r9]
    667a:	3301      	adds	r3, #1
    667c:	f889 3000 	strb.w	r3, [r9]
				}
			}
			table[ index( i, TX, EVEN ) ].desc = 0;
    6680:	f048 0302 	orr.w	r3, r8, #2
			default:
				break;
			}
		}
		usb_rx_memory_needed = 0;
		for ( i = 1; i <= NUM_ENDPOINTS; i++ )
    6684:	3601      	adds	r6, #1
					table[ index( i, RX, ODD ) ].desc = 0;
					usb_rx_memory_needed++;
				}
			}
			table[ index( i, TX, EVEN ) ].desc = 0;
			table[ index( i, TX, ODD ) ].desc = 0;
    6686:	f048 0803 	orr.w	r8, r8, #3
				{
					table[ index( i, RX, ODD ) ].desc = 0;
					usb_rx_memory_needed++;
				}
			}
			table[ index( i, TX, EVEN ) ].desc = 0;
    668a:	2100      	movs	r1, #0
			default:
				break;
			}
		}
		usb_rx_memory_needed = 0;
		for ( i = 1; i <= NUM_ENDPOINTS; i++ )
    668c:	2e09      	cmp	r6, #9
				{
					table[ index( i, RX, ODD ) ].desc = 0;
					usb_rx_memory_needed++;
				}
			}
			table[ index( i, TX, EVEN ) ].desc = 0;
    668e:	f844 1033 	str.w	r1, [r4, r3, lsl #3]
			table[ index( i, TX, ODD ) ].desc = 0;
    6692:	f844 1038 	str.w	r1, [r4, r8, lsl #3]
			default:
				break;
			}
		}
		usb_rx_memory_needed = 0;
		for ( i = 1; i <= NUM_ENDPOINTS; i++ )
    6696:	d1c0      	bne.n	661a <usb_isr+0x232>
    6698:	e0ad      	b.n	67f6 <usb_isr+0x40e>
			table[ index( i, TX, ODD ) ].desc = 0;
		}
		goto send;

	case 0x0880: // GET_CONFIGURATION
		reply_buffer[0] = usb_configuration;
    669a:	4b04      	ldr	r3, [pc, #16]	; (66ac <usb_isr+0x2c4>)
    669c:	4c0c      	ldr	r4, [pc, #48]	; (66d0 <usb_isr+0x2e8>)
    669e:	781b      	ldrb	r3, [r3, #0]
		datalen = 1;
    66a0:	4631      	mov	r1, r6
			table[ index( i, TX, ODD ) ].desc = 0;
		}
		goto send;

	case 0x0880: // GET_CONFIGURATION
		reply_buffer[0] = usb_configuration;
    66a2:	7023      	strb	r3, [r4, #0]
    66a4:	e0aa      	b.n	67fc <usb_isr+0x414>
    66a6:	bf00      	nop
    66a8:	40072080 	.word	0x40072080
    66ac:	1fff961f 	.word	0x1fff961f
    66b0:	1fff9589 	.word	0x1fff9589
    66b4:	1fff9622 	.word	0x1fff9622
    66b8:	40072090 	.word	0x40072090
    66bc:	1fff8000 	.word	0x1fff8000
    66c0:	1fff960c 	.word	0x1fff960c
    66c4:	004000c8 	.word	0x004000c8
    66c8:	1fff94fc 	.word	0x1fff94fc
    66cc:	1fff9620 	.word	0x1fff9620
    66d0:	1fff9617 	.word	0x1fff9617
    66d4:	0000b9fc 	.word	0x0000b9fc
    66d8:	0000b8d0 	.word	0x0000b8d0
    66dc:	1fff94f5 	.word	0x1fff94f5
    66e0:	1fff8e51 	.word	0x1fff8e51
    66e4:	1fff9630 	.word	0x1fff9630
    66e8:	1fff9500 	.word	0x1fff9500
    66ec:	1fff95ec 	.word	0x1fff95ec
    66f0:	1fffa656 	.word	0x1fffa656
    66f4:	1fff9520 	.word	0x1fff9520
    66f8:	1fff9616 	.word	0x1fff9616
    66fc:	0000b8ba 	.word	0x0000b8ba
    6700:	1001c830 	.word	0x1001c830
    6704:	00400088 	.word	0x00400088
    6708:	1fff9568 	.word	0x1fff9568
    670c:	1fff95cc 	.word	0x1fff95cc
		datalen = 2;
		data = reply_buffer;
		goto send;

	case 0x0082: // GET_STATUS (endpoint)
		if ( setup.wIndex > NUM_ENDPOINTS )
    6710:	88ab      	ldrh	r3, [r5, #4]
    6712:	2b08      	cmp	r3, #8
    6714:	d868      	bhi.n	67e8 <usb_isr+0x400>
		{
			// TODO: do we need to handle IN vs OUT here?
			endpoint0_stall();
			return;
		}
		reply_buffer[0] = 0;
    6716:	4c9d      	ldr	r4, [pc, #628]	; (698c <usb_isr+0x5a4>)
		reply_buffer[1] = 0;
		if ( *(uint8_t *)(&USB0_ENDPT0 + setup.wIndex * 4) & 0x02 )
    6718:	009a      	lsls	r2, r3, #2
    671a:	4b9d      	ldr	r3, [pc, #628]	; (6990 <usb_isr+0x5a8>)
		{
			// TODO: do we need to handle IN vs OUT here?
			endpoint0_stall();
			return;
		}
		reply_buffer[0] = 0;
    671c:	7021      	strb	r1, [r4, #0]
		reply_buffer[1] = 0;
    671e:	7061      	strb	r1, [r4, #1]
		if ( *(uint8_t *)(&USB0_ENDPT0 + setup.wIndex * 4) & 0x02 )
    6720:	5c9b      	ldrb	r3, [r3, r2]
    6722:	079a      	lsls	r2, r3, #30
    6724:	d569      	bpl.n	67fa <usb_isr+0x412>
			reply_buffer[0] = 1;
    6726:	7026      	strb	r6, [r4, #0]
    6728:	e067      	b.n	67fa <usb_isr+0x412>
		warn_print("CLEAR_FEATURE - Device/Interface");
		endpoint0_stall();
		return;

	case 0x0102: // CLEAR_FEATURE (endpoint)
		i = setup.wIndex & 0x7F;
    672a:	88ab      	ldrh	r3, [r5, #4]
    672c:	f003 027f 	and.w	r2, r3, #127	; 0x7f
		if ( i > NUM_ENDPOINTS || setup.wValue != 0 )
    6730:	2a08      	cmp	r2, #8
    6732:	dc59      	bgt.n	67e8 <usb_isr+0x400>
    6734:	8869      	ldrh	r1, [r5, #2]
    6736:	2900      	cmp	r1, #0
    6738:	d156      	bne.n	67e8 <usb_isr+0x400>
		{
			endpoint0_stall();
			return;
		}
		(*(uint8_t *)(&USB0_ENDPT0 + setup.wIndex * 4)) &= ~0x02;
    673a:	009a      	lsls	r2, r3, #2
    673c:	4b94      	ldr	r3, [pc, #592]	; (6990 <usb_isr+0x5a8>)
    673e:	4413      	add	r3, r2
    6740:	781a      	ldrb	r2, [r3, #0]
    6742:	f022 0202 	bic.w	r2, r2, #2
    6746:	e04d      	b.n	67e4 <usb_isr+0x3fc>
		goto send;

	case 0x0300: // SET_FEATURE (device)
	case 0x0301: // SET_FEATURE (interface)
		// TODO: Currently ignoring, perhaps useful? -HaaTa
		warn_print("SET_FEATURE - Device/Interface");
    6748:	4892      	ldr	r0, [pc, #584]	; (6994 <usb_isr+0x5ac>)
    674a:	e02f      	b.n	67ac <usb_isr+0x3c4>
		endpoint0_stall();
		return;

	case 0x0302: // SET_FEATURE (endpoint)
		i = setup.wIndex & 0x7F;
    674c:	88ab      	ldrh	r3, [r5, #4]
    674e:	f003 027f 	and.w	r2, r3, #127	; 0x7f
		if ( i > NUM_ENDPOINTS || setup.wValue != 0 )
    6752:	2a08      	cmp	r2, #8
    6754:	dc48      	bgt.n	67e8 <usb_isr+0x400>
    6756:	8869      	ldrh	r1, [r5, #2]
    6758:	2900      	cmp	r1, #0
    675a:	d145      	bne.n	67e8 <usb_isr+0x400>
		{
			// TODO: do we need to handle IN vs OUT here?
			endpoint0_stall();
			return;
		}
		(*(uint8_t *)(&USB0_ENDPT0 + setup.wIndex * 4)) |= 0x02;
    675c:	009a      	lsls	r2, r3, #2
    675e:	4b8c      	ldr	r3, [pc, #560]	; (6990 <usb_isr+0x5a8>)
    6760:	4413      	add	r3, r2
    6762:	781a      	ldrb	r2, [r3, #0]
    6764:	f042 0202 	orr.w	r2, r2, #2
    6768:	e03c      	b.n	67e4 <usb_isr+0x3fc>
		#endif
		for ( list = usb_descriptor_list; 1; list++ )
		{
			if ( list->addr == NULL )
				break;
			if ( setup.wValue == list->wValue && setup.wIndex == list->wIndex )
    676a:	f833 6c0c 	ldrh.w	r6, [r3, #-12]
    676e:	4296      	cmp	r6, r2
    6770:	d007      	beq.n	6782 <usb_isr+0x39a>
    6772:	330c      	adds	r3, #12
		printHex( setup.wValue );
		print( NL );
		#endif
		for ( list = usb_descriptor_list; 1; list++ )
		{
			if ( list->addr == NULL )
    6774:	f853 4c08 	ldr.w	r4, [r3, #-8]
    6778:	f1a3 000c 	sub.w	r0, r3, #12
    677c:	2c00      	cmp	r4, #0
    677e:	d1f4      	bne.n	676a <usb_isr+0x382>
    6780:	e032      	b.n	67e8 <usb_isr+0x400>
				break;
			if ( setup.wValue == list->wValue && setup.wIndex == list->wIndex )
    6782:	f833 6c0a 	ldrh.w	r6, [r3, #-10]
    6786:	428e      	cmp	r6, r1
    6788:	d1f3      	bne.n	6772 <usb_isr+0x38a>
			{
				data = list->addr;
				if ( (setup.wValue >> 8) == 3 )
    678a:	0a12      	lsrs	r2, r2, #8
    678c:	2a03      	cmp	r2, #3
				{
					// for string descriptors, use the descriptor's
					// length field, allowing runtime configured
					// length.
					datalen = *(list->addr);
    678e:	bf0c      	ite	eq
    6790:	7821      	ldrbeq	r1, [r4, #0]
				}
				else
				{
					datalen = list->length;
    6792:	8901      	ldrhne	r1, [r0, #8]
    6794:	e032      	b.n	67fc <usb_isr+0x414>
		//serial_print("set coding, waiting...\n");
		return;

	case 0x0921: // HID SET_REPORT
		// Interface
		switch ( setup.wIndex & 0xFF )
    6796:	792b      	ldrb	r3, [r5, #4]
    6798:	2b01      	cmp	r3, #1
    679a:	d952      	bls.n	6842 <usb_isr+0x45a>
			break;
		// NKRO Keyboard Interface
		case NKRO_KEYBOARD_INTERFACE:
			break;
		default:
			warn_msg("Unknown interface - ");
    679c:	487e      	ldr	r0, [pc, #504]	; (6998 <usb_isr+0x5b0>)
    679e:	f001 f831 	bl	7804 <_print>
			printHex( setup.wIndex );
    67a2:	88a8      	ldrh	r0, [r5, #4]
    67a4:	4631      	mov	r1, r6
    67a6:	f001 f8b6 	bl	7916 <printHex_op>
			print( NL );
    67aa:	487c      	ldr	r0, [pc, #496]	; (699c <usb_isr+0x5b4>)
    67ac:	f001 f82a 	bl	7804 <_print>
    67b0:	e01a      	b.n	67e8 <usb_isr+0x400>
		// Search through descriptors returning necessary info
		for ( list = usb_descriptor_list; 1; list++ )
		{
			if ( list->addr == NULL )
				break;
			if ( list->wValue != 0x2200 )
    67b2:	f833 0c0c 	ldrh.w	r0, [r3, #-12]
    67b6:	f5b0 5f08 	cmp.w	r0, #8704	; 0x2200
    67ba:	d005      	beq.n	67c8 <usb_isr+0x3e0>
    67bc:	330c      	adds	r3, #12
		print(NL);
		#endif
		// Search through descriptors returning necessary info
		for ( list = usb_descriptor_list; 1; list++ )
		{
			if ( list->addr == NULL )
    67be:	f853 4c08 	ldr.w	r4, [r3, #-8]
    67c2:	2c00      	cmp	r4, #0
    67c4:	d1f5      	bne.n	67b2 <usb_isr+0x3ca>
    67c6:	e00f      	b.n	67e8 <usb_isr+0x400>
				break;
			if ( list->wValue != 0x2200 )
				continue;
			if ( setup.wIndex == list->wIndex )
    67c8:	f833 0c0a 	ldrh.w	r0, [r3, #-10]
    67cc:	4290      	cmp	r0, r2
    67ce:	d1f5      	bne.n	67bc <usb_isr+0x3d4>
			{
				data = list->addr;
				datalen = list->length;
    67d0:	f833 1c04 	ldrh.w	r1, [r3, #-4]
    67d4:	e012      	b.n	67fc <usb_isr+0x414>
		#ifdef UART_DEBUG
		print("SET_IDLE - ");
		printHex( setup.wValue );
		print(NL);
		#endif
		USBKeys_Idle_Config = (setup.wValue >> 8);
    67d6:	886a      	ldrh	r2, [r5, #2]
    67d8:	4b71      	ldr	r3, [pc, #452]	; (69a0 <usb_isr+0x5b8>)
    67da:	0a12      	lsrs	r2, r2, #8
    67dc:	701a      	strb	r2, [r3, #0]
		USBKeys_Idle_Count = 0;
    67de:	4b71      	ldr	r3, [pc, #452]	; (69a4 <usb_isr+0x5bc>)
    67e0:	7019      	strb	r1, [r3, #0]
    67e2:	e008      	b.n	67f6 <usb_isr+0x40e>
		printHex( setup.wValue );
		print(" - ");
		printHex( setup.wValue & 0xFF );
		print(NL);
		#endif
		USBKeys_Protocol = setup.wValue & 0xFF; // 0 - Boot Mode, 1 - NKRO Mode
    67e4:	701a      	strb	r2, [r3, #0]
    67e6:	e006      	b.n	67f6 <usb_isr+0x40e>
static void endpoint0_stall()
{
	#ifdef UART_DEBUG_UNKNOWN
	print("STALL" NL );
	#endif
	USB0_ENDPT0 = USB_ENDPT_EPSTALL | USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    67e8:	4b69      	ldr	r3, [pc, #420]	; (6990 <usb_isr+0x5a8>)
    67ea:	220f      	movs	r2, #15
    67ec:	701a      	strb	r2, [r3, #0]
    67ee:	e028      	b.n	6842 <usb_isr+0x45a>
		//serial_print("set control line state\n");
		goto send;

	case 0x21A1: // CDC_GET_LINE_CODING
		data = (uint8_t*)usb_cdc_line_coding;
		datalen = sizeof( usb_cdc_line_coding );
    67f0:	2107      	movs	r1, #7
		usb_cdc_line_rtsdtr = setup.wValue;
		//serial_print("set control line state\n");
		goto send;

	case 0x21A1: // CDC_GET_LINE_CODING
		data = (uint8_t*)usb_cdc_line_coding;
    67f2:	4c6d      	ldr	r4, [pc, #436]	; (69a8 <usb_isr+0x5c0>)
    67f4:	e002      	b.n	67fc <usb_isr+0x414>
	ep0_tx_bdt_bank ^= 1;
}

static void usb_setup()
{
	const uint8_t *data = NULL;
    67f6:	460c      	mov	r4, r1
    67f8:	e000      	b.n	67fc <usb_isr+0x414>
		reply_buffer[0] = 0;
		reply_buffer[1] = 0;
		if ( *(uint8_t *)(&USB0_ENDPT0 + setup.wIndex * 4) & 0x02 )
			reply_buffer[0] = 1;
		data = reply_buffer;
		datalen = 2;
    67fa:	2102      	movs	r1, #2
	print(",");
	printHex( datalen );
	print( NL );
	#endif

	if ( datalen > setup.wLength )
    67fc:	88ee      	ldrh	r6, [r5, #6]
    67fe:	42b1      	cmp	r1, r6
    6800:	bf38      	it	cc
    6802:	460e      	movcc	r6, r1
    6804:	2e40      	cmp	r6, #64	; 0x40
    6806:	bf34      	ite	cc
    6808:	4635      	movcc	r5, r6
    680a:	2540      	movcs	r5, #64	; 0x40

	size = datalen;
	if ( size > EP0_SIZE )
		size = EP0_SIZE;

	endpoint0_transmit(data, size);
    680c:	4620      	mov	r0, r4
    680e:	4629      	mov	r1, r5
    6810:	f7ff fd0a 	bl	6228 <endpoint0_transmit>
	data += size;
	datalen -= size;

	// See if transmit has finished
	if ( datalen == 0 && size < EP0_SIZE )
    6814:	1b76      	subs	r6, r6, r5
	size = datalen;
	if ( size > EP0_SIZE )
		size = EP0_SIZE;

	endpoint0_transmit(data, size);
	data += size;
    6816:	442c      	add	r4, r5
	datalen -= size;

	// See if transmit has finished
	if ( datalen == 0 && size < EP0_SIZE )
    6818:	d103      	bne.n	6822 <usb_isr+0x43a>
    681a:	2d40      	cmp	r5, #64	; 0x40
    681c:	d111      	bne.n	6842 <usb_isr+0x45a>
    681e:	4635      	mov	r5, r6
    6820:	e003      	b.n	682a <usb_isr+0x442>
    6822:	2e40      	cmp	r6, #64	; 0x40
    6824:	bf34      	ite	cc
    6826:	4635      	movcc	r5, r6
    6828:	2540      	movcs	r5, #64	; 0x40
		return;

	size = datalen;
	if ( size > EP0_SIZE )
		size = EP0_SIZE;
	endpoint0_transmit(data, size);
    682a:	4620      	mov	r0, r4
    682c:	4629      	mov	r1, r5
    682e:	f7ff fcfb 	bl	6228 <endpoint0_transmit>
	data += size;
	datalen -= size;

	// See if transmit has finished
	if ( datalen == 0 && size < EP0_SIZE )
    6832:	1b76      	subs	r6, r6, r5

	size = datalen;
	if ( size > EP0_SIZE )
		size = EP0_SIZE;
	endpoint0_transmit(data, size);
	data += size;
    6834:	442c      	add	r4, r5
	datalen -= size;

	// See if transmit has finished
	if ( datalen == 0 && size < EP0_SIZE )
    6836:	d101      	bne.n	683c <usb_isr+0x454>
    6838:	2d40      	cmp	r5, #64	; 0x40
    683a:	d102      	bne.n	6842 <usb_isr+0x45a>
		return;

	// Save rest of transfer for later? XXX
	ep0_tx_ptr = data;
	ep0_tx_len = datalen;
    683c:	4b5b      	ldr	r3, [pc, #364]	; (69ac <usb_isr+0x5c4>)
	// See if transmit has finished
	if ( datalen == 0 && size < EP0_SIZE )
		return;

	// Save rest of transfer for later? XXX
	ep0_tx_ptr = data;
    683e:	603c      	str	r4, [r7, #0]
	ep0_tx_len = datalen;
    6840:	801e      	strh	r6, [r3, #0]
		print(NL);
		#endif
		// actually "do" the setup request
		usb_setup();
		// unfreeze the USB, now that we're ready
		USB0_CTL = USB_CTL_USBENSOFEN; // clear TXSUSPENDTOKENBUSY bit
    6842:	2201      	movs	r2, #1
    6844:	4b5a      	ldr	r3, [pc, #360]	; (69b0 <usb_isr+0x5c8>)
    6846:	e058      	b.n	68fa <usb_isr+0x512>
		printHex32(setup.word2);
		print(NL);
		#endif

		// CDC Interface
		if ( setup.wRequestAndType == 0x2021 /*CDC_SET_LINE_CODING*/ )
    6848:	4d5a      	ldr	r5, [pc, #360]	; (69b4 <usb_isr+0x5cc>)
    684a:	882b      	ldrh	r3, [r5, #0]
    684c:	f242 0121 	movw	r1, #8225	; 0x2021
    6850:	428b      	cmp	r3, r1
    6852:	d10e      	bne.n	6872 <usb_isr+0x48a>
    6854:	2300      	movs	r3, #0
			uint8_t *dst = (uint8_t *)usb_cdc_line_coding;
			//serial_print("set line coding ");
			for ( i = 0; i < 7; i++ )
			{
				//serial_phex(*buf);
				*dst++ = *buf++;
    6856:	5cd0      	ldrb	r0, [r2, r3]
    6858:	4953      	ldr	r1, [pc, #332]	; (69a8 <usb_isr+0x5c0>)
    685a:	5458      	strb	r0, [r3, r1]
		if ( setup.wRequestAndType == 0x2021 /*CDC_SET_LINE_CODING*/ )
		{
			int i;
			uint8_t *dst = (uint8_t *)usb_cdc_line_coding;
			//serial_print("set line coding ");
			for ( i = 0; i < 7; i++ )
    685c:	3301      	adds	r3, #1
    685e:	2b07      	cmp	r3, #7
    6860:	d1f9      	bne.n	6856 <usb_isr+0x46e>
				//serial_phex(*buf);
				*dst++ = *buf++;
			}
			//serial_phex32(usb_cdc_line_coding[0]);
			//serial_print("\n");
			if ( usb_cdc_line_coding[0] == 134 )
    6862:	780b      	ldrb	r3, [r1, #0]
    6864:	2b86      	cmp	r3, #134	; 0x86
    6866:	d102      	bne.n	686e <usb_isr+0x486>
				usb_reboot_timer = 15;
    6868:	4b53      	ldr	r3, [pc, #332]	; (69b8 <usb_isr+0x5d0>)
    686a:	220f      	movs	r2, #15
    686c:	701a      	strb	r2, [r3, #0]
			endpoint0_transmit( NULL, 0 );
    686e:	2000      	movs	r0, #0
    6870:	e010      	b.n	6894 <usb_isr+0x4ac>
		}

		// Keyboard SET_REPORT
		if ( setup.wRequestAndType == 0x921 && setup.wValue & 0x200 )
    6872:	f640 1121 	movw	r1, #2337	; 0x921
    6876:	428b      	cmp	r3, r1
    6878:	d11a      	bne.n	68b0 <usb_isr+0x4c8>
    687a:	886b      	ldrh	r3, [r5, #2]
    687c:	059b      	lsls	r3, r3, #22
    687e:	d517      	bpl.n	68b0 <usb_isr+0x4c8>
		{
			// Interface
			switch ( setup.wIndex & 0xFF )
    6880:	7928      	ldrb	r0, [r5, #4]
    6882:	b120      	cbz	r0, 688e <usb_isr+0x4a6>
    6884:	2801      	cmp	r0, #1
    6886:	d109      	bne.n	689c <usb_isr+0x4b4>
				endpoint0_transmit( NULL, 0 );
				break;
			// NKRO Keyboard Interface
			case NKRO_KEYBOARD_INTERFACE:
				// Only use 2nd byte, first byte is the report id
				USBKeys_LEDs = buf[1];
    6888:	7852      	ldrb	r2, [r2, #1]
    688a:	4b4c      	ldr	r3, [pc, #304]	; (69bc <usb_isr+0x5d4>)
    688c:	e7ee      	b.n	686c <usb_isr+0x484>
			// Interface
			switch ( setup.wIndex & 0xFF )
			{
			// Keyboard Interface
			case KEYBOARD_INTERFACE:
				USBKeys_LEDs = buf[0];
    688e:	7812      	ldrb	r2, [r2, #0]
    6890:	4b4a      	ldr	r3, [pc, #296]	; (69bc <usb_isr+0x5d4>)
    6892:	701a      	strb	r2, [r3, #0]
				endpoint0_transmit( NULL, 0 );
    6894:	4601      	mov	r1, r0
    6896:	f7ff fcc7 	bl	6228 <endpoint0_transmit>
    689a:	e009      	b.n	68b0 <usb_isr+0x4c8>
				// Only use 2nd byte, first byte is the report id
				USBKeys_LEDs = buf[1];
				endpoint0_transmit( NULL, 0 );
				break;
			default:
				warn_msg("Unknown interface - ");
    689c:	483e      	ldr	r0, [pc, #248]	; (6998 <usb_isr+0x5b0>)
    689e:	f000 ffb1 	bl	7804 <_print>
				printHex( setup.wIndex );
    68a2:	88a8      	ldrh	r0, [r5, #4]
    68a4:	2101      	movs	r1, #1
    68a6:	f001 f836 	bl	7916 <printHex_op>
				print( NL );
    68aa:	483c      	ldr	r0, [pc, #240]	; (699c <usb_isr+0x5b4>)
    68ac:	f000 ffaa 	bl	7804 <_print>
			print( NL );
			#endif
		}

		// give the buffer back
		b->desc = BDT_DESC( EP0_SIZE, DATA1 );
    68b0:	4b43      	ldr	r3, [pc, #268]	; (69c0 <usb_isr+0x5d8>)
    68b2:	f844 3037 	str.w	r3, [r4, r7, lsl #3]
    68b6:	e021      	b.n	68fc <usb_isr+0x514>
		printHex(stat);
		print(NL);
		#endif

		// send remaining data, if any...
		data = ep0_tx_ptr;
    68b8:	4e42      	ldr	r6, [pc, #264]	; (69c4 <usb_isr+0x5dc>)
    68ba:	6835      	ldr	r5, [r6, #0]
		if ( data )
    68bc:	b1a5      	cbz	r5, 68e8 <usb_isr+0x500>
		{
			size = ep0_tx_len;
    68be:	4f3b      	ldr	r7, [pc, #236]	; (69ac <usb_isr+0x5c4>)
    68c0:	f8b7 8000 	ldrh.w	r8, [r7]
    68c4:	f1b8 0f40 	cmp.w	r8, #64	; 0x40
    68c8:	bf34      	ite	cc
    68ca:	4644      	movcc	r4, r8
    68cc:	2440      	movcs	r4, #64	; 0x40
			if (size > EP0_SIZE) size = EP0_SIZE;
			endpoint0_transmit(data, size);
    68ce:	4628      	mov	r0, r5
    68d0:	4621      	mov	r1, r4
    68d2:	f7ff fca9 	bl	6228 <endpoint0_transmit>
			data += size;
			ep0_tx_len -= size;
    68d6:	ebc4 0308 	rsb	r3, r4, r8
    68da:	b29b      	uxth	r3, r3
    68dc:	803b      	strh	r3, [r7, #0]
			ep0_tx_ptr = (ep0_tx_len > 0 || size == EP0_SIZE) ? data : NULL;
    68de:	b90b      	cbnz	r3, 68e4 <usb_isr+0x4fc>
    68e0:	2c40      	cmp	r4, #64	; 0x40
    68e2:	d100      	bne.n	68e6 <usb_isr+0x4fe>
		if ( data )
		{
			size = ep0_tx_len;
			if (size > EP0_SIZE) size = EP0_SIZE;
			endpoint0_transmit(data, size);
			data += size;
    68e4:	192b      	adds	r3, r5, r4
			ep0_tx_len -= size;
			ep0_tx_ptr = (ep0_tx_len > 0 || size == EP0_SIZE) ? data : NULL;
    68e6:	6033      	str	r3, [r6, #0]
		}

		if ( setup.bRequest == 5 && setup.bmRequestType == 0 )
    68e8:	4b32      	ldr	r3, [pc, #200]	; (69b4 <usb_isr+0x5cc>)
    68ea:	881a      	ldrh	r2, [r3, #0]
    68ec:	f5b2 6fa0 	cmp.w	r2, #1280	; 0x500
    68f0:	d104      	bne.n	68fc <usb_isr+0x514>
		{
			setup.bRequest = 0;
    68f2:	2200      	movs	r2, #0
    68f4:	705a      	strb	r2, [r3, #1]
			#ifdef UART_DEBUG
			print("set address: ");
			printHex(setup.wValue);
			print(NL);
			#endif
			USB0_ADDR = setup.wValue;
    68f6:	789a      	ldrb	r2, [r3, #2]
    68f8:	4b33      	ldr	r3, [pc, #204]	; (69c8 <usb_isr+0x5e0>)
    68fa:	701a      	strb	r2, [r3, #0]
		printHex(pid);
		print(NL);
		#endif
		break;
	}
	USB0_CTL = USB_CTL_USBENSOFEN; // clear TXSUSPENDTOKENBUSY bit
    68fc:	2201      	movs	r2, #1
    68fe:	4b2c      	ldr	r3, [pc, #176]	; (69b0 <usb_isr+0x5c8>)
    6900:	e091      	b.n	6a26 <usb_isr+0x63e>
		{
			usb_control( stat );
		}
		else
		{
			bdt_t *b = stat2bufferdescriptor(stat);
    6902:	eb04 06c7 	add.w	r6, r4, r7, lsl #3
			serial_print(((uint32_t)b & 8) ? ", odd" : ", even");
			serial_print(", count:");
			serial_phex(b->desc >> 16);
			serial_print("\n");
#endif
			endpoint--;     // endpoint is index to zero-based arrays
    6906:	3d01      	subs	r5, #1
			usb_control( stat );
		}
		else
		{
			bdt_t *b = stat2bufferdescriptor(stat);
			usb_packet_t *packet = (usb_packet_t *)((uint8_t *)(b->addr) - 8);
    6908:	6873      	ldr	r3, [r6, #4]
			serial_phex(b->desc >> 16);
			serial_print("\n");
#endif
			endpoint--;     // endpoint is index to zero-based arrays

			if ( stat & 0x08 )
    690a:	f002 0208 	and.w	r2, r2, #8
			usb_control( stat );
		}
		else
		{
			bdt_t *b = stat2bufferdescriptor(stat);
			usb_packet_t *packet = (usb_packet_t *)((uint8_t *)(b->addr) - 8);
    690e:	f1a3 0008 	sub.w	r0, r3, #8
			serial_print(((uint32_t)b & 8) ? ", odd" : ", even");
			serial_print(", count:");
			serial_phex(b->desc >> 16);
			serial_print("\n");
#endif
			endpoint--;     // endpoint is index to zero-based arrays
    6912:	b2ed      	uxtb	r5, r5

			if ( stat & 0x08 )
    6914:	f002 01ff 	and.w	r1, r2, #255	; 0xff
    6918:	2a00      	cmp	r2, #0
    691a:	d05b      	beq.n	69d4 <usb_isr+0x5ec>
			{ // transmit
				usb_free( packet );
    691c:	f000 faba 	bl	6e94 <usb_free>
				packet = tx_first[ endpoint ];
    6920:	492a      	ldr	r1, [pc, #168]	; (69cc <usb_isr+0x5e4>)
    6922:	4b2b      	ldr	r3, [pc, #172]	; (69d0 <usb_isr+0x5e8>)
    6924:	f851 2025 	ldr.w	r2, [r1, r5, lsl #2]
				if ( packet )
    6928:	b1ea      	cbz	r2, 6966 <usb_isr+0x57e>
				{
					//serial_print("tx packet\n");
					tx_first[endpoint] = packet->next;
    692a:	6850      	ldr	r0, [r2, #4]
    692c:	f841 0025 	str.w	r0, [r1, r5, lsl #2]
					b->addr = packet->buf;
    6930:	f102 0108 	add.w	r1, r2, #8
    6934:	6071      	str	r1, [r6, #4]
					switch ( tx_state[ endpoint ] )
    6936:	5d59      	ldrb	r1, [r3, r5]
    6938:	2903      	cmp	r1, #3
    693a:	d80b      	bhi.n	6954 <usb_isr+0x56c>
    693c:	e8df f001 	tbb	[pc, r1]
    6940:	08060402 	.word	0x08060402
					{
					case TX_STATE_BOTH_FREE_EVEN_FIRST:
						tx_state[ endpoint ] = TX_STATE_ODD_FREE;
    6944:	2103      	movs	r1, #3
    6946:	e004      	b.n	6952 <usb_isr+0x56a>
						break;
					case TX_STATE_BOTH_FREE_ODD_FIRST:
						tx_state[ endpoint ] = TX_STATE_EVEN_FREE;
    6948:	2102      	movs	r1, #2
    694a:	e002      	b.n	6952 <usb_isr+0x56a>
						break;
					case TX_STATE_EVEN_FREE:
						tx_state[ endpoint ] = TX_STATE_NONE_FREE_ODD_FIRST;
    694c:	2105      	movs	r1, #5
    694e:	e000      	b.n	6952 <usb_isr+0x56a>
						break;
					case TX_STATE_ODD_FREE:
						tx_state[ endpoint ] = TX_STATE_NONE_FREE_EVEN_FIRST;
    6950:	2104      	movs	r1, #4
    6952:	5559      	strb	r1, [r3, r5]
						break;
					default:
						break;
					}
					b->desc = BDT_DESC( packet->len, ((uint32_t)b & 8) ? DATA1 : DATA0 );
    6954:	f016 0f08 	tst.w	r6, #8
    6958:	8812      	ldrh	r2, [r2, #0]
    695a:	bf0c      	ite	eq
    695c:	2388      	moveq	r3, #136	; 0x88
    695e:	23c8      	movne	r3, #200	; 0xc8
    6960:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
    6964:	e067      	b.n	6a36 <usb_isr+0x64e>
				} else {
					//serial_print("tx no packet\n");
					switch ( tx_state[ endpoint ] )
    6966:	5d5a      	ldrb	r2, [r3, r5]
    6968:	2a03      	cmp	r2, #3
    696a:	d807      	bhi.n	697c <usb_isr+0x594>
    696c:	e8df f002 	tbb	[pc, r2]
    6970:	04026565 	.word	0x04026565
					{
					case TX_STATE_BOTH_FREE_EVEN_FIRST:
					case TX_STATE_BOTH_FREE_ODD_FIRST:
						break;
					case TX_STATE_EVEN_FREE:
						tx_state[ endpoint ] = TX_STATE_BOTH_FREE_EVEN_FIRST;
    6974:	2200      	movs	r2, #0
    6976:	e006      	b.n	6986 <usb_isr+0x59e>
						break;
					case TX_STATE_ODD_FREE:
						tx_state[ endpoint ] = TX_STATE_BOTH_FREE_ODD_FIRST;
    6978:	2201      	movs	r2, #1
    697a:	e004      	b.n	6986 <usb_isr+0x59e>
						break;
					default:
						tx_state[ endpoint ] = ((uint32_t)b & 8)
    697c:	f016 0f08 	tst.w	r6, #8
    6980:	bf0c      	ite	eq
    6982:	2202      	moveq	r2, #2
    6984:	2203      	movne	r2, #3
    6986:	555a      	strb	r2, [r3, r5]
							? TX_STATE_ODD_FREE
							: TX_STATE_EVEN_FREE;
						break;
    6988:	e057      	b.n	6a3a <usb_isr+0x652>
    698a:	bf00      	nop
    698c:	1fff9617 	.word	0x1fff9617
    6990:	400720c0 	.word	0x400720c0
    6994:	0000ba34 	.word	0x0000ba34
    6998:	0000ba6a 	.word	0x0000ba6a
    699c:	0000bafb 	.word	0x0000bafb
    69a0:	1fff8e50 	.word	0x1fff8e50
    69a4:	1fff94f1 	.word	0x1fff94f1
    69a8:	1fff929c 	.word	0x1fff929c
    69ac:	1fff9614 	.word	0x1fff9614
    69b0:	40072094 	.word	0x40072094
    69b4:	1fff960c 	.word	0x1fff960c
    69b8:	1fff9589 	.word	0x1fff9589
    69bc:	1fff94ee 	.word	0x1fff94ee
    69c0:	004000c8 	.word	0x004000c8
    69c4:	1fff94fc 	.word	0x1fff94fc
    69c8:	40072098 	.word	0x40072098
    69cc:	1fff95cc 	.word	0x1fff95cc
    69d0:	1fff9520 	.word	0x1fff9520
					}
				}
			}
			else
			{ // receive
				packet->len = b->desc >> 16;
    69d4:	f854 2037 	ldr.w	r2, [r4, r7, lsl #3]
    69d8:	0c12      	lsrs	r2, r2, #16
    69da:	f823 2c08 	strh.w	r2, [r3, #-8]
				if ( packet->len > 0 )
    69de:	b322      	cbz	r2, 6a2a <usb_isr+0x642>
				{
					packet->index = 0;
    69e0:	f823 1c06 	strh.w	r1, [r3, #-6]
					packet->next = NULL;
    69e4:	f843 1c04 	str.w	r1, [r3, #-4]
					if ( rx_first[ endpoint ] == NULL )
    69e8:	4933      	ldr	r1, [pc, #204]	; (6ab8 <usb_isr+0x6d0>)
    69ea:	f8df e108 	ldr.w	lr, [pc, #264]	; 6af4 <usb_isr+0x70c>
    69ee:	f851 3025 	ldr.w	r3, [r1, r5, lsl #2]
    69f2:	b913      	cbnz	r3, 69fa <usb_isr+0x612>
						//serial_print("rx 1st, epidx=");
						//serial_phex(endpoint);
						//serial_print(", packet=");
						//serial_phex32((uint32_t)packet);
						//serial_print("\n");
						rx_first[ endpoint ] = packet;
    69f4:	f841 0025 	str.w	r0, [r1, r5, lsl #2]
    69f8:	e002      	b.n	6a00 <usb_isr+0x618>
						//serial_print("rx Nth, epidx=");
						//serial_phex(endpoint);
						//serial_print(", packet=");
						//serial_phex32((uint32_t)packet);
						//serial_print("\n");
						rx_last[ endpoint ]->next = packet;
    69fa:	f85e 1025 	ldr.w	r1, [lr, r5, lsl #2]
    69fe:	6048      	str	r0, [r1, #4]
					}
					rx_last[ endpoint ] = packet;
					usb_rx_byte_count_data[ endpoint ] += packet->len;
    6a00:	4b2e      	ldr	r3, [pc, #184]	; (6abc <usb_isr+0x6d4>)
						//serial_print(", packet=");
						//serial_phex32((uint32_t)packet);
						//serial_print("\n");
						rx_last[ endpoint ]->next = packet;
					}
					rx_last[ endpoint ] = packet;
    6a02:	f84e 0025 	str.w	r0, [lr, r5, lsl #2]
					usb_rx_byte_count_data[ endpoint ] += packet->len;
    6a06:	f833 1015 	ldrh.w	r1, [r3, r5, lsl #1]
    6a0a:	440a      	add	r2, r1
    6a0c:	f823 2015 	strh.w	r2, [r3, r5, lsl #1]
					// TODO: implement a per-endpoint maximum # of allocated packets
					// so a flood of incoming data on 1 endpoint doesn't starve
					// the others if the user isn't reading it regularly
					packet = usb_malloc();
    6a10:	f000 fa22 	bl	6e58 <usb_malloc>
					if ( packet )
    6a14:	b110      	cbz	r0, 6a1c <usb_isr+0x634>
					{
						b->addr = packet->buf;
    6a16:	3008      	adds	r0, #8
    6a18:	6070      	str	r0, [r6, #4]
    6a1a:	e006      	b.n	6a2a <usb_isr+0x642>
					{
						//serial_print("starving ");
						//serial_phex(endpoint + 1);
						//serial_print(((uint32_t)b & 8) ? ",odd\n" : ",even\n");
						b->desc = 0;
						usb_rx_memory_needed++;
    6a1c:	4b28      	ldr	r3, [pc, #160]	; (6ac0 <usb_isr+0x6d8>)
					else
					{
						//serial_print("starving ");
						//serial_phex(endpoint + 1);
						//serial_print(((uint32_t)b & 8) ? ",odd\n" : ",even\n");
						b->desc = 0;
    6a1e:	f844 0037 	str.w	r0, [r4, r7, lsl #3]
						usb_rx_memory_needed++;
    6a22:	781a      	ldrb	r2, [r3, #0]
    6a24:	3201      	adds	r2, #1
    6a26:	701a      	strb	r2, [r3, #0]
    6a28:	e007      	b.n	6a3a <usb_isr+0x652>
					}
				}
				else
				{
					b->desc = BDT_DESC( 64, ((uint32_t)b & 8) ? DATA1 : DATA0 );
    6a2a:	4b26      	ldr	r3, [pc, #152]	; (6ac4 <usb_isr+0x6dc>)
    6a2c:	4a26      	ldr	r2, [pc, #152]	; (6ac8 <usb_isr+0x6e0>)
    6a2e:	f016 0f08 	tst.w	r6, #8
    6a32:	bf08      	it	eq
    6a34:	4613      	moveq	r3, r2
    6a36:	f844 3037 	str.w	r3, [r4, r7, lsl #3]




		}
		USB0_ISTAT = USB_ISTAT_TOKDNE;
    6a3a:	4b24      	ldr	r3, [pc, #144]	; (6acc <usb_isr+0x6e4>)
    6a3c:	2208      	movs	r2, #8
    6a3e:	701a      	strb	r2, [r3, #0]
		goto restart;
    6a40:	e4d4      	b.n	63ec <usb_isr+0x4>
	}


	if ( status & USB_ISTAT_USBRST /* 01 */ )
    6a42:	07e6      	lsls	r6, r4, #31
    6a44:	d520      	bpl.n	6a88 <usb_isr+0x6a0>
	{
		//serial_print("reset\n");

		// initialize BDT toggle bits
		USB0_CTL = USB_CTL_ODDRST;
    6a46:	4922      	ldr	r1, [pc, #136]	; (6ad0 <usb_isr+0x6e8>)
		ep0_tx_bdt_bank = 0;

		// set up buffers to receive Setup and OUT packets
		table[index( 0, RX, EVEN ) ].desc = BDT_DESC( EP0_SIZE, 0 );
    6a48:	481f      	ldr	r0, [pc, #124]	; (6ac8 <usb_isr+0x6e0>)
		table[index( 0, RX, EVEN ) ].addr = ep0_rx0_buf;
    6a4a:	4c22      	ldr	r4, [pc, #136]	; (6ad4 <usb_isr+0x6ec>)
	if ( status & USB_ISTAT_USBRST /* 01 */ )
	{
		//serial_print("reset\n");

		// initialize BDT toggle bits
		USB0_CTL = USB_CTL_ODDRST;
    6a4c:	2302      	movs	r3, #2
    6a4e:	700b      	strb	r3, [r1, #0]
		ep0_tx_bdt_bank = 0;
    6a50:	4b21      	ldr	r3, [pc, #132]	; (6ad8 <usb_isr+0x6f0>)
    6a52:	701a      	strb	r2, [r3, #0]

		// set up buffers to receive Setup and OUT packets
		table[index( 0, RX, EVEN ) ].desc = BDT_DESC( EP0_SIZE, 0 );
    6a54:	4b21      	ldr	r3, [pc, #132]	; (6adc <usb_isr+0x6f4>)
    6a56:	6018      	str	r0, [r3, #0]
		table[index( 0, RX, EVEN ) ].addr = ep0_rx0_buf;
		table[index( 0, RX, ODD ) ].desc = BDT_DESC( EP0_SIZE, 0 );
    6a58:	6098      	str	r0, [r3, #8]
		table[index( 0, RX, ODD ) ].addr = ep0_rx1_buf;
    6a5a:	4821      	ldr	r0, [pc, #132]	; (6ae0 <usb_isr+0x6f8>)
		table[index( 0, TX, EVEN ) ].desc = 0;
    6a5c:	611a      	str	r2, [r3, #16]

		// set up buffers to receive Setup and OUT packets
		table[index( 0, RX, EVEN ) ].desc = BDT_DESC( EP0_SIZE, 0 );
		table[index( 0, RX, EVEN ) ].addr = ep0_rx0_buf;
		table[index( 0, RX, ODD ) ].desc = BDT_DESC( EP0_SIZE, 0 );
		table[index( 0, RX, ODD ) ].addr = ep0_rx1_buf;
    6a5e:	60d8      	str	r0, [r3, #12]
		table[index( 0, TX, EVEN ) ].desc = 0;
		table[index( 0, TX, ODD ) ].desc = 0;
    6a60:	619a      	str	r2, [r3, #24]
		USB0_CTL = USB_CTL_ODDRST;
		ep0_tx_bdt_bank = 0;

		// set up buffers to receive Setup and OUT packets
		table[index( 0, RX, EVEN ) ].desc = BDT_DESC( EP0_SIZE, 0 );
		table[index( 0, RX, EVEN ) ].addr = ep0_rx0_buf;
    6a62:	605c      	str	r4, [r3, #4]
		table[index( 0, RX, ODD ) ].addr = ep0_rx1_buf;
		table[index( 0, TX, EVEN ) ].desc = 0;
		table[index( 0, TX, ODD ) ].desc = 0;

		// activate endpoint 0
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    6a64:	4b1f      	ldr	r3, [pc, #124]	; (6ae4 <usb_isr+0x6fc>)
    6a66:	200d      	movs	r0, #13
    6a68:	7018      	strb	r0, [r3, #0]

		// clear all ending interrupts
		USB0_ERRSTAT = 0xFF;
    6a6a:	481f      	ldr	r0, [pc, #124]	; (6ae8 <usb_isr+0x700>)
    6a6c:	23ff      	movs	r3, #255	; 0xff
    6a6e:	7003      	strb	r3, [r0, #0]
		USB0_ISTAT = 0xFF;
    6a70:	f800 3c08 	strb.w	r3, [r0, #-8]

		// set the address to zero during enumeration
		USB0_ADDR = 0;
    6a74:	7402      	strb	r2, [r0, #16]

		// enable other interrupts
		USB0_ERREN = 0xFF;
    6a76:	4a1d      	ldr	r2, [pc, #116]	; (6aec <usb_isr+0x704>)
    6a78:	7013      	strb	r3, [r2, #0]
		USB0_INTEN = USB_INTEN_TOKDNEEN |
    6a7a:	4b1d      	ldr	r3, [pc, #116]	; (6af0 <usb_isr+0x708>)
    6a7c:	229f      	movs	r2, #159	; 0x9f
    6a7e:	701a      	strb	r2, [r3, #0]
			USB_INTEN_ERROREN |
			USB_INTEN_USBRSTEN |
			USB_INTEN_SLEEPEN;

		// is this necessary?
		USB0_CTL = USB_CTL_USBENSOFEN;
    6a80:	2301      	movs	r3, #1
    6a82:	700b      	strb	r3, [r1, #0]
		return;
    6a84:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	}


	if ( (status & USB_ISTAT_STALL /* 80 */ ) )
    6a88:	0625      	lsls	r5, r4, #24
    6a8a:	d505      	bpl.n	6a98 <usb_isr+0x6b0>
	{
		//serial_print("stall:\n");
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    6a8c:	4b15      	ldr	r3, [pc, #84]	; (6ae4 <usb_isr+0x6fc>)
    6a8e:	220d      	movs	r2, #13
    6a90:	701a      	strb	r2, [r3, #0]
		USB0_ISTAT = USB_ISTAT_STALL;
    6a92:	2280      	movs	r2, #128	; 0x80
    6a94:	f803 2c40 	strb.w	r2, [r3, #-64]
	}
	if ( (status & USB_ISTAT_ERROR /* 02 */ ) )
    6a98:	07a0      	lsls	r0, r4, #30
    6a9a:	d506      	bpl.n	6aaa <usb_isr+0x6c2>
	{
		uint8_t err = USB0_ERRSTAT;
    6a9c:	4b12      	ldr	r3, [pc, #72]	; (6ae8 <usb_isr+0x700>)
    6a9e:	781a      	ldrb	r2, [r3, #0]
    6aa0:	b2d2      	uxtb	r2, r2
		USB0_ERRSTAT = err;
    6aa2:	701a      	strb	r2, [r3, #0]
		//serial_print("err:");
		//serial_phex(err);
		//serial_print("\n");
		USB0_ISTAT = USB_ISTAT_ERROR;
    6aa4:	2202      	movs	r2, #2
    6aa6:	f803 2c08 	strb.w	r2, [r3, #-8]
	}

	if ( (status & USB_ISTAT_SLEEP /* 10 */ ) )
    6aaa:	06e1      	lsls	r1, r4, #27
    6aac:	d502      	bpl.n	6ab4 <usb_isr+0x6cc>
	{
		//serial_print("sleep\n");
		USB0_ISTAT = USB_ISTAT_SLEEP;
    6aae:	4b07      	ldr	r3, [pc, #28]	; (6acc <usb_isr+0x6e4>)
    6ab0:	2210      	movs	r2, #16
    6ab2:	701a      	strb	r2, [r3, #0]
    6ab4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    6ab8:	1fff9568 	.word	0x1fff9568
    6abc:	1fffa656 	.word	0x1fffa656
    6ac0:	1fff9616 	.word	0x1fff9616
    6ac4:	004000c8 	.word	0x004000c8
    6ac8:	00400088 	.word	0x00400088
    6acc:	40072080 	.word	0x40072080
    6ad0:	40072094 	.word	0x40072094
    6ad4:	1fff9528 	.word	0x1fff9528
    6ad8:	1fff9588 	.word	0x1fff9588
    6adc:	1fff8000 	.word	0x1fff8000
    6ae0:	1fff958c 	.word	0x1fff958c
    6ae4:	400720c0 	.word	0x400720c0
    6ae8:	40072088 	.word	0x40072088
    6aec:	4007208c 	.word	0x4007208c
    6af0:	40072084 	.word	0x40072084
    6af4:	1fff9500 	.word	0x1fff9500

00006af8 <usb_init>:
}



uint8_t usb_init()
{
    6af8:	2300      	movs	r3, #0
	#endif

	// Clear out endpoints table
	for ( int i = 0; i <= NUM_ENDPOINTS * 4; i++ )
	{
		table[i].desc = 0;
    6afa:	4a1e      	ldr	r2, [pc, #120]	; (6b74 <usb_init+0x7c>)
    6afc:	2100      	movs	r1, #0
    6afe:	5099      	str	r1, [r3, r2]
    6b00:	18d0      	adds	r0, r2, r3
    6b02:	3308      	adds	r3, #8
	#ifdef UART_DEBUG
	print("USB INIT"NL);
	#endif

	// Clear out endpoints table
	for ( int i = 0; i <= NUM_ENDPOINTS * 4; i++ )
    6b04:	f5b3 7f84 	cmp.w	r3, #264	; 0x108
	{
		table[i].desc = 0;
		table[i].addr = 0;
    6b08:	6041      	str	r1, [r0, #4]
	#ifdef UART_DEBUG
	print("USB INIT"NL);
	#endif

	// Clear out endpoints table
	for ( int i = 0; i <= NUM_ENDPOINTS * 4; i++ )
    6b0a:	d1f6      	bne.n	6afa <usb_init+0x2>
	// this basically follows the flowchart in the Kinetis
	// Quick Reference User Guide, Rev. 1, 03/2012, page 141

	// assume 48 MHz clock already running
	// SIM - enable clock
	SIM_SCGC4 |= SIM_SCGC4_USBOTG;
    6b0c:	4b1a      	ldr	r3, [pc, #104]	; (6b78 <usb_init+0x80>)
    6b0e:	6819      	ldr	r1, [r3, #0]
    6b10:	f441 2180 	orr.w	r1, r1, #262144	; 0x40000
    6b14:	6019      	str	r1, [r3, #0]

	// reset USB module
	USB0_USBTRC0 = USB_USBTRC_USBRESET;
    6b16:	4b19      	ldr	r3, [pc, #100]	; (6b7c <usb_init+0x84>)
    6b18:	2180      	movs	r1, #128	; 0x80
    6b1a:	7019      	strb	r1, [r3, #0]
	while ( (USB0_USBTRC0 & USB_USBTRC_USBRESET) != 0 ); // wait for reset to end
    6b1c:	7818      	ldrb	r0, [r3, #0]
    6b1e:	4917      	ldr	r1, [pc, #92]	; (6b7c <usb_init+0x84>)
    6b20:	0600      	lsls	r0, r0, #24
    6b22:	d4fb      	bmi.n	6b1c <usb_init+0x24>

	// set desc table base addr
	USB0_BDTPAGE1 = ((uint32_t)table) >> 8;
    6b24:	4b16      	ldr	r3, [pc, #88]	; (6b80 <usb_init+0x88>)
    6b26:	f3c2 2007 	ubfx	r0, r2, #8, #8
    6b2a:	7018      	strb	r0, [r3, #0]
	USB0_BDTPAGE2 = ((uint32_t)table) >> 16;
    6b2c:	f3c2 4007 	ubfx	r0, r2, #16, #8
	USB0_BDTPAGE3 = ((uint32_t)table) >> 24;
    6b30:	0e12      	lsrs	r2, r2, #24
	USB0_USBTRC0 = USB_USBTRC_USBRESET;
	while ( (USB0_USBTRC0 & USB_USBTRC_USBRESET) != 0 ); // wait for reset to end

	// set desc table base addr
	USB0_BDTPAGE1 = ((uint32_t)table) >> 8;
	USB0_BDTPAGE2 = ((uint32_t)table) >> 16;
    6b32:	7518      	strb	r0, [r3, #20]
	USB0_BDTPAGE3 = ((uint32_t)table) >> 24;
    6b34:	761a      	strb	r2, [r3, #24]

	// clear all ISR flags
	USB0_ISTAT = 0xFF;
    6b36:	4a13      	ldr	r2, [pc, #76]	; (6b84 <usb_init+0x8c>)
    6b38:	23ff      	movs	r3, #255	; 0xff
    6b3a:	7013      	strb	r3, [r2, #0]
	USB0_ERRSTAT = 0xFF;
    6b3c:	7213      	strb	r3, [r2, #8]
	USB0_OTGISTAT = 0xFF;
    6b3e:	f802 3c70 	strb.w	r3, [r2, #-112]

	USB0_USBTRC0 |= 0x40; // undocumented bit
    6b42:	780b      	ldrb	r3, [r1, #0]
    6b44:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    6b48:	700b      	strb	r3, [r1, #0]

	// enable USB
	USB0_CTL = USB_CTL_USBENSOFEN;
    6b4a:	4b0f      	ldr	r3, [pc, #60]	; (6b88 <usb_init+0x90>)
    6b4c:	2001      	movs	r0, #1
	USB0_USBCTRL = 0;
    6b4e:	2200      	movs	r2, #0
	USB0_OTGISTAT = 0xFF;

	USB0_USBTRC0 |= 0x40; // undocumented bit

	// enable USB
	USB0_CTL = USB_CTL_USBENSOFEN;
    6b50:	7018      	strb	r0, [r3, #0]
	USB0_USBCTRL = 0;
    6b52:	f883 206c 	strb.w	r2, [r3, #108]	; 0x6c

	// enable reset interrupt
	USB0_INTEN = USB_INTEN_USBRSTEN;
    6b56:	f803 0c10 	strb.w	r0, [r3, #-16]

	// enable interrupt in NVIC...
	NVIC_SET_PRIORITY( IRQ_USBOTG, 112 );
    6b5a:	4b0c      	ldr	r3, [pc, #48]	; (6b8c <usb_init+0x94>)
    6b5c:	2270      	movs	r2, #112	; 0x70
	NVIC_ENABLE_IRQ( IRQ_USBOTG );
    6b5e:	f46f 7c50 	mvn.w	ip, #832	; 0x340

	// enable reset interrupt
	USB0_INTEN = USB_INTEN_USBRSTEN;

	// enable interrupt in NVIC...
	NVIC_SET_PRIORITY( IRQ_USBOTG, 112 );
    6b62:	701a      	strb	r2, [r3, #0]
	NVIC_ENABLE_IRQ( IRQ_USBOTG );
    6b64:	4463      	add	r3, ip
    6b66:	f44f 7200 	mov.w	r2, #512	; 0x200
    6b6a:	601a      	str	r2, [r3, #0]

	// enable d+ pullup
	USB0_CONTROL = USB_CONTROL_DPPULLUPNONOTG;
    6b6c:	4b08      	ldr	r3, [pc, #32]	; (6b90 <usb_init+0x98>)
    6b6e:	2210      	movs	r2, #16
    6b70:	701a      	strb	r2, [r3, #0]

	return 1;
}
    6b72:	4770      	bx	lr
    6b74:	1fff8000 	.word	0x1fff8000
    6b78:	40048034 	.word	0x40048034
    6b7c:	4007210c 	.word	0x4007210c
    6b80:	4007209c 	.word	0x4007209c
    6b84:	40072080 	.word	0x40072080
    6b88:	40072094 	.word	0x40072094
    6b8c:	e000e449 	.word	0xe000e449
    6b90:	40072108 	.word	0x40072108

00006b94 <usb_keyboard_send>:

// ----- Functions -----

// send the contents of keyboard_keys and keyboard_modifier_keys
void usb_keyboard_send()
{
    6b94:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    6b98:	f246 4501 	movw	r5, #25601	; 0x6401
	usb_packet_t *tx_packet;

	// Wait till ready
	while ( 1 )
	{
		if ( !usb_configuration )
    6b9c:	4b99      	ldr	r3, [pc, #612]	; (6e04 <usb_keyboard_send+0x270>)
    6b9e:	781b      	ldrb	r3, [r3, #0]
    6ba0:	b90b      	cbnz	r3, 6ba6 <usb_keyboard_send+0x12>
		{
			erro_print("USB not configured...");
    6ba2:	4899      	ldr	r0, [pc, #612]	; (6e08 <usb_keyboard_send+0x274>)
    6ba4:	e023      	b.n	6bee <usb_keyboard_send+0x5a>
			return;
		}

		if ( USBKeys_Protocol == 0 ) // Boot Mode
    6ba6:	4b99      	ldr	r3, [pc, #612]	; (6e0c <usb_keyboard_send+0x278>)
    6ba8:	781a      	ldrb	r2, [r3, #0]
    6baa:	461e      	mov	r6, r3
    6bac:	b942      	cbnz	r2, 6bc0 <usb_keyboard_send+0x2c>
		{
			if ( usb_tx_packet_count( KEYBOARD_ENDPOINT ) < TX_PACKET_LIMIT )
    6bae:	2001      	movs	r0, #1
    6bb0:	f7ff fb76 	bl	62a0 <usb_tx_packet_count>
    6bb4:	2803      	cmp	r0, #3
    6bb6:	d90f      	bls.n	6bd8 <usb_keyboard_send+0x44>
				if ( tx_packet )
					break;
			}
		}

		if ( ++wait_count > TX_TIMEOUT || transmit_previous_timeout )
    6bb8:	3d01      	subs	r5, #1
    6bba:	4b95      	ldr	r3, [pc, #596]	; (6e10 <usb_keyboard_send+0x27c>)
    6bbc:	d112      	bne.n	6be4 <usb_keyboard_send+0x50>
    6bbe:	e013      	b.n	6be8 <usb_keyboard_send+0x54>
				tx_packet = usb_malloc();
				if ( tx_packet )
					break;
			}
		}
		else if ( USBKeys_Protocol == 1 ) // NKRO Mode
    6bc0:	781b      	ldrb	r3, [r3, #0]
    6bc2:	2b01      	cmp	r3, #1
    6bc4:	d101      	bne.n	6bca <usb_keyboard_send+0x36>
		{
			if ( usb_tx_packet_count( NKRO_KEYBOARD_ENDPOINT ) < TX_PACKET_LIMIT )
    6bc6:	2002      	movs	r0, #2
    6bc8:	e7f2      	b.n	6bb0 <usb_keyboard_send+0x1c>
				tx_packet = usb_malloc();
				if ( tx_packet )
					break;
			}
		}
		else if ( USBKeys_Changed &
    6bca:	4b92      	ldr	r3, [pc, #584]	; (6e14 <usb_keyboard_send+0x280>)
    6bcc:	781b      	ldrb	r3, [r3, #0]
    6bce:	f013 0f60 	tst.w	r3, #96	; 0x60
    6bd2:	d0f1      	beq.n	6bb8 <usb_keyboard_send+0x24>
			( USBKeyChangeState_System | USBKeyChangeState_Consumer )
		)
		{
			if ( usb_tx_packet_count( SYS_CTRL_ENDPOINT ) < TX_PACKET_LIMIT )
    6bd4:	2008      	movs	r0, #8
    6bd6:	e7eb      	b.n	6bb0 <usb_keyboard_send+0x1c>
			{
				tx_packet = usb_malloc();
    6bd8:	f000 f93e 	bl	6e58 <usb_malloc>
				if ( tx_packet )
    6bdc:	4604      	mov	r4, r0
    6bde:	2800      	cmp	r0, #0
    6be0:	d0ea      	beq.n	6bb8 <usb_keyboard_send+0x24>
    6be2:	e00b      	b.n	6bfc <usb_keyboard_send+0x68>
					break;
			}
		}

		if ( ++wait_count > TX_TIMEOUT || transmit_previous_timeout )
    6be4:	781a      	ldrb	r2, [r3, #0]
    6be6:	b132      	cbz	r2, 6bf6 <usb_keyboard_send+0x62>
		{
			transmit_previous_timeout = 1;
    6be8:	2201      	movs	r2, #1
			warn_print("USB Transmit Timeout...");
    6bea:	488b      	ldr	r0, [pc, #556]	; (6e18 <usb_keyboard_send+0x284>)
			}
		}

		if ( ++wait_count > TX_TIMEOUT || transmit_previous_timeout )
		{
			transmit_previous_timeout = 1;
    6bec:	701a      	strb	r2, [r3, #0]

		break;
	}

	return;
}
    6bee:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		}

		if ( ++wait_count > TX_TIMEOUT || transmit_previous_timeout )
		{
			transmit_previous_timeout = 1;
			warn_print("USB Transmit Timeout...");
    6bf2:	f000 be07 	b.w	7804 <_print>
			return;
		}
		yield();
    6bf6:	f7fb fcca 	bl	258e <yield>
	}
    6bfa:	e7cf      	b.n	6b9c <usb_keyboard_send+0x8>

	// Pointer to USB tx packet buffer
	uint8_t *tx_buf = tx_packet->buf;

	// Check system control keys
	if ( USBKeys_Changed & USBKeyChangeState_System )
    6bfc:	4d85      	ldr	r5, [pc, #532]	; (6e14 <usb_keyboard_send+0x280>)
    6bfe:	782b      	ldrb	r3, [r5, #0]
    6c00:	069a      	lsls	r2, r3, #26
    6c02:	d51a      	bpl.n	6c3a <usb_keyboard_send+0xa6>
	{
		if ( Output_DebugMode )
    6c04:	4b85      	ldr	r3, [pc, #532]	; (6e1c <usb_keyboard_send+0x288>)
    6c06:	4e86      	ldr	r6, [pc, #536]	; (6e20 <usb_keyboard_send+0x28c>)
    6c08:	781b      	ldrb	r3, [r3, #0]
    6c0a:	b14b      	cbz	r3, 6c20 <usb_keyboard_send+0x8c>
		{
			print("SysCtrl[");
    6c0c:	4885      	ldr	r0, [pc, #532]	; (6e24 <usb_keyboard_send+0x290>)
    6c0e:	f000 fdf9 	bl	7804 <_print>
			printHex_op( USBKeys_SysCtrl, 2 );
    6c12:	7830      	ldrb	r0, [r6, #0]
    6c14:	2102      	movs	r1, #2
    6c16:	f000 fe7e 	bl	7916 <printHex_op>
			print( "] " NL );
    6c1a:	4883      	ldr	r0, [pc, #524]	; (6e28 <usb_keyboard_send+0x294>)
    6c1c:	f000 fdf2 	bl	7804 <_print>
		}

		*tx_buf++ = 0x02; // ID
		*tx_buf   = USBKeys_SysCtrl;
    6c20:	7832      	ldrb	r2, [r6, #0]
			print("SysCtrl[");
			printHex_op( USBKeys_SysCtrl, 2 );
			print( "] " NL );
		}

		*tx_buf++ = 0x02; // ID
    6c22:	2302      	movs	r3, #2
    6c24:	7223      	strb	r3, [r4, #8]
		*tx_buf   = USBKeys_SysCtrl;
		tx_packet->len = 2;
    6c26:	8023      	strh	r3, [r4, #0]
			printHex_op( USBKeys_SysCtrl, 2 );
			print( "] " NL );
		}

		*tx_buf++ = 0x02; // ID
		*tx_buf   = USBKeys_SysCtrl;
    6c28:	7262      	strb	r2, [r4, #9]
		tx_packet->len = 2;

		// Send USB Packet
		usb_tx( SYS_CTRL_ENDPOINT, tx_packet );
    6c2a:	2008      	movs	r0, #8
    6c2c:	4621      	mov	r1, r4
    6c2e:	f7ff fb85 	bl	633c <usb_tx>
		USBKeys_Changed &= ~USBKeyChangeState_System; // Mark sent
    6c32:	782b      	ldrb	r3, [r5, #0]
    6c34:	f023 0320 	bic.w	r3, r3, #32
    6c38:	e0e0      	b.n	6dfc <usb_keyboard_send+0x268>
		return;
	}

	// Check consumer control keys
	if ( USBKeys_Changed & USBKeyChangeState_Consumer )
    6c3a:	065b      	lsls	r3, r3, #25
    6c3c:	d51c      	bpl.n	6c78 <usb_keyboard_send+0xe4>
	{
		if ( Output_DebugMode )
    6c3e:	4b77      	ldr	r3, [pc, #476]	; (6e1c <usb_keyboard_send+0x288>)
    6c40:	4e7a      	ldr	r6, [pc, #488]	; (6e2c <usb_keyboard_send+0x298>)
    6c42:	781b      	ldrb	r3, [r3, #0]
    6c44:	b14b      	cbz	r3, 6c5a <usb_keyboard_send+0xc6>
		{
			print("ConsCtrl[");
    6c46:	487a      	ldr	r0, [pc, #488]	; (6e30 <usb_keyboard_send+0x29c>)
    6c48:	f000 fddc 	bl	7804 <_print>
			printHex_op( USBKeys_ConsCtrl, 2 );
    6c4c:	8830      	ldrh	r0, [r6, #0]
    6c4e:	2102      	movs	r1, #2
    6c50:	f000 fe61 	bl	7916 <printHex_op>
			print( "] " NL );
    6c54:	4874      	ldr	r0, [pc, #464]	; (6e28 <usb_keyboard_send+0x294>)
    6c56:	f000 fdd5 	bl	7804 <_print>
		}

		*tx_buf++ = 0x03; // ID
		*tx_buf++ = (uint8_t)(USBKeys_ConsCtrl & 0x00FF);
    6c5a:	8832      	ldrh	r2, [r6, #0]
			print("ConsCtrl[");
			printHex_op( USBKeys_ConsCtrl, 2 );
			print( "] " NL );
		}

		*tx_buf++ = 0x03; // ID
    6c5c:	2303      	movs	r3, #3
		*tx_buf++ = (uint8_t)(USBKeys_ConsCtrl & 0x00FF);
    6c5e:	7262      	strb	r2, [r4, #9]
		*tx_buf   = (uint8_t)(USBKeys_ConsCtrl >> 8);
    6c60:	0a12      	lsrs	r2, r2, #8
			print("ConsCtrl[");
			printHex_op( USBKeys_ConsCtrl, 2 );
			print( "] " NL );
		}

		*tx_buf++ = 0x03; // ID
    6c62:	7223      	strb	r3, [r4, #8]
		*tx_buf++ = (uint8_t)(USBKeys_ConsCtrl & 0x00FF);
		*tx_buf   = (uint8_t)(USBKeys_ConsCtrl >> 8);
		tx_packet->len = 3;
    6c64:	8023      	strh	r3, [r4, #0]
			print( "] " NL );
		}

		*tx_buf++ = 0x03; // ID
		*tx_buf++ = (uint8_t)(USBKeys_ConsCtrl & 0x00FF);
		*tx_buf   = (uint8_t)(USBKeys_ConsCtrl >> 8);
    6c66:	72a2      	strb	r2, [r4, #10]
		tx_packet->len = 3;

		// Send USB Packet
		usb_tx( SYS_CTRL_ENDPOINT, tx_packet );
    6c68:	2008      	movs	r0, #8
    6c6a:	4621      	mov	r1, r4
    6c6c:	f7ff fb66 	bl	633c <usb_tx>
		USBKeys_Changed &= ~USBKeyChangeState_Consumer; // Mark sent
    6c70:	782b      	ldrb	r3, [r5, #0]
    6c72:	f023 0340 	bic.w	r3, r3, #64	; 0x40
    6c76:	e0c1      	b.n	6dfc <usb_keyboard_send+0x268>
		return;
	}

	switch ( USBKeys_Protocol )
    6c78:	7833      	ldrb	r3, [r6, #0]
    6c7a:	f003 06ff 	and.w	r6, r3, #255	; 0xff
    6c7e:	b11b      	cbz	r3, 6c88 <usb_keyboard_send+0xf4>
    6c80:	2e01      	cmp	r6, #1
    6c82:	d045      	beq.n	6d10 <usb_keyboard_send+0x17c>
    6c84:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	{
	// Send boot keyboard interrupt packet(s)
	case 0:
		// USB Boot Mode debug output
		if ( Output_DebugMode )
    6c88:	4b64      	ldr	r3, [pc, #400]	; (6e1c <usb_keyboard_send+0x288>)
    6c8a:	4f6a      	ldr	r7, [pc, #424]	; (6e34 <usb_keyboard_send+0x2a0>)
    6c8c:	781b      	ldrb	r3, [r3, #0]
    6c8e:	b363      	cbz	r3, 6cea <usb_keyboard_send+0x156>
		{
			dbug_msg("Boot USB: ");
    6c90:	4869      	ldr	r0, [pc, #420]	; (6e38 <usb_keyboard_send+0x2a4>)
    6c92:	f000 fdb7 	bl	7804 <_print>
			printHex_op( USBKeys_Modifiers, 2 );
    6c96:	2102      	movs	r1, #2
    6c98:	7838      	ldrb	r0, [r7, #0]
    6c9a:	f000 fe3c 	bl	7916 <printHex_op>
			print(" ");
    6c9e:	4867      	ldr	r0, [pc, #412]	; (6e3c <usb_keyboard_send+0x2a8>)
    6ca0:	f000 fdb0 	bl	7804 <_print>
			printHex( 0 );
    6ca4:	4630      	mov	r0, r6
    6ca6:	2101      	movs	r1, #1
			print(" ");
			printHex_op( USBKeys_Keys[0], 2 );
    6ca8:	4e65      	ldr	r6, [pc, #404]	; (6e40 <usb_keyboard_send+0x2ac>)
		if ( Output_DebugMode )
		{
			dbug_msg("Boot USB: ");
			printHex_op( USBKeys_Modifiers, 2 );
			print(" ");
			printHex( 0 );
    6caa:	f000 fe34 	bl	7916 <printHex_op>
			print(" ");
    6cae:	4863      	ldr	r0, [pc, #396]	; (6e3c <usb_keyboard_send+0x2a8>)
    6cb0:	f000 fda8 	bl	7804 <_print>
			printHex_op( USBKeys_Keys[0], 2 );
    6cb4:	7830      	ldrb	r0, [r6, #0]
    6cb6:	2102      	movs	r1, #2
    6cb8:	f000 fe2d 	bl	7916 <printHex_op>
			printHex_op( USBKeys_Keys[1], 2 );
    6cbc:	7870      	ldrb	r0, [r6, #1]
    6cbe:	2102      	movs	r1, #2
    6cc0:	f000 fe29 	bl	7916 <printHex_op>
			printHex_op( USBKeys_Keys[2], 2 );
    6cc4:	78b0      	ldrb	r0, [r6, #2]
    6cc6:	2102      	movs	r1, #2
    6cc8:	f000 fe25 	bl	7916 <printHex_op>
			printHex_op( USBKeys_Keys[3], 2 );
    6ccc:	78f0      	ldrb	r0, [r6, #3]
    6cce:	2102      	movs	r1, #2
    6cd0:	f000 fe21 	bl	7916 <printHex_op>
			printHex_op( USBKeys_Keys[4], 2 );
    6cd4:	7930      	ldrb	r0, [r6, #4]
    6cd6:	2102      	movs	r1, #2
    6cd8:	f000 fe1d 	bl	7916 <printHex_op>
			printHex_op( USBKeys_Keys[5], 2 );
    6cdc:	7970      	ldrb	r0, [r6, #5]
    6cde:	2102      	movs	r1, #2
    6ce0:	f000 fe19 	bl	7916 <printHex_op>
			print( NL );
    6ce4:	4857      	ldr	r0, [pc, #348]	; (6e44 <usb_keyboard_send+0x2b0>)
    6ce6:	f000 fd8d 	bl	7804 <_print>
		}

		// Boot Mode
		*tx_buf++ = USBKeys_Modifiers;
    6cea:	783b      	ldrb	r3, [r7, #0]
		*tx_buf++ = 0;
		memcpy( tx_buf, USBKeys_Keys, USB_BOOT_MAX_KEYS );
    6cec:	4954      	ldr	r1, [pc, #336]	; (6e40 <usb_keyboard_send+0x2ac>)
			printHex_op( USBKeys_Keys[5], 2 );
			print( NL );
		}

		// Boot Mode
		*tx_buf++ = USBKeys_Modifiers;
    6cee:	7223      	strb	r3, [r4, #8]
		*tx_buf++ = 0;
    6cf0:	2600      	movs	r6, #0
		memcpy( tx_buf, USBKeys_Keys, USB_BOOT_MAX_KEYS );
    6cf2:	2206      	movs	r2, #6
			print( NL );
		}

		// Boot Mode
		*tx_buf++ = USBKeys_Modifiers;
		*tx_buf++ = 0;
    6cf4:	7266      	strb	r6, [r4, #9]
		memcpy( tx_buf, USBKeys_Keys, USB_BOOT_MAX_KEYS );
    6cf6:	f104 000a 	add.w	r0, r4, #10
    6cfa:	f7fb fc3f 	bl	257c <memcpy>
		tx_packet->len = 8;
    6cfe:	2308      	movs	r3, #8
    6d00:	8023      	strh	r3, [r4, #0]

		// Send USB Packet
		usb_tx( KEYBOARD_ENDPOINT, tx_packet );
    6d02:	2001      	movs	r0, #1
    6d04:	4621      	mov	r1, r4
    6d06:	f7ff fb19 	bl	633c <usb_tx>
		USBKeys_Changed = USBKeyChangeState_None;
    6d0a:	702e      	strb	r6, [r5, #0]
		break;
    6d0c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

	// Send NKRO keyboard interrupts packet(s)
	case 1:
		if ( Output_DebugMode )
    6d10:	4b42      	ldr	r3, [pc, #264]	; (6e1c <usb_keyboard_send+0x288>)
    6d12:	781a      	ldrb	r2, [r3, #0]
    6d14:	461e      	mov	r6, r3
    6d16:	b112      	cbz	r2, 6d1e <usb_keyboard_send+0x18a>
		{
			dbug_msg("NKRO USB: ");
    6d18:	484b      	ldr	r0, [pc, #300]	; (6e48 <usb_keyboard_send+0x2b4>)
    6d1a:	f000 fd73 	bl	7804 <_print>
		}

		// Standard HID Keyboard
		if ( USBKeys_Changed )
    6d1e:	782b      	ldrb	r3, [r5, #0]
    6d20:	2b00      	cmp	r3, #0
    6d22:	d06c      	beq.n	6dfe <usb_keyboard_send+0x26a>
		{
			// USB NKRO Debug output
			if ( Output_DebugMode )
    6d24:	7833      	ldrb	r3, [r6, #0]
    6d26:	4f43      	ldr	r7, [pc, #268]	; (6e34 <usb_keyboard_send+0x2a0>)
    6d28:	2b00      	cmp	r3, #0
    6d2a:	d036      	beq.n	6d9a <usb_keyboard_send+0x206>
			{
				printHex_op( USBKeys_Modifiers, 2 );
    6d2c:	7838      	ldrb	r0, [r7, #0]
    6d2e:	2102      	movs	r1, #2
    6d30:	f000 fdf1 	bl	7916 <printHex_op>
				print(" ");
    6d34:	4841      	ldr	r0, [pc, #260]	; (6e3c <usb_keyboard_send+0x2a8>)
    6d36:	f000 fd65 	bl	7804 <_print>
    6d3a:	2600      	movs	r6, #0
				for ( uint8_t c = 0; c < 6; c++ )
					printHex_op( USBKeys_Keys[ c ], 2 );
    6d3c:	f8df 8100 	ldr.w	r8, [pc, #256]	; 6e40 <usb_keyboard_send+0x2ac>
    6d40:	2102      	movs	r1, #2
    6d42:	f818 0006 	ldrb.w	r0, [r8, r6]
    6d46:	3601      	adds	r6, #1
    6d48:	f000 fde5 	bl	7916 <printHex_op>
			// USB NKRO Debug output
			if ( Output_DebugMode )
			{
				printHex_op( USBKeys_Modifiers, 2 );
				print(" ");
				for ( uint8_t c = 0; c < 6; c++ )
    6d4c:	2e06      	cmp	r6, #6
    6d4e:	d1f5      	bne.n	6d3c <usb_keyboard_send+0x1a8>
					printHex_op( USBKeys_Keys[ c ], 2 );
				print(" ");
    6d50:	483a      	ldr	r0, [pc, #232]	; (6e3c <usb_keyboard_send+0x2a8>)
    6d52:	f000 fd57 	bl	7804 <_print>
    6d56:	2600      	movs	r6, #0
    6d58:	eb08 0306 	add.w	r3, r8, r6
				for ( uint8_t c = 6; c < 20; c++ )
					printHex_op( USBKeys_Keys[ c ], 2 );
    6d5c:	2102      	movs	r1, #2
    6d5e:	7998      	ldrb	r0, [r3, #6]
    6d60:	3601      	adds	r6, #1
    6d62:	f000 fdd8 	bl	7916 <printHex_op>
				printHex_op( USBKeys_Modifiers, 2 );
				print(" ");
				for ( uint8_t c = 0; c < 6; c++ )
					printHex_op( USBKeys_Keys[ c ], 2 );
				print(" ");
				for ( uint8_t c = 6; c < 20; c++ )
    6d66:	2e0e      	cmp	r6, #14
    6d68:	d1f6      	bne.n	6d58 <usb_keyboard_send+0x1c4>
					printHex_op( USBKeys_Keys[ c ], 2 );
				print(" ");
    6d6a:	4834      	ldr	r0, [pc, #208]	; (6e3c <usb_keyboard_send+0x2a8>)
    6d6c:	f000 fd4a 	bl	7804 <_print>
				printHex_op( USBKeys_Keys[20], 2 );
    6d70:	4b33      	ldr	r3, [pc, #204]	; (6e40 <usb_keyboard_send+0x2ac>)
    6d72:	2102      	movs	r1, #2
    6d74:	7d18      	ldrb	r0, [r3, #20]
    6d76:	f000 fdce 	bl	7916 <printHex_op>
				print(" ");
    6d7a:	4830      	ldr	r0, [pc, #192]	; (6e3c <usb_keyboard_send+0x2a8>)
    6d7c:	f000 fd42 	bl	7804 <_print>
    6d80:	2600      	movs	r6, #0
    6d82:	eb08 0306 	add.w	r3, r8, r6
				for ( uint8_t c = 21; c < 27; c++ )
					printHex_op( USBKeys_Keys[ c ], 2 );
    6d86:	2102      	movs	r1, #2
    6d88:	7d58      	ldrb	r0, [r3, #21]
    6d8a:	3601      	adds	r6, #1
    6d8c:	f000 fdc3 	bl	7916 <printHex_op>
				for ( uint8_t c = 6; c < 20; c++ )
					printHex_op( USBKeys_Keys[ c ], 2 );
				print(" ");
				printHex_op( USBKeys_Keys[20], 2 );
				print(" ");
				for ( uint8_t c = 21; c < 27; c++ )
    6d90:	2e06      	cmp	r6, #6
    6d92:	d1f6      	bne.n	6d82 <usb_keyboard_send+0x1ee>
					printHex_op( USBKeys_Keys[ c ], 2 );
				print( NL );
    6d94:	482b      	ldr	r0, [pc, #172]	; (6e44 <usb_keyboard_send+0x2b0>)
    6d96:	f000 fd35 	bl	7804 <_print>

			tx_packet->len = 0;

			// Modifiers
			*tx_buf++ = 0x01; // ID
			*tx_buf++ = USBKeys_Modifiers;
    6d9a:	783b      	ldrb	r3, [r7, #0]
			tx_packet->len += 2;

			// 4-49 (first 6 bytes)
			memcpy( tx_buf, USBKeys_Keys, 6 );
    6d9c:	4928      	ldr	r1, [pc, #160]	; (6e40 <usb_keyboard_send+0x2ac>)

			tx_packet->len = 0;

			// Modifiers
			*tx_buf++ = 0x01; // ID
			*tx_buf++ = USBKeys_Modifiers;
    6d9e:	7263      	strb	r3, [r4, #9]
			tx_packet->len += 2;
    6da0:	4620      	mov	r0, r4
			}

			tx_packet->len = 0;

			// Modifiers
			*tx_buf++ = 0x01; // ID
    6da2:	f04f 0801 	mov.w	r8, #1
			*tx_buf++ = USBKeys_Modifiers;
			tx_packet->len += 2;
    6da6:	2602      	movs	r6, #2
			}

			tx_packet->len = 0;

			// Modifiers
			*tx_buf++ = 0x01; // ID
    6da8:	f884 8008 	strb.w	r8, [r4, #8]
			*tx_buf++ = USBKeys_Modifiers;
			tx_packet->len += 2;

			// 4-49 (first 6 bytes)
			memcpy( tx_buf, USBKeys_Keys, 6 );
    6dac:	2206      	movs	r2, #6
			tx_packet->len = 0;

			// Modifiers
			*tx_buf++ = 0x01; // ID
			*tx_buf++ = USBKeys_Modifiers;
			tx_packet->len += 2;
    6dae:	f820 6b0a 	strh.w	r6, [r0], #10

			// 4-49 (first 6 bytes)
			memcpy( tx_buf, USBKeys_Keys, 6 );
    6db2:	f7fb fbe3 	bl	257c <memcpy>
			tx_buf += 6;
			tx_packet->len += 6;
    6db6:	8822      	ldrh	r2, [r4, #0]

			// 51-155 (Middle 14 bytes)
			memcpy( tx_buf, USBKeys_Keys + 6, 14 );
    6db8:	4924      	ldr	r1, [pc, #144]	; (6e4c <usb_keyboard_send+0x2b8>)
			tx_packet->len += 2;

			// 4-49 (first 6 bytes)
			memcpy( tx_buf, USBKeys_Keys, 6 );
			tx_buf += 6;
			tx_packet->len += 6;
    6dba:	4620      	mov	r0, r4
    6dbc:	3206      	adds	r2, #6
    6dbe:	f820 2b10 	strh.w	r2, [r0], #16

			// 51-155 (Middle 14 bytes)
			memcpy( tx_buf, USBKeys_Keys + 6, 14 );
    6dc2:	220e      	movs	r2, #14
    6dc4:	f7fb fbda 	bl	257c <memcpy>
			tx_buf += 14;
			tx_packet->len += 14;
    6dc8:	8822      	ldrh	r2, [r4, #0]

			// 157-164 (Next byte)
			memcpy( tx_buf, USBKeys_Keys + 20, 1 );
    6dca:	4921      	ldr	r1, [pc, #132]	; (6e50 <usb_keyboard_send+0x2bc>)
			tx_packet->len += 6;

			// 51-155 (Middle 14 bytes)
			memcpy( tx_buf, USBKeys_Keys + 6, 14 );
			tx_buf += 14;
			tx_packet->len += 14;
    6dcc:	4620      	mov	r0, r4
    6dce:	320e      	adds	r2, #14
    6dd0:	f820 2b1e 	strh.w	r2, [r0], #30

			// 157-164 (Next byte)
			memcpy( tx_buf, USBKeys_Keys + 20, 1 );
    6dd4:	4642      	mov	r2, r8
    6dd6:	f7fb fbd1 	bl	257c <memcpy>
			tx_buf += 1;
			tx_packet->len += 1;
    6dda:	8822      	ldrh	r2, [r4, #0]

			// 176-221 (last 6 bytes)
			memcpy( tx_buf, USBKeys_Keys + 21, 6 );
    6ddc:	491d      	ldr	r1, [pc, #116]	; (6e54 <usb_keyboard_send+0x2c0>)
			tx_packet->len += 14;

			// 157-164 (Next byte)
			memcpy( tx_buf, USBKeys_Keys + 20, 1 );
			tx_buf += 1;
			tx_packet->len += 1;
    6dde:	4620      	mov	r0, r4
    6de0:	4442      	add	r2, r8
    6de2:	f820 2b1f 	strh.w	r2, [r0], #31

			// 176-221 (last 6 bytes)
			memcpy( tx_buf, USBKeys_Keys + 21, 6 );
    6de6:	2206      	movs	r2, #6
    6de8:	f7fb fbc8 	bl	257c <memcpy>
			tx_packet->len += 6;
    6dec:	8823      	ldrh	r3, [r4, #0]
    6dee:	3306      	adds	r3, #6
    6df0:	8023      	strh	r3, [r4, #0]

			// Send USB Packet
			usb_tx( NKRO_KEYBOARD_ENDPOINT, tx_packet );
    6df2:	4630      	mov	r0, r6
    6df4:	4621      	mov	r1, r4
    6df6:	f7ff faa1 	bl	633c <usb_tx>
			USBKeys_Changed = USBKeyChangeState_None; // Mark sent
    6dfa:	2300      	movs	r3, #0
    6dfc:	702b      	strb	r3, [r5, #0]
    6dfe:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    6e02:	bf00      	nop
    6e04:	1fff961f 	.word	0x1fff961f
    6e08:	0000ba94 	.word	0x0000ba94
    6e0c:	1fff8e51 	.word	0x1fff8e51
    6e10:	1fff9621 	.word	0x1fff9621
    6e14:	1fff94f0 	.word	0x1fff94f0
    6e18:	0000bac1 	.word	0x0000bac1
    6e1c:	1fff94f2 	.word	0x1fff94f2
    6e20:	1fffa61c 	.word	0x1fffa61c
    6e24:	0000baf0 	.word	0x0000baf0
    6e28:	0000baf9 	.word	0x0000baf9
    6e2c:	1fffa654 	.word	0x1fffa654
    6e30:	0000bafe 	.word	0x0000bafe
    6e34:	1fff94ef 	.word	0x1fff94ef
    6e38:	0000bb08 	.word	0x0000bb08
    6e3c:	00008156 	.word	0x00008156
    6e40:	1fffa61d 	.word	0x1fffa61d
    6e44:	0000bafb 	.word	0x0000bafb
    6e48:	0000bb26 	.word	0x0000bb26
    6e4c:	1fffa623 	.word	0x1fffa623
    6e50:	1fffa631 	.word	0x1fffa631
    6e54:	1fffa632 	.word	0x1fffa632

00006e58 <usb_malloc>:
usb_packet_t *usb_malloc()
{
	unsigned int n, avail;
	uint8_t *p;

	__disable_irq();
    6e58:	b672      	cpsid	i
	avail = usb_buffer_available;
    6e5a:	4a0c      	ldr	r2, [pc, #48]	; (6e8c <usb_malloc+0x34>)
    6e5c:	6811      	ldr	r1, [r2, #0]
	n = __builtin_clz( avail ); // clz = count leading zeros
    6e5e:	fab1 f381 	clz	r3, r1
	if ( n >= NUM_USB_BUFFERS )
    6e62:	2b1d      	cmp	r3, #29
    6e64:	d902      	bls.n	6e6c <usb_malloc+0x14>
	{
		__enable_irq();
    6e66:	b662      	cpsie	i
		return NULL;
    6e68:	2000      	movs	r0, #0
    6e6a:	4770      	bx	lr
	}

	usb_buffer_available = avail & ~(0x80000000 >> n);
    6e6c:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
    6e70:	40d8      	lsrs	r0, r3
    6e72:	ea21 0100 	bic.w	r1, r1, r0
    6e76:	6011      	str	r1, [r2, #0]
	__enable_irq();
    6e78:	b662      	cpsie	i
	p = usb_buffer_memory + ( n * sizeof(usb_packet_t) );
    6e7a:	4905      	ldr	r1, [pc, #20]	; (6e90 <usb_malloc+0x38>)
    6e7c:	2248      	movs	r2, #72	; 0x48
    6e7e:	4353      	muls	r3, r2
    6e80:	18c8      	adds	r0, r1, r3
	*(uint32_t *)p = 0;
    6e82:	2200      	movs	r2, #0
    6e84:	50ca      	str	r2, [r1, r3]
	*(uint32_t *)(p + 4) = 0;
    6e86:	6042      	str	r2, [r0, #4]
	return (usb_packet_t *)p;
}
    6e88:	4770      	bx	lr
    6e8a:	bf00      	nop
    6e8c:	1fff9298 	.word	0x1fff9298
    6e90:	1fff8120 	.word	0x1fff8120

00006e94 <usb_free>:

void usb_free( usb_packet_t *p )
{
	unsigned int n, mask;

	n = ( (uint8_t *)p - usb_buffer_memory ) / sizeof(usb_packet_t);
    6e94:	4b0c      	ldr	r3, [pc, #48]	; (6ec8 <usb_free+0x34>)
    6e96:	2248      	movs	r2, #72	; 0x48
    6e98:	1ac3      	subs	r3, r0, r3
    6e9a:	fbb3 f3f2 	udiv	r3, r3, r2
	if ( n >= NUM_USB_BUFFERS )
    6e9e:	2b1d      	cmp	r3, #29
    6ea0:	d811      	bhi.n	6ec6 <usb_free+0x32>
		return;

	// if any endpoints are starving for memory to receive
	// packets, give this memory to them immediately!
	if ( usb_rx_memory_needed && usb_configuration )
    6ea2:	4a0a      	ldr	r2, [pc, #40]	; (6ecc <usb_free+0x38>)
    6ea4:	7812      	ldrb	r2, [r2, #0]
    6ea6:	b122      	cbz	r2, 6eb2 <usb_free+0x1e>
    6ea8:	4a09      	ldr	r2, [pc, #36]	; (6ed0 <usb_free+0x3c>)
    6eaa:	7812      	ldrb	r2, [r2, #0]
    6eac:	b10a      	cbz	r2, 6eb2 <usb_free+0x1e>
	{
		usb_rx_memory( p );
    6eae:	f7ff ba09 	b.w	62c4 <usb_rx_memory>
		return;
	}

	mask = (0x80000000 >> n);
	__disable_irq();
    6eb2:	b672      	cpsid	i
	usb_buffer_available |= mask;
    6eb4:	4a07      	ldr	r2, [pc, #28]	; (6ed4 <usb_free+0x40>)
	{
		usb_rx_memory( p );
		return;
	}

	mask = (0x80000000 >> n);
    6eb6:	f04f 4100 	mov.w	r1, #2147483648	; 0x80000000
    6eba:	fa21 f303 	lsr.w	r3, r1, r3
	__disable_irq();
	usb_buffer_available |= mask;
    6ebe:	6811      	ldr	r1, [r2, #0]
    6ec0:	4319      	orrs	r1, r3
    6ec2:	6011      	str	r1, [r2, #0]
	__enable_irq();
    6ec4:	b662      	cpsie	i
    6ec6:	4770      	bx	lr
    6ec8:	1fff8120 	.word	0x1fff8120
    6ecc:	1fff9616 	.word	0x1fff9616
    6ed0:	1fff961f 	.word	0x1fff961f
    6ed4:	1fff9298 	.word	0x1fff9298

00006ed8 <usb_serial_getchar>:

// ----- Functions -----

// get the next character, or -1 if nothing received
int usb_serial_getchar()
{
    6ed8:	b510      	push	{r4, lr}
	unsigned int i;
	int c;

	if ( !rx_packet )
    6eda:	4c10      	ldr	r4, [pc, #64]	; (6f1c <usb_serial_getchar+0x44>)
    6edc:	6823      	ldr	r3, [r4, #0]
    6ede:	b16b      	cbz	r3, 6efc <usb_serial_getchar+0x24>
			return -1;
		rx_packet = usb_rx( CDC_RX_ENDPOINT );
		if ( !rx_packet )
			return -1;
	}
	i = rx_packet->index;
    6ee0:	6820      	ldr	r0, [r4, #0]
    6ee2:	8842      	ldrh	r2, [r0, #2]
	c = rx_packet->buf[i++];
    6ee4:	1c53      	adds	r3, r2, #1
    6ee6:	4402      	add	r2, r0
    6ee8:	7a14      	ldrb	r4, [r2, #8]
	if ( i >= rx_packet->len )
    6eea:	8802      	ldrh	r2, [r0, #0]
    6eec:	4293      	cmp	r3, r2
    6eee:	d312      	bcc.n	6f16 <usb_serial_getchar+0x3e>
	{
		usb_free( rx_packet );
    6ef0:	f7ff ffd0 	bl	6e94 <usb_free>
		rx_packet = NULL;
    6ef4:	4b09      	ldr	r3, [pc, #36]	; (6f1c <usb_serial_getchar+0x44>)
    6ef6:	2200      	movs	r2, #0
    6ef8:	601a      	str	r2, [r3, #0]
    6efa:	e00d      	b.n	6f18 <usb_serial_getchar+0x40>
	unsigned int i;
	int c;

	if ( !rx_packet )
	{
		if ( !usb_configuration )
    6efc:	4b08      	ldr	r3, [pc, #32]	; (6f20 <usb_serial_getchar+0x48>)
    6efe:	781b      	ldrb	r3, [r3, #0]
    6f00:	b913      	cbnz	r3, 6f08 <usb_serial_getchar+0x30>
			return -1;
    6f02:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    6f06:	bd10      	pop	{r4, pc}
		rx_packet = usb_rx( CDC_RX_ENDPOINT );
    6f08:	2004      	movs	r0, #4
    6f0a:	f7ff f9ad 	bl	6268 <usb_rx>
    6f0e:	6020      	str	r0, [r4, #0]
		if ( !rx_packet )
    6f10:	2800      	cmp	r0, #0
    6f12:	d1e5      	bne.n	6ee0 <usb_serial_getchar+0x8>
    6f14:	e7f5      	b.n	6f02 <usb_serial_getchar+0x2a>
		usb_free( rx_packet );
		rx_packet = NULL;
	}
	else
	{
		rx_packet->index = i;
    6f16:	8043      	strh	r3, [r0, #2]
	}
	return c;
    6f18:	4620      	mov	r0, r4
}
    6f1a:	bd10      	pop	{r4, pc}
    6f1c:	1fff962c 	.word	0x1fff962c
    6f20:	1fff961f 	.word	0x1fff961f

00006f24 <usb_serial_available>:
static inline uint32_t usb_rx_byte_count(uint32_t endpoint)
{
	endpoint--;
	if ( endpoint >= NUM_ENDPOINTS )
		return 0;
	return usb_rx_byte_count_data[ endpoint ];
    6f24:	4b04      	ldr	r3, [pc, #16]	; (6f38 <usb_serial_available+0x14>)
}

// number of bytes available in the receive buffer
int usb_serial_available()
{
	int count = usb_rx_byte_count( CDC_RX_ENDPOINT );
    6f26:	88d8      	ldrh	r0, [r3, #6]
	if ( rx_packet )
    6f28:	4b04      	ldr	r3, [pc, #16]	; (6f3c <usb_serial_available+0x18>)
    6f2a:	681b      	ldr	r3, [r3, #0]
    6f2c:	b11b      	cbz	r3, 6f36 <usb_serial_available+0x12>
		count += rx_packet->len - rx_packet->index;
    6f2e:	881a      	ldrh	r2, [r3, #0]
    6f30:	885b      	ldrh	r3, [r3, #2]
    6f32:	1ad3      	subs	r3, r2, r3
    6f34:	4418      	add	r0, r3
	return count;
}
    6f36:	4770      	bx	lr
    6f38:	1fffa656 	.word	0x1fffa656
    6f3c:	1fff962c 	.word	0x1fff962c

00006f40 <usb_serial_write>:
{
	return usb_serial_write( &c, 1 );
}

int usb_serial_write( const void *buffer, uint32_t size )
{
    6f40:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	uint32_t len;
	uint32_t wait_count;
	const uint8_t *src = (const uint8_t *)buffer;
	uint8_t *dest;

	tx_noautoflush = 1;
    6f44:	4e2d      	ldr	r6, [pc, #180]	; (6ffc <usb_serial_write+0xbc>)
    6f46:	2301      	movs	r3, #1
{
	return usb_serial_write( &c, 1 );
}

int usb_serial_write( const void *buffer, uint32_t size )
{
    6f48:	4607      	mov	r7, r0
    6f4a:	460c      	mov	r4, r1
	uint32_t len;
	uint32_t wait_count;
	const uint8_t *src = (const uint8_t *)buffer;
	uint8_t *dest;

	tx_noautoflush = 1;
    6f4c:	7033      	strb	r3, [r6, #0]
	while ( size > 0 )
    6f4e:	2c00      	cmp	r4, #0
    6f50:	d04f      	beq.n	6ff2 <usb_serial_write+0xb2>
	{
		if ( !tx_packet )
    6f52:	4d2b      	ldr	r5, [pc, #172]	; (7000 <usb_serial_write+0xc0>)
    6f54:	682b      	ldr	r3, [r5, #0]
    6f56:	46a9      	mov	r9, r5
    6f58:	bb2b      	cbnz	r3, 6fa6 <usb_serial_write+0x66>
    6f5a:	f648 4801 	movw	r8, #35841	; 0x8c01
		{
			wait_count = 0;
			while ( 1 )
			{
				if ( !usb_configuration )
    6f5e:	4b29      	ldr	r3, [pc, #164]	; (7004 <usb_serial_write+0xc4>)
    6f60:	781b      	ldrb	r3, [r3, #0]
    6f62:	f003 02ff 	and.w	r2, r3, #255	; 0xff
    6f66:	b90b      	cbnz	r3, 6f6c <usb_serial_write+0x2c>
				{
					tx_noautoflush = 0;
    6f68:	7032      	strb	r2, [r6, #0]
    6f6a:	e015      	b.n	6f98 <usb_serial_write+0x58>
					return -1;
				}
				if ( usb_tx_packet_count( CDC_TX_ENDPOINT ) < TX_PACKET_LIMIT )
    6f6c:	2005      	movs	r0, #5
    6f6e:	f7ff f997 	bl	62a0 <usb_tx_packet_count>
    6f72:	2807      	cmp	r0, #7
    6f74:	d808      	bhi.n	6f88 <usb_serial_write+0x48>
				{
					tx_noautoflush = 1;
    6f76:	2301      	movs	r3, #1
    6f78:	7033      	strb	r3, [r6, #0]
					tx_packet = usb_malloc();
    6f7a:	f7ff ff6d 	bl	6e58 <usb_malloc>
    6f7e:	f8c9 0000 	str.w	r0, [r9]
					if ( tx_packet )
    6f82:	b980      	cbnz	r0, 6fa6 <usb_serial_write+0x66>
						break;
					tx_noautoflush = 0;
    6f84:	4b1d      	ldr	r3, [pc, #116]	; (6ffc <usb_serial_write+0xbc>)
    6f86:	7018      	strb	r0, [r3, #0]
				}
				if ( ++wait_count > TX_TIMEOUT || transmit_previous_timeout )
    6f88:	f1b8 0801 	subs.w	r8, r8, #1
    6f8c:	4b1e      	ldr	r3, [pc, #120]	; (7008 <usb_serial_write+0xc8>)
    6f8e:	d001      	beq.n	6f94 <usb_serial_write+0x54>
    6f90:	781a      	ldrb	r2, [r3, #0]
    6f92:	b12a      	cbz	r2, 6fa0 <usb_serial_write+0x60>
				{
					transmit_previous_timeout = 1;
    6f94:	2201      	movs	r2, #1
    6f96:	701a      	strb	r2, [r3, #0]
					return -1;
    6f98:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    6f9c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
				}
				yield();
    6fa0:	f7fb faf5 	bl	258e <yield>
			}
    6fa4:	e7db      	b.n	6f5e <usb_serial_write+0x1e>
		}
		transmit_previous_timeout = 0;
		len = CDC_TX_SIZE - tx_packet->index;
    6fa6:	6829      	ldr	r1, [r5, #0]
					return -1;
				}
				yield();
			}
		}
		transmit_previous_timeout = 0;
    6fa8:	4a17      	ldr	r2, [pc, #92]	; (7008 <usb_serial_write+0xc8>)
		len = CDC_TX_SIZE - tx_packet->index;
    6faa:	8848      	ldrh	r0, [r1, #2]
					return -1;
				}
				yield();
			}
		}
		transmit_previous_timeout = 0;
    6fac:	2300      	movs	r3, #0
    6fae:	7013      	strb	r3, [r2, #0]
		len = CDC_TX_SIZE - tx_packet->index;
    6fb0:	f1c0 0240 	rsb	r2, r0, #64	; 0x40
    6fb4:	4294      	cmp	r4, r2
    6fb6:	bf38      	it	cc
    6fb8:	4622      	movcc	r2, r4
		if ( len > size )
			len = size;
		dest = tx_packet->buf + tx_packet->index;
    6fba:	f100 0c08 	add.w	ip, r0, #8
		tx_packet->index += len;
    6fbe:	4410      	add	r0, r2
		}
		transmit_previous_timeout = 0;
		len = CDC_TX_SIZE - tx_packet->index;
		if ( len > size )
			len = size;
		dest = tx_packet->buf + tx_packet->index;
    6fc0:	448c      	add	ip, r1
		tx_packet->index += len;
    6fc2:	8048      	strh	r0, [r1, #2]
		size -= len;
    6fc4:	1aa4      	subs	r4, r4, r2
		while ( len-- > 0 )
    6fc6:	4293      	cmp	r3, r2
    6fc8:	d004      	beq.n	6fd4 <usb_serial_write+0x94>
			*dest++ = *src++;
    6fca:	5cf8      	ldrb	r0, [r7, r3]
    6fcc:	f80c 0003 	strb.w	r0, [ip, r3]
    6fd0:	3301      	adds	r3, #1
    6fd2:	e7f8      	b.n	6fc6 <usb_serial_write+0x86>
    6fd4:	441f      	add	r7, r3
		if ( tx_packet->index >= CDC_TX_SIZE )
    6fd6:	884b      	ldrh	r3, [r1, #2]
    6fd8:	2b3f      	cmp	r3, #63	; 0x3f
    6fda:	d906      	bls.n	6fea <usb_serial_write+0xaa>
		{
			tx_packet->len = CDC_TX_SIZE;
    6fdc:	2340      	movs	r3, #64	; 0x40
    6fde:	800b      	strh	r3, [r1, #0]
			usb_tx( CDC_TX_ENDPOINT, tx_packet );
    6fe0:	2005      	movs	r0, #5
    6fe2:	f7ff f9ab 	bl	633c <usb_tx>
			tx_packet = NULL;
    6fe6:	2300      	movs	r3, #0
    6fe8:	602b      	str	r3, [r5, #0]
		}
		usb_cdc_transmit_flush_timer = TRANSMIT_FLUSH_TIMEOUT;
    6fea:	4b08      	ldr	r3, [pc, #32]	; (700c <usb_serial_write+0xcc>)
    6fec:	2205      	movs	r2, #5
    6fee:	701a      	strb	r2, [r3, #0]
    6ff0:	e7ad      	b.n	6f4e <usb_serial_write+0xe>
	}
	tx_noautoflush = 0;
    6ff2:	7034      	strb	r4, [r6, #0]
	return 0;
    6ff4:	4620      	mov	r0, r4
}
    6ff6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    6ffa:	bf00      	nop
    6ffc:	1fff9623 	.word	0x1fff9623
    7000:	1fff9624 	.word	0x1fff9624
    7004:	1fff961f 	.word	0x1fff961f
    7008:	1fff9628 	.word	0x1fff9628
    700c:	1fff9622 	.word	0x1fff9622

00007010 <usb_serial_flush_callback>:
	}
	tx_noautoflush = 0;
}

void usb_serial_flush_callback()
{
    7010:	b538      	push	{r3, r4, r5, lr}
	if ( tx_noautoflush )
    7012:	4b0e      	ldr	r3, [pc, #56]	; (704c <usb_serial_flush_callback+0x3c>)
    7014:	781b      	ldrb	r3, [r3, #0]
    7016:	f003 05ff 	and.w	r5, r3, #255	; 0xff
    701a:	b9ab      	cbnz	r3, 7048 <usb_serial_flush_callback+0x38>
		return;
	if ( tx_packet )
    701c:	4c0c      	ldr	r4, [pc, #48]	; (7050 <usb_serial_flush_callback+0x40>)
    701e:	6821      	ldr	r1, [r4, #0]
    7020:	b131      	cbz	r1, 7030 <usb_serial_flush_callback+0x20>
	{
		tx_packet->len = tx_packet->index;
    7022:	884b      	ldrh	r3, [r1, #2]
		usb_tx( CDC_TX_ENDPOINT, tx_packet );
    7024:	2005      	movs	r0, #5
{
	if ( tx_noautoflush )
		return;
	if ( tx_packet )
	{
		tx_packet->len = tx_packet->index;
    7026:	800b      	strh	r3, [r1, #0]
		usb_tx( CDC_TX_ENDPOINT, tx_packet );
    7028:	f7ff f988 	bl	633c <usb_tx>
		tx_packet = NULL;
    702c:	6025      	str	r5, [r4, #0]
    702e:	bd38      	pop	{r3, r4, r5, pc}
	} else {
		usb_packet_t *tx = usb_malloc();
    7030:	f7ff ff12 	bl	6e58 <usb_malloc>
		if ( tx )
    7034:	4601      	mov	r1, r0
    7036:	b120      	cbz	r0, 7042 <usb_serial_flush_callback+0x32>
		{
			usb_tx( CDC_TX_ENDPOINT, tx );
    7038:	2005      	movs	r0, #5
		else
		{
			usb_cdc_transmit_flush_timer = 1;
		}
	}
}
    703a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		tx_packet = NULL;
	} else {
		usb_packet_t *tx = usb_malloc();
		if ( tx )
		{
			usb_tx( CDC_TX_ENDPOINT, tx );
    703e:	f7ff b97d 	b.w	633c <usb_tx>
		}
		else
		{
			usb_cdc_transmit_flush_timer = 1;
    7042:	4b04      	ldr	r3, [pc, #16]	; (7054 <usb_serial_flush_callback+0x44>)
    7044:	2201      	movs	r2, #1
    7046:	701a      	strb	r2, [r3, #0]
    7048:	bd38      	pop	{r3, r4, r5, pc}
    704a:	bf00      	nop
    704c:	1fff9623 	.word	0x1fff9623
    7050:	1fff9624 	.word	0x1fff9624
    7054:	1fff9622 	.word	0x1fff9622

00007058 <cliFunc_clear>:

// ----- CLI Command Functions -----

void cliFunc_clear( char* args)
{
	print("\033[2J\033[H\r"); // Erases the whole screen
    7058:	4801      	ldr	r0, [pc, #4]	; (7060 <cliFunc_clear+0x8>)
    705a:	f000 bbd3 	b.w	7804 <_print>
    705e:	bf00      	nop
    7060:	0000bc0d 	.word	0x0000bc0d

00007064 <cliFunc_reload>:
	CLILEDState ^= 1 << 1; // Toggle between 0 and 1
	errorLED( CLILEDState ); // Enable/Disable error LED
}

void cliFunc_reload( char* args )
{
    7064:	b508      	push	{r3, lr}
	if ( flashModeEnabled_define == 0 )
	{
		print( NL );
    7066:	4805      	ldr	r0, [pc, #20]	; (707c <cliFunc_reload+0x18>)
    7068:	f000 fbcc 	bl	7804 <_print>
		warn_print("flashModeEnabled not set, cancelling firmware reload...");
    706c:	4804      	ldr	r0, [pc, #16]	; (7080 <cliFunc_reload+0x1c>)
    706e:	f000 fbc9 	bl	7804 <_print>
		info_msg("Set flashModeEnabled to 1 in your kll configuration.");
    7072:	4804      	ldr	r0, [pc, #16]	; (7084 <cliFunc_reload+0x20>)
		return;
	}

	// Request to output module to be set into firmware reload mode
	Output_firmwareReload();
}
    7074:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
{
	if ( flashModeEnabled_define == 0 )
	{
		print( NL );
		warn_print("flashModeEnabled not set, cancelling firmware reload...");
		info_msg("Set flashModeEnabled to 1 in your kll configuration.");
    7078:	f000 bbc4 	b.w	7804 <_print>
    707c:	0000bafb 	.word	0x0000bafb
    7080:	00009481 	.word	0x00009481
    7084:	000094d0 	.word	0x000094d0

00007088 <cliFunc_reset>:
	Output_firmwareReload();
}

void cliFunc_reset( char* args )
{
	print("\033c"); // Resets the terminal
    7088:	4801      	ldr	r0, [pc, #4]	; (7090 <cliFunc_reset+0x8>)
    708a:	f000 bbbb 	b.w	7804 <_print>
    708e:	bf00      	nop
    7090:	0000bc16 	.word	0x0000bc16

00007094 <cliFunc_help>:
		CLIHexDebugMode = 1;
	}
}

void cliFunc_help( char* args )
{
    7094:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	// Scan array of dictionaries and print every description
	//  (no alphabetical here, too much processing/memory to sort...)
	for ( uint8_t dict = 0; dict < CLIDictionariesUsed; dict++ )
    7098:	2400      	movs	r4, #0
    709a:	4b21      	ldr	r3, [pc, #132]	; (7120 <cliFunc_help+0x8c>)
    709c:	781b      	ldrb	r3, [r3, #0]
    709e:	42a3      	cmp	r3, r4
    70a0:	d93c      	bls.n	711c <cliFunc_help+0x88>
	{
		// Print the name of each dictionary as a title
		print( NL "\033[1;32m" );
    70a2:	4820      	ldr	r0, [pc, #128]	; (7124 <cliFunc_help+0x90>)
    70a4:	f000 fbae 	bl	7804 <_print>
		_print( CLIDictNames[dict] ); // This print is requride by AVR (flash)
    70a8:	4b1f      	ldr	r3, [pc, #124]	; (7128 <cliFunc_help+0x94>)
    70aa:	f853 0024 	ldr.w	r0, [r3, r4, lsl #2]
    70ae:	f000 fba9 	bl	7804 <_print>
		print( "\033[0m" NL );
    70b2:	481e      	ldr	r0, [pc, #120]	; (712c <cliFunc_help+0x98>)
    70b4:	f000 fba6 	bl	7804 <_print>

		// Parse each cmd/description until a null command entry is found
		for ( uint8_t cmd = 0; CLIDict[dict][cmd].name != 0; cmd++ )
    70b8:	2700      	movs	r7, #0
    70ba:	b23b      	sxth	r3, r7
    70bc:	4e1c      	ldr	r6, [pc, #112]	; (7130 <cliFunc_help+0x9c>)
    70be:	009a      	lsls	r2, r3, #2
    70c0:	011d      	lsls	r5, r3, #4
    70c2:	1aad      	subs	r5, r5, r2
    70c4:	f856 3024 	ldr.w	r3, [r6, r4, lsl #2]
    70c8:	5959      	ldr	r1, [r3, r5]
    70ca:	b321      	cbz	r1, 7116 <cliFunc_help+0x82>
		{
			dPrintStrs(" \033[35m", CLIDict[dict][cmd].name, "\033[0m");
    70cc:	4819      	ldr	r0, [pc, #100]	; (7134 <cliFunc_help+0xa0>)
    70ce:	4a1a      	ldr	r2, [pc, #104]	; (7138 <cliFunc_help+0xa4>)
    70d0:	4b1a      	ldr	r3, [pc, #104]	; (713c <cliFunc_help+0xa8>)
    70d2:	f000 fb7d 	bl	77d0 <printstrs>

			// Determine number of spaces to tab by the length of the command and TabAlign
			uint8_t padLength = CLIEntryTabAlign - lenStr( (char*)CLIDict[dict][cmd].name );
    70d6:	f856 3024 	ldr.w	r3, [r6, r4, lsl #2]
    70da:	5958      	ldr	r0, [r3, r5]
    70dc:	f000 fb94 	bl	7808 <lenStr>
    70e0:	f1c0 000d 	rsb	r0, r0, #13
    70e4:	fa5f f880 	uxtb.w	r8, r0
			while ( padLength-- > 0 )
    70e8:	f1b8 0f00 	cmp.w	r8, #0
    70ec:	d007      	beq.n	70fe <cliFunc_help+0x6a>
				print(" ");
    70ee:	4814      	ldr	r0, [pc, #80]	; (7140 <cliFunc_help+0xac>)
    70f0:	f108 38ff 	add.w	r8, r8, #4294967295	; 0xffffffff
    70f4:	f000 fb86 	bl	7804 <_print>
    70f8:	fa5f f888 	uxtb.w	r8, r8
    70fc:	e7f4      	b.n	70e8 <cliFunc_help+0x54>

			_print( CLIDict[dict][cmd].description ); // This print is required by AVR (flash)
    70fe:	f856 3024 	ldr.w	r3, [r6, r4, lsl #2]
    7102:	441d      	add	r5, r3
		print( NL "\033[1;32m" );
		_print( CLIDictNames[dict] ); // This print is requride by AVR (flash)
		print( "\033[0m" NL );

		// Parse each cmd/description until a null command entry is found
		for ( uint8_t cmd = 0; CLIDict[dict][cmd].name != 0; cmd++ )
    7104:	3701      	adds	r7, #1
			// Determine number of spaces to tab by the length of the command and TabAlign
			uint8_t padLength = CLIEntryTabAlign - lenStr( (char*)CLIDict[dict][cmd].name );
			while ( padLength-- > 0 )
				print(" ");

			_print( CLIDict[dict][cmd].description ); // This print is required by AVR (flash)
    7106:	6868      	ldr	r0, [r5, #4]
    7108:	f000 fb7c 	bl	7804 <_print>
			print( NL );
    710c:	480d      	ldr	r0, [pc, #52]	; (7144 <cliFunc_help+0xb0>)
    710e:	f000 fb79 	bl	7804 <_print>
		print( NL "\033[1;32m" );
		_print( CLIDictNames[dict] ); // This print is requride by AVR (flash)
		print( "\033[0m" NL );

		// Parse each cmd/description until a null command entry is found
		for ( uint8_t cmd = 0; CLIDict[dict][cmd].name != 0; cmd++ )
    7112:	b2ff      	uxtb	r7, r7
    7114:	e7d1      	b.n	70ba <cliFunc_help+0x26>

void cliFunc_help( char* args )
{
	// Scan array of dictionaries and print every description
	//  (no alphabetical here, too much processing/memory to sort...)
	for ( uint8_t dict = 0; dict < CLIDictionariesUsed; dict++ )
    7116:	3401      	adds	r4, #1
    7118:	b2e4      	uxtb	r4, r4
    711a:	e7be      	b.n	709a <cliFunc_help+0x6>

			_print( CLIDict[dict][cmd].description ); // This print is required by AVR (flash)
			print( NL );
		}
	}
}
    711c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    7120:	1fff9637 	.word	0x1fff9637
    7124:	0000bc19 	.word	0x0000bc19
    7128:	1fff9ab4 	.word	0x1fff9ab4
    712c:	0000bc23 	.word	0x0000bc23
    7130:	1fff9a88 	.word	0x1fff9a88
    7134:	0000bc2a 	.word	0x0000bc2a
    7138:	000095df 	.word	0x000095df
    713c:	0000bb44 	.word	0x0000bb44
    7140:	00008156 	.word	0x00008156
    7144:	0000bafb 	.word	0x0000bafb

00007148 <cliFunc_led>:

void cliFunc_led( char* args )
{
	CLILEDState ^= 1 << 1; // Toggle between 0 and 1
    7148:	4b03      	ldr	r3, [pc, #12]	; (7158 <cliFunc_led+0x10>)
    714a:	7818      	ldrb	r0, [r3, #0]
    714c:	f080 0002 	eor.w	r0, r0, #2
    7150:	7018      	strb	r0, [r3, #0]
	errorLED( CLILEDState ); // Enable/Disable error LED
    7152:	f000 bb2f 	b.w	77b4 <errorLED>
    7156:	bf00      	nop
    7158:	1fff9636 	.word	0x1fff9636

0000715c <cliFunc_restart>:
}

void cliFunc_restart( char* args )
{
	// Trigger an overall software reset
	Output_softReset();
    715c:	f7ff b85c 	b.w	6218 <Output_softReset>

00007160 <cliFunc_version>:
}

void cliFunc_version( char* args )
{
    7160:	b508      	push	{r3, lr}
	print( NL );
    7162:	4821      	ldr	r0, [pc, #132]	; (71e8 <cliFunc_version+0x88>)
    7164:	f000 fb4e 	bl	7804 <_print>
	print( " \033[1mRevision:\033[0m      " CLI_Revision       NL );
    7168:	4820      	ldr	r0, [pc, #128]	; (71ec <cliFunc_version+0x8c>)
    716a:	f000 fb4b 	bl	7804 <_print>
	print( " \033[1mBranch:\033[0m        " CLI_Branch         NL );
    716e:	4820      	ldr	r0, [pc, #128]	; (71f0 <cliFunc_version+0x90>)
    7170:	f000 fb48 	bl	7804 <_print>
	print( " \033[1mTree Status:\033[0m   " CLI_ModifiedStatus CLI_ModifiedFiles NL );
    7174:	481f      	ldr	r0, [pc, #124]	; (71f4 <cliFunc_version+0x94>)
    7176:	f000 fb45 	bl	7804 <_print>
	print( " \033[1mRepo Origin:\033[0m   " CLI_RepoOrigin     NL );
    717a:	481f      	ldr	r0, [pc, #124]	; (71f8 <cliFunc_version+0x98>)
    717c:	f000 fb42 	bl	7804 <_print>
	print( " \033[1mCommit Date:\033[0m   " CLI_CommitDate     NL );
    7180:	481e      	ldr	r0, [pc, #120]	; (71fc <cliFunc_version+0x9c>)
    7182:	f000 fb3f 	bl	7804 <_print>
	print( " \033[1mCommit Author:\033[0m " CLI_CommitAuthor   NL );
    7186:	481e      	ldr	r0, [pc, #120]	; (7200 <cliFunc_version+0xa0>)
    7188:	f000 fb3c 	bl	7804 <_print>
	print( " \033[1mBuild Date:\033[0m    " CLI_BuildDate      NL );
    718c:	481d      	ldr	r0, [pc, #116]	; (7204 <cliFunc_version+0xa4>)
    718e:	f000 fb39 	bl	7804 <_print>
	print( " \033[1mBuild OS:\033[0m      " CLI_BuildOS        NL );
    7192:	481d      	ldr	r0, [pc, #116]	; (7208 <cliFunc_version+0xa8>)
    7194:	f000 fb36 	bl	7804 <_print>
	print( " \033[1mArchitecture:\033[0m  " CLI_Arch           NL );
    7198:	481c      	ldr	r0, [pc, #112]	; (720c <cliFunc_version+0xac>)
    719a:	f000 fb33 	bl	7804 <_print>
	print( " \033[1mChip:\033[0m          " CLI_Chip           NL );
    719e:	481c      	ldr	r0, [pc, #112]	; (7210 <cliFunc_version+0xb0>)
    71a0:	f000 fb30 	bl	7804 <_print>
	print( " \033[1mCPU:\033[0m           " CLI_CPU            NL );
    71a4:	481b      	ldr	r0, [pc, #108]	; (7214 <cliFunc_version+0xb4>)
    71a6:	f000 fb2d 	bl	7804 <_print>
	print( " \033[1mDevice:\033[0m        " CLI_Device         NL );
    71aa:	481b      	ldr	r0, [pc, #108]	; (7218 <cliFunc_version+0xb8>)
    71ac:	f000 fb2a 	bl	7804 <_print>
	print( " \033[1mModules:\033[0m       " CLI_Modules        NL );
    71b0:	481a      	ldr	r0, [pc, #104]	; (721c <cliFunc_version+0xbc>)
    71b2:	f000 fb27 	bl	7804 <_print>
#if defined(_mk20dx128_) || defined(_mk20dx128vlf5_) || defined(_mk20dx256_) || defined(_mk20dx256vlh7_)
	print( " \033[1mUnique Id:\033[0m     " );
    71b6:	481a      	ldr	r0, [pc, #104]	; (7220 <cliFunc_version+0xc0>)
    71b8:	f000 fb24 	bl	7804 <_print>
	printHex32_op( SIM_UIDH, 4 );
    71bc:	4b19      	ldr	r3, [pc, #100]	; (7224 <cliFunc_version+0xc4>)
    71be:	2104      	movs	r1, #4
    71c0:	6818      	ldr	r0, [r3, #0]
    71c2:	f000 fbdd 	bl	7980 <printHex32_op>
	printHex32_op( SIM_UIDMH, 4 );
    71c6:	4b18      	ldr	r3, [pc, #96]	; (7228 <cliFunc_version+0xc8>)
    71c8:	2104      	movs	r1, #4
    71ca:	6818      	ldr	r0, [r3, #0]
    71cc:	f000 fbd8 	bl	7980 <printHex32_op>
	printHex32_op( SIM_UIDML, 4 );
    71d0:	4b16      	ldr	r3, [pc, #88]	; (722c <cliFunc_version+0xcc>)
    71d2:	2104      	movs	r1, #4
    71d4:	6818      	ldr	r0, [r3, #0]
    71d6:	f000 fbd3 	bl	7980 <printHex32_op>
	printHex32_op( SIM_UIDL, 4 );
    71da:	4b15      	ldr	r3, [pc, #84]	; (7230 <cliFunc_version+0xd0>)
    71dc:	2104      	movs	r1, #4
    71de:	6818      	ldr	r0, [r3, #0]
#elif defined(_at90usb162_) || defined(_atmega32u4_) || defined(_at90usb646_) || defined(_at90usb1286_)
#else
#error "No unique id defined."
#endif
}
    71e0:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
#if defined(_mk20dx128_) || defined(_mk20dx128vlf5_) || defined(_mk20dx256_) || defined(_mk20dx256vlh7_)
	print( " \033[1mUnique Id:\033[0m     " );
	printHex32_op( SIM_UIDH, 4 );
	printHex32_op( SIM_UIDMH, 4 );
	printHex32_op( SIM_UIDML, 4 );
	printHex32_op( SIM_UIDL, 4 );
    71e4:	f000 bbcc 	b.w	7980 <printHex32_op>
    71e8:	0000bafb 	.word	0x0000bafb
    71ec:	0000bc31 	.word	0x0000bc31
    71f0:	0000bc74 	.word	0x0000bc74
    71f4:	0000bc95 	.word	0x0000bc95
    71f8:	0000bd79 	.word	0x0000bd79
    71fc:	0000bdbd 	.word	0x0000bdbd
    7200:	0000bdf1 	.word	0x0000bdf1
    7204:	0000be27 	.word	0x0000be27
    7208:	0000be5b 	.word	0x0000be5b
    720c:	0000be8d 	.word	0x0000be8d
    7210:	0000beab 	.word	0x0000beab
    7214:	0000bed3 	.word	0x0000bed3
    7218:	0000bef7 	.word	0x0000bef7
    721c:	0000bf1a 	.word	0x0000bf1a
    7220:	0000bf70 	.word	0x0000bf70
    7224:	40048054 	.word	0x40048054
    7228:	40048058 	.word	0x40048058
    722c:	4004805c 	.word	0x4004805c
    7230:	40048060 	.word	0x40048060

00007234 <cliFunc_cliDebug>:
{
	print("\033[2J\033[H\r"); // Erases the whole screen
}

void cliFunc_cliDebug( char* args )
{
    7234:	b510      	push	{r4, lr}
	// Toggle Hex Debug Mode
	if ( CLIHexDebugMode )
    7236:	4c09      	ldr	r4, [pc, #36]	; (725c <cliFunc_cliDebug+0x28>)
	{
		print( NL );
    7238:	4809      	ldr	r0, [pc, #36]	; (7260 <cliFunc_cliDebug+0x2c>)
}

void cliFunc_cliDebug( char* args )
{
	// Toggle Hex Debug Mode
	if ( CLIHexDebugMode )
    723a:	7823      	ldrb	r3, [r4, #0]
    723c:	b133      	cbz	r3, 724c <cliFunc_cliDebug+0x18>
	{
		print( NL );
    723e:	f000 fae1 	bl	7804 <_print>
		info_print("Hex debug mode disabled...");
    7242:	4808      	ldr	r0, [pc, #32]	; (7264 <cliFunc_cliDebug+0x30>)
    7244:	f000 fade 	bl	7804 <_print>
		CLIHexDebugMode = 0;
    7248:	2300      	movs	r3, #0
    724a:	e005      	b.n	7258 <cliFunc_cliDebug+0x24>
	}
	else
	{
		print( NL );
    724c:	f000 fada 	bl	7804 <_print>
		info_print("Hex debug mode enabled...");
    7250:	4805      	ldr	r0, [pc, #20]	; (7268 <cliFunc_cliDebug+0x34>)
    7252:	f000 fad7 	bl	7804 <_print>
		CLIHexDebugMode = 1;
    7256:	2301      	movs	r3, #1
    7258:	7023      	strb	r3, [r4, #0]
    725a:	bd10      	pop	{r4, pc}
    725c:	1fff9634 	.word	0x1fff9634
    7260:	0000bafb 	.word	0x0000bafb
    7264:	0000bf89 	.word	0x0000bf89
    7268:	0000bfb8 	.word	0x0000bfb8

0000726c <CLI_saveHistory.part.1>:
        while (*cursor == ' ') { cursor++; } // advance past the leading whitespace
        if (*cursor == '\0') { return ; }

	// Copy the line to the history
	int i;
	for (i = 0; i < CLILineBufferCurrent; i++)
    726c:	4b08      	ldr	r3, [pc, #32]	; (7290 <CLI_saveHistory.part.1+0x24>)
    726e:	781a      	ldrb	r2, [r3, #0]
	{
		CLIHistoryBuffer[ CLIHistoryTail ][ i ] = CLILineBuffer[ i ];
    7270:	4b08      	ldr	r3, [pc, #32]	; (7294 <CLI_saveHistory.part.1+0x28>)
    7272:	7818      	ldrb	r0, [r3, #0]
    7274:	4b08      	ldr	r3, [pc, #32]	; (7298 <CLI_saveHistory.part.1+0x2c>)
    7276:	2164      	movs	r1, #100	; 0x64
    7278:	fb00 3101 	mla	r1, r0, r1, r3
    727c:	2300      	movs	r3, #0
        while (*cursor == ' ') { cursor++; } // advance past the leading whitespace
        if (*cursor == '\0') { return ; }

	// Copy the line to the history
	int i;
	for (i = 0; i < CLILineBufferCurrent; i++)
    727e:	4293      	cmp	r3, r2
    7280:	da04      	bge.n	728c <CLI_saveHistory.part.1+0x20>
	{
		CLIHistoryBuffer[ CLIHistoryTail ][ i ] = CLILineBuffer[ i ];
    7282:	4806      	ldr	r0, [pc, #24]	; (729c <CLI_saveHistory.part.1+0x30>)
    7284:	5c18      	ldrb	r0, [r3, r0]
    7286:	54c8      	strb	r0, [r1, r3]
        while (*cursor == ' ') { cursor++; } // advance past the leading whitespace
        if (*cursor == '\0') { return ; }

	// Copy the line to the history
	int i;
	for (i = 0; i < CLILineBufferCurrent; i++)
    7288:	3301      	adds	r3, #1
    728a:	e7f8      	b.n	727e <CLI_saveHistory.part.1+0x12>
	{
		CLIHistoryBuffer[ CLIHistoryTail ][ i ] = CLILineBuffer[ i ];
	}
}
    728c:	4770      	bx	lr
    728e:	bf00      	nop
    7290:	1fff9adc 	.word	0x1fff9adc
    7294:	1fff9ab0 	.word	0x1fff9ab0
    7298:	1fff9638 	.word	0x1fff9638
    729c:	1fff9a20 	.word	0x1fff9a20

000072a0 <CLI_argumentIsolation>:
// Takes a string, returns two pointers
//  One to the first non-space character
//  The second to the next argument (first NULL if there isn't an argument). delimited by a space
//  Places a NULL at the first space after the first argument
void CLI_argumentIsolation( char* string, char** first, char** second )
{
    72a0:	b530      	push	{r4, r5, lr}
	// Mark out the first argument
	// This is done by finding the first space after a list of non-spaces and setting it NULL
	char* cmdPtr = string - 1;
	while ( *++cmdPtr == ' ' ); // Skips leading spaces, and points to first character of cmd
    72a2:	4604      	mov	r4, r0
    72a4:	3001      	adds	r0, #1
    72a6:	7823      	ldrb	r3, [r4, #0]
    72a8:	2b20      	cmp	r3, #32
    72aa:	d0fa      	beq.n	72a2 <CLI_argumentIsolation+0x2>
    72ac:	4603      	mov	r3, r0
    72ae:	3001      	adds	r0, #1

	// Locates first space delimiter
	char* argPtr = cmdPtr + 1;
	while ( *argPtr != ' ' && *argPtr != '\0' )
    72b0:	781d      	ldrb	r5, [r3, #0]
    72b2:	f015 05df 	ands.w	r5, r5, #223	; 0xdf
    72b6:	d1f9      	bne.n	72ac <CLI_argumentIsolation+0xc>
		argPtr++;

	// Point to the first character of args or a NULL (no args) and set the space delimiter as a NULL
	(++argPtr)[-1] = '\0';
    72b8:	f803 5b01 	strb.w	r5, [r3], #1

	// Set return variables
	*first = cmdPtr;
    72bc:	600c      	str	r4, [r1, #0]
	*second = argPtr;
    72be:	6013      	str	r3, [r2, #0]
    72c0:	bd30      	pop	{r4, r5, pc}
    72c2:	0000      	movs	r0, r0

000072c4 <CLI_commandLookup>:
}

// Scans the CLILineBuffer for any valid commands
void CLI_commandLookup()
{
    72c4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	// Ignore command if buffer is 0 length
	if ( CLILineBufferCurrent == 0 )
    72c8:	4b22      	ldr	r3, [pc, #136]	; (7354 <CLI_commandLookup+0x90>)
    72ca:	781b      	ldrb	r3, [r3, #0]
	*second = argPtr;
}

// Scans the CLILineBuffer for any valid commands
void CLI_commandLookup()
{
    72cc:	b088      	sub	sp, #32
	// Ignore command if buffer is 0 length
	if ( CLILineBufferCurrent == 0 )
    72ce:	2b00      	cmp	r3, #0
    72d0:	d03d      	beq.n	734e <CLI_commandLookup+0x8a>
		return;

	// Set the last+1 character of the buffer to NULL for string processing
	CLILineBuffer[CLILineBufferCurrent] = '\0';
    72d2:	4d21      	ldr	r5, [pc, #132]	; (7358 <CLI_commandLookup+0x94>)
    72d4:	2400      	movs	r4, #0

	// Retrieve pointers to command and beginning of arguments
	// Places a NULL at the first space after the command
	char* cmdPtr;
	char* argPtr;
	CLI_argumentIsolation( CLILineBuffer, &cmdPtr, &argPtr );
    72d6:	4628      	mov	r0, r5
    72d8:	a906      	add	r1, sp, #24
    72da:	aa07      	add	r2, sp, #28
	// Ignore command if buffer is 0 length
	if ( CLILineBufferCurrent == 0 )
		return;

	// Set the last+1 character of the buffer to NULL for string processing
	CLILineBuffer[CLILineBufferCurrent] = '\0';
    72dc:	54ec      	strb	r4, [r5, r3]

	// Retrieve pointers to command and beginning of arguments
	// Places a NULL at the first space after the command
	char* cmdPtr;
	char* argPtr;
	CLI_argumentIsolation( CLILineBuffer, &cmdPtr, &argPtr );
    72de:	f7ff ffdf 	bl	72a0 <CLI_argumentIsolation>
    72e2:	46a8      	mov	r8, r5

	// Scan array of dictionaries for a valid command match
	for ( uint8_t dict = 0; dict < CLIDictionariesUsed; dict++ )
    72e4:	4b1d      	ldr	r3, [pc, #116]	; (735c <CLI_commandLookup+0x98>)
    72e6:	781b      	ldrb	r3, [r3, #0]
    72e8:	42a3      	cmp	r3, r4
    72ea:	d91b      	bls.n	7324 <CLI_commandLookup+0x60>
    72ec:	2600      	movs	r6, #0
	{
		// Parse each cmd until a null command entry is found, or an argument match
		for ( uint8_t cmd = 0; CLIDict[dict][cmd].name != 0; cmd++ )
    72ee:	b233      	sxth	r3, r6
    72f0:	4d1b      	ldr	r5, [pc, #108]	; (7360 <CLI_commandLookup+0x9c>)
    72f2:	009a      	lsls	r2, r3, #2
    72f4:	011f      	lsls	r7, r3, #4
    72f6:	1abf      	subs	r7, r7, r2
    72f8:	f855 3024 	ldr.w	r3, [r5, r4, lsl #2]
    72fc:	59d9      	ldr	r1, [r3, r7]
    72fe:	b171      	cbz	r1, 731e <CLI_commandLookup+0x5a>
		{
			// Compare the first argument and each command entry
			if ( eqStr( cmdPtr, (char*)CLIDict[dict][cmd].name ) == -1 )
    7300:	9806      	ldr	r0, [sp, #24]
    7302:	f000 fb48 	bl	7996 <eqStr>
    7306:	3001      	adds	r0, #1
    7308:	d106      	bne.n	7318 <CLI_commandLookup+0x54>
			{
				// Run the specified command function pointer
				//   argPtr is already pointing at the first character of the arguments
				(*(void (*)(char*))CLIDict[dict][cmd].function)( argPtr );
    730a:	f855 3024 	ldr.w	r3, [r5, r4, lsl #2]
    730e:	9807      	ldr	r0, [sp, #28]
    7310:	441f      	add	r7, r3
    7312:	68bb      	ldr	r3, [r7, #8]
    7314:	4798      	blx	r3

				return;
    7316:	e01a      	b.n	734e <CLI_commandLookup+0x8a>

	// Scan array of dictionaries for a valid command match
	for ( uint8_t dict = 0; dict < CLIDictionariesUsed; dict++ )
	{
		// Parse each cmd until a null command entry is found, or an argument match
		for ( uint8_t cmd = 0; CLIDict[dict][cmd].name != 0; cmd++ )
    7318:	3601      	adds	r6, #1
    731a:	b2f6      	uxtb	r6, r6
    731c:	e7e7      	b.n	72ee <CLI_commandLookup+0x2a>
	char* cmdPtr;
	char* argPtr;
	CLI_argumentIsolation( CLILineBuffer, &cmdPtr, &argPtr );

	// Scan array of dictionaries for a valid command match
	for ( uint8_t dict = 0; dict < CLIDictionariesUsed; dict++ )
    731e:	3401      	adds	r4, #1
    7320:	b2e4      	uxtb	r4, r4
    7322:	e7df      	b.n	72e4 <CLI_commandLookup+0x20>
			}
		}
	}

	// No match for the command...
	print( NL );
    7324:	4c0f      	ldr	r4, [pc, #60]	; (7364 <CLI_commandLookup+0xa0>)
    7326:	4620      	mov	r0, r4
    7328:	f000 fa6c 	bl	7804 <_print>
	erro_dPrint("\"", CLILineBuffer, "\" is not a valid command...type \033[35mhelp\033[0m");
    732c:	4b0e      	ldr	r3, [pc, #56]	; (7368 <CLI_commandLookup+0xa4>)
    732e:	f8cd 8008 	str.w	r8, [sp, #8]
    7332:	9300      	str	r3, [sp, #0]
    7334:	4b0d      	ldr	r3, [pc, #52]	; (736c <CLI_commandLookup+0xa8>)
    7336:	9404      	str	r4, [sp, #16]
    7338:	9301      	str	r3, [sp, #4]
    733a:	4b0d      	ldr	r3, [pc, #52]	; (7370 <CLI_commandLookup+0xac>)
    733c:	480d      	ldr	r0, [pc, #52]	; (7374 <CLI_commandLookup+0xb0>)
    733e:	9303      	str	r3, [sp, #12]
    7340:	4b0d      	ldr	r3, [pc, #52]	; (7378 <CLI_commandLookup+0xb4>)
    7342:	490e      	ldr	r1, [pc, #56]	; (737c <CLI_commandLookup+0xb8>)
    7344:	9305      	str	r3, [sp, #20]
    7346:	4a0e      	ldr	r2, [pc, #56]	; (7380 <CLI_commandLookup+0xbc>)
    7348:	4b0e      	ldr	r3, [pc, #56]	; (7384 <CLI_commandLookup+0xc0>)
    734a:	f000 fa41 	bl	77d0 <printstrs>
}
    734e:	b008      	add	sp, #32
    7350:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    7354:	1fff9adc 	.word	0x1fff9adc
    7358:	1fff9a20 	.word	0x1fff9a20
    735c:	1fff9637 	.word	0x1fff9637
    7360:	1fff9a88 	.word	0x1fff9a88
    7364:	0000bafb 	.word	0x0000bafb
    7368:	00008fb8 	.word	0x00008fb8
    736c:	0000bff6 	.word	0x0000bff6
    7370:	0000bff8 	.word	0x0000bff8
    7374:	0000bfe6 	.word	0x0000bfe6
    7378:	0000bb44 	.word	0x0000bb44
    737c:	0000bfe9 	.word	0x0000bfe9
    7380:	000095e2 	.word	0x000095e2
    7384:	0000bff0 	.word	0x0000bff0

00007388 <CLI_registerDictionary>:

// Registers a command dictionary with the CLI
void CLI_registerDictionary( const CLIDictItem *cmdDict, const char* dictName )
{
    7388:	b510      	push	{r4, lr}
	// Make sure this max limit of dictionaries hasn't been reached
	if ( CLIDictionariesUsed >= CLIMaxDictionaries )
    738a:	4a09      	ldr	r2, [pc, #36]	; (73b0 <CLI_registerDictionary+0x28>)
    738c:	7813      	ldrb	r3, [r2, #0]
    738e:	2b09      	cmp	r3, #9
    7390:	d904      	bls.n	739c <CLI_registerDictionary+0x14>
	{
		erro_print("Max number of dictionaries defined already...");
    7392:	4808      	ldr	r0, [pc, #32]	; (73b4 <CLI_registerDictionary+0x2c>)
	}

	// Add dictionary
	CLIDictNames[CLIDictionariesUsed] = (char*)dictName;
	CLIDict[CLIDictionariesUsed++] = (CLIDictItem*)cmdDict;
}
    7394:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
void CLI_registerDictionary( const CLIDictItem *cmdDict, const char* dictName )
{
	// Make sure this max limit of dictionaries hasn't been reached
	if ( CLIDictionariesUsed >= CLIMaxDictionaries )
	{
		erro_print("Max number of dictionaries defined already...");
    7398:	f000 ba34 	b.w	7804 <_print>
		return;
	}

	// Add dictionary
	CLIDictNames[CLIDictionariesUsed] = (char*)dictName;
    739c:	4c06      	ldr	r4, [pc, #24]	; (73b8 <CLI_registerDictionary+0x30>)
    739e:	f844 1023 	str.w	r1, [r4, r3, lsl #2]
	CLIDict[CLIDictionariesUsed++] = (CLIDictItem*)cmdDict;
    73a2:	1c59      	adds	r1, r3, #1
    73a4:	7011      	strb	r1, [r2, #0]
    73a6:	4a05      	ldr	r2, [pc, #20]	; (73bc <CLI_registerDictionary+0x34>)
    73a8:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
    73ac:	bd10      	pop	{r4, pc}
    73ae:	bf00      	nop
    73b0:	1fff9637 	.word	0x1fff9637
    73b4:	0000c026 	.word	0x0000c026
    73b8:	1fff9ab4 	.word	0x1fff9ab4
    73bc:	1fff9a88 	.word	0x1fff9a88

000073c0 <CLI_init>:

// Initialize the CLI
inline void CLI_init()
{
	// Reset the Line Buffer
	CLILineBufferCurrent = 0;
    73c0:	4b0e      	ldr	r3, [pc, #56]	; (73fc <CLI_init+0x3c>)

// ----- Functions -----

inline void prompt()
{
	print("\033[2K\r"); // Erases the current line and resets cursor to beginning of line
    73c2:	480f      	ldr	r0, [pc, #60]	; (7400 <CLI_init+0x40>)
	print("\033[1;34m:\033[0m "); // Blue bold prompt
}

// Initialize the CLI
inline void CLI_init()
{
    73c4:	b510      	push	{r4, lr}
	// Reset the Line Buffer
	CLILineBufferCurrent = 0;
    73c6:	2400      	movs	r4, #0
    73c8:	701c      	strb	r4, [r3, #0]

	// History starts empty
	CLIHistoryHead = 0;
    73ca:	4b0e      	ldr	r3, [pc, #56]	; (7404 <CLI_init+0x44>)
    73cc:	701c      	strb	r4, [r3, #0]
	CLIHistoryCurrent = 0;
    73ce:	4b0e      	ldr	r3, [pc, #56]	; (7408 <CLI_init+0x48>)
    73d0:	701c      	strb	r4, [r3, #0]
	CLIHistoryTail = 0;
    73d2:	4b0e      	ldr	r3, [pc, #56]	; (740c <CLI_init+0x4c>)
    73d4:	701c      	strb	r4, [r3, #0]

// ----- Functions -----

inline void prompt()
{
	print("\033[2K\r"); // Erases the current line and resets cursor to beginning of line
    73d6:	f000 fa15 	bl	7804 <_print>
	print("\033[1;34m:\033[0m "); // Blue bold prompt
    73da:	480d      	ldr	r0, [pc, #52]	; (7410 <CLI_init+0x50>)
    73dc:	f000 fa12 	bl	7804 <_print>

	// Set prompt
	prompt();

	// Register first dictionary
	CLIDictionariesUsed = 0;
    73e0:	4b0c      	ldr	r3, [pc, #48]	; (7414 <CLI_init+0x54>)
	CLI_registerDictionary( basicCLIDict, basicCLIDictName );
    73e2:	480d      	ldr	r0, [pc, #52]	; (7418 <CLI_init+0x58>)
    73e4:	490d      	ldr	r1, [pc, #52]	; (741c <CLI_init+0x5c>)

	// Set prompt
	prompt();

	// Register first dictionary
	CLIDictionariesUsed = 0;
    73e6:	701c      	strb	r4, [r3, #0]
	CLI_registerDictionary( basicCLIDict, basicCLIDictName );
    73e8:	f7ff ffce 	bl	7388 <CLI_registerDictionary>

	// Initialize main LED
	init_errorLED();
    73ec:	f000 f9d4 	bl	7798 <init_errorLED>
	CLILEDState = 0;
    73f0:	4b0b      	ldr	r3, [pc, #44]	; (7420 <CLI_init+0x60>)
    73f2:	701c      	strb	r4, [r3, #0]

	// Hex debug mode is off by default
	CLIHexDebugMode = 0;
    73f4:	4b0b      	ldr	r3, [pc, #44]	; (7424 <CLI_init+0x64>)
    73f6:	701c      	strb	r4, [r3, #0]
    73f8:	bd10      	pop	{r4, pc}
    73fa:	bf00      	nop
    73fc:	1fff9adc 	.word	0x1fff9adc
    7400:	0000c06b 	.word	0x0000c06b
    7404:	1fff9a85 	.word	0x1fff9a85
    7408:	1fff9635 	.word	0x1fff9635
    740c:	1fff9ab0 	.word	0x1fff9ab0
    7410:	0000c071 	.word	0x0000c071
    7414:	1fff9637 	.word	0x1fff9637
    7418:	0000c14c 	.word	0x0000c14c
    741c:	0000c24e 	.word	0x0000c24e
    7420:	1fff9636 	.word	0x1fff9636
    7424:	1fff9634 	.word	0x1fff9634

00007428 <CLI_tabCompletion>:
	CLIDictNames[CLIDictionariesUsed] = (char*)dictName;
	CLIDict[CLIDictionariesUsed++] = (CLIDictItem*)cmdDict;
}

inline void CLI_tabCompletion()
{
    7428:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	// Ignore command if buffer is 0 length
	if ( CLILineBufferCurrent == 0 )
    742c:	4d28      	ldr	r5, [pc, #160]	; (74d0 <CLI_tabCompletion+0xa8>)
    742e:	782b      	ldrb	r3, [r5, #0]
    7430:	2b00      	cmp	r3, #0
    7432:	d049      	beq.n	74c8 <CLI_tabCompletion+0xa0>
		return;

	// Set the last+1 character of the buffer to NULL for string processing
	CLILineBuffer[CLILineBufferCurrent] = '\0';
    7434:	4f27      	ldr	r7, [pc, #156]	; (74d4 <CLI_tabCompletion+0xac>)
    7436:	2400      	movs	r4, #0

	// Retrieve pointers to command and beginning of arguments
	// Places a NULL at the first space after the command
	char* cmdPtr;
	char* argPtr;
	CLI_argumentIsolation( CLILineBuffer, &cmdPtr, &argPtr );
    7438:	4638      	mov	r0, r7
    743a:	4669      	mov	r1, sp
    743c:	aa01      	add	r2, sp, #4
	// Ignore command if buffer is 0 length
	if ( CLILineBufferCurrent == 0 )
		return;

	// Set the last+1 character of the buffer to NULL for string processing
	CLILineBuffer[CLILineBufferCurrent] = '\0';
    743e:	54fc      	strb	r4, [r7, r3]

	// Retrieve pointers to command and beginning of arguments
	// Places a NULL at the first space after the command
	char* cmdPtr;
	char* argPtr;
	CLI_argumentIsolation( CLILineBuffer, &cmdPtr, &argPtr );
    7440:	f7ff ff2e 	bl	72a0 <CLI_argumentIsolation>

	// Tab match pointer
	char* tabMatch = 0;
	uint8_t matches = 0;
    7444:	46a0      	mov	r8, r4
	char* cmdPtr;
	char* argPtr;
	CLI_argumentIsolation( CLILineBuffer, &cmdPtr, &argPtr );

	// Tab match pointer
	char* tabMatch = 0;
    7446:	4626      	mov	r6, r4
	uint8_t matches = 0;

	// Scan array of dictionaries for a valid command match
	for ( uint8_t dict = 0; dict < CLIDictionariesUsed; dict++ )
    7448:	4b23      	ldr	r3, [pc, #140]	; (74d8 <CLI_tabCompletion+0xb0>)
    744a:	781b      	ldrb	r3, [r3, #0]
    744c:	42a3      	cmp	r3, r4
    744e:	d923      	bls.n	7498 <CLI_tabCompletion+0x70>
    7450:	f04f 0900 	mov.w	r9, #0
	{
		// Parse each cmd until a null command entry is found, or an argument match
		for ( uint8_t cmd = 0; CLIDict[dict][cmd].name != 0; cmd++ )
    7454:	fa0f f389 	sxth.w	r3, r9
    7458:	f8df b088 	ldr.w	fp, [pc, #136]	; 74e4 <CLI_tabCompletion+0xbc>
    745c:	009a      	lsls	r2, r3, #2
    745e:	ea4f 1a03 	mov.w	sl, r3, lsl #4
    7462:	ebc2 0a0a 	rsb	sl, r2, sl
    7466:	f85b 3024 	ldr.w	r3, [fp, r4, lsl #2]
    746a:	f853 100a 	ldr.w	r1, [r3, sl]
    746e:	b181      	cbz	r1, 7492 <CLI_tabCompletion+0x6a>
		{
			// Compare the first argument piece to each command entry to see if it is "like"
			// NOTE: To save on processing, we only care about the commands and ignore the arguments
			//       If there are arguments, and a valid tab match is found, buffer is cleared (args lost)
			//       Also ignores full matches
			if ( eqStr( cmdPtr, (char*)CLIDict[dict][cmd].name ) == 0 )
    7470:	9800      	ldr	r0, [sp, #0]
    7472:	f000 fa90 	bl	7996 <eqStr>
    7476:	b938      	cbnz	r0, 7488 <CLI_tabCompletion+0x60>
			{
				// TODO Make list of commands if multiple matches
				matches++;
				tabMatch = (char*)CLIDict[dict][cmd].name;
    7478:	f85b 3024 	ldr.w	r3, [fp, r4, lsl #2]
			//       If there are arguments, and a valid tab match is found, buffer is cleared (args lost)
			//       Also ignores full matches
			if ( eqStr( cmdPtr, (char*)CLIDict[dict][cmd].name ) == 0 )
			{
				// TODO Make list of commands if multiple matches
				matches++;
    747c:	f108 0801 	add.w	r8, r8, #1
				tabMatch = (char*)CLIDict[dict][cmd].name;
    7480:	f853 600a 	ldr.w	r6, [r3, sl]
			//       If there are arguments, and a valid tab match is found, buffer is cleared (args lost)
			//       Also ignores full matches
			if ( eqStr( cmdPtr, (char*)CLIDict[dict][cmd].name ) == 0 )
			{
				// TODO Make list of commands if multiple matches
				matches++;
    7484:	fa5f f888 	uxtb.w	r8, r8

	// Scan array of dictionaries for a valid command match
	for ( uint8_t dict = 0; dict < CLIDictionariesUsed; dict++ )
	{
		// Parse each cmd until a null command entry is found, or an argument match
		for ( uint8_t cmd = 0; CLIDict[dict][cmd].name != 0; cmd++ )
    7488:	f109 0901 	add.w	r9, r9, #1
    748c:	fa5f f989 	uxtb.w	r9, r9
    7490:	e7e0      	b.n	7454 <CLI_tabCompletion+0x2c>
	// Tab match pointer
	char* tabMatch = 0;
	uint8_t matches = 0;

	// Scan array of dictionaries for a valid command match
	for ( uint8_t dict = 0; dict < CLIDictionariesUsed; dict++ )
    7492:	3401      	adds	r4, #1
    7494:	b2e4      	uxtb	r4, r4
    7496:	e7d7      	b.n	7448 <CLI_tabCompletion+0x20>
			}
		}
	}

	// Only tab complete if there was 1 match
	if ( matches == 1 )
    7498:	f1b8 0f01 	cmp.w	r8, #1
    749c:	d114      	bne.n	74c8 <CLI_tabCompletion+0xa0>
	{
		// Reset the buffer
		CLILineBufferCurrent = 0;
    749e:	2300      	movs	r3, #0

// ----- Functions -----

inline void prompt()
{
	print("\033[2K\r"); // Erases the current line and resets cursor to beginning of line
    74a0:	480e      	ldr	r0, [pc, #56]	; (74dc <CLI_tabCompletion+0xb4>)

	// Only tab complete if there was 1 match
	if ( matches == 1 )
	{
		// Reset the buffer
		CLILineBufferCurrent = 0;
    74a2:	702b      	strb	r3, [r5, #0]

// ----- Functions -----

inline void prompt()
{
	print("\033[2K\r"); // Erases the current line and resets cursor to beginning of line
    74a4:	f000 f9ae 	bl	7804 <_print>
	print("\033[1;34m:\033[0m "); // Blue bold prompt
    74a8:	480d      	ldr	r0, [pc, #52]	; (74e0 <CLI_tabCompletion+0xb8>)
    74aa:	f000 f9ab 	bl	7804 <_print>

		// Reprint the prompt (automatically clears the line)
		prompt();

		// Display the command
		dPrint( tabMatch );
    74ae:	4630      	mov	r0, r6
    74b0:	f7fe feaa 	bl	6208 <Output_putstr>

		// There are no index counts, so just copy the whole string to the input buffer
		while ( *tabMatch != '\0' )
    74b4:	f816 3b01 	ldrb.w	r3, [r6], #1
    74b8:	b133      	cbz	r3, 74c8 <CLI_tabCompletion+0xa0>
		{
			CLILineBuffer[CLILineBufferCurrent++] = *tabMatch++;
    74ba:	782b      	ldrb	r3, [r5, #0]
    74bc:	1c5a      	adds	r2, r3, #1
    74be:	702a      	strb	r2, [r5, #0]
    74c0:	f816 2c01 	ldrb.w	r2, [r6, #-1]
    74c4:	54fa      	strb	r2, [r7, r3]
    74c6:	e7f5      	b.n	74b4 <CLI_tabCompletion+0x8c>
		}
	}
}
    74c8:	b003      	add	sp, #12
    74ca:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    74ce:	bf00      	nop
    74d0:	1fff9adc 	.word	0x1fff9adc
    74d4:	1fff9a20 	.word	0x1fff9a20
    74d8:	1fff9637 	.word	0x1fff9637
    74dc:	0000c06b 	.word	0x0000c06b
    74e0:	0000c071 	.word	0x0000c071
    74e4:	1fff9a88 	.word	0x1fff9a88

000074e8 <CLI_wrap>:

inline int CLI_wrap( int kX, int const kLowerBound, int const kUpperBound )
{
	int range_size = kUpperBound - kLowerBound + 1;
    74e8:	1a52      	subs	r2, r2, r1

	if ( kX < kLowerBound )
    74ea:	4288      	cmp	r0, r1
	}
}

inline int CLI_wrap( int kX, int const kLowerBound, int const kUpperBound )
{
	int range_size = kUpperBound - kLowerBound + 1;
    74ec:	f102 0201 	add.w	r2, r2, #1

	if ( kX < kLowerBound )
    74f0:	da05      	bge.n	74fe <CLI_wrap+0x16>
		kX += range_size * ((kLowerBound - kX) / range_size + 1);
    74f2:	1a0b      	subs	r3, r1, r0
    74f4:	fb93 f3f2 	sdiv	r3, r3, r2
    74f8:	3301      	adds	r3, #1
    74fa:	fb03 0002 	mla	r0, r3, r2, r0

	return kLowerBound + (kX - kLowerBound) % range_size;
    74fe:	1a40      	subs	r0, r0, r1
    7500:	fb90 f3f2 	sdiv	r3, r0, r2
    7504:	fb02 0013 	mls	r0, r2, r3, r0
}
    7508:	4408      	add	r0, r1
    750a:	4770      	bx	lr

0000750c <CLI_saveHistory>:

inline void CLI_saveHistory( char *buff )
{
	if ( buff == NULL )
    750c:	b108      	cbz	r0, 7512 <CLI_saveHistory+0x6>
    750e:	3801      	subs	r0, #1
    7510:	e006      	b.n	7520 <CLI_saveHistory+0x14>
	{
		//clear the item
		CLIHistoryBuffer[ CLIHistoryTail ][ 0 ] = '\0';
    7512:	4b07      	ldr	r3, [pc, #28]	; (7530 <CLI_saveHistory+0x24>)
    7514:	781b      	ldrb	r3, [r3, #0]
    7516:	2264      	movs	r2, #100	; 0x64
    7518:	4353      	muls	r3, r2
    751a:	4a06      	ldr	r2, [pc, #24]	; (7534 <CLI_saveHistory+0x28>)
    751c:	54d0      	strb	r0, [r2, r3]
		return;
    751e:	4770      	bx	lr
	}

        // Don't write empty lines to the history
        const char *cursor = buff;
        while (*cursor == ' ') { cursor++; } // advance past the leading whitespace
    7520:	f810 3f01 	ldrb.w	r3, [r0, #1]!
    7524:	2b20      	cmp	r3, #32
    7526:	d0fb      	beq.n	7520 <CLI_saveHistory+0x14>
        if (*cursor == '\0') { return ; }
    7528:	b10b      	cbz	r3, 752e <CLI_saveHistory+0x22>
    752a:	f7ff be9f 	b.w	726c <CLI_saveHistory.part.1>
    752e:	4770      	bx	lr
    7530:	1fff9ab0 	.word	0x1fff9ab0
    7534:	1fff9638 	.word	0x1fff9638

00007538 <CLI_retreiveHistory>:
	}
}

void CLI_retreiveHistory( int index )
{
	char *histMatch = CLIHistoryBuffer[ index ];
    7538:	4b0d      	ldr	r3, [pc, #52]	; (7570 <CLI_retreiveHistory+0x38>)
		CLIHistoryBuffer[ CLIHistoryTail ][ i ] = CLILineBuffer[ i ];
	}
}

void CLI_retreiveHistory( int index )
{
    753a:	b570      	push	{r4, r5, r6, lr}
	char *histMatch = CLIHistoryBuffer[ index ];
    753c:	2464      	movs	r4, #100	; 0x64

	// Reset the buffer
	CLILineBufferCurrent = 0;
    753e:	4d0d      	ldr	r5, [pc, #52]	; (7574 <CLI_retreiveHistory+0x3c>)
	}
}

void CLI_retreiveHistory( int index )
{
	char *histMatch = CLIHistoryBuffer[ index ];
    7540:	fb04 3400 	mla	r4, r4, r0, r3

	// Reset the buffer
	CLILineBufferCurrent = 0;
    7544:	2600      	movs	r6, #0

// ----- Functions -----

inline void prompt()
{
	print("\033[2K\r"); // Erases the current line and resets cursor to beginning of line
    7546:	480c      	ldr	r0, [pc, #48]	; (7578 <CLI_retreiveHistory+0x40>)
void CLI_retreiveHistory( int index )
{
	char *histMatch = CLIHistoryBuffer[ index ];

	// Reset the buffer
	CLILineBufferCurrent = 0;
    7548:	702e      	strb	r6, [r5, #0]

// ----- Functions -----

inline void prompt()
{
	print("\033[2K\r"); // Erases the current line and resets cursor to beginning of line
    754a:	f000 f95b 	bl	7804 <_print>
	print("\033[1;34m:\033[0m "); // Blue bold prompt
    754e:	480b      	ldr	r0, [pc, #44]	; (757c <CLI_retreiveHistory+0x44>)
    7550:	f000 f958 	bl	7804 <_print>

	// Reprint the prompt (automatically clears the line)
	prompt();

	// Display the command
	dPrint( histMatch );
    7554:	4620      	mov	r0, r4
    7556:	f7fe fe57 	bl	6208 <Output_putstr>

	// There are no index counts, so just copy the whole string to the input buffe
	CLILineBufferCurrent = 0;
	while ( *histMatch != '\0' )
    755a:	4633      	mov	r3, r6
    755c:	b2da      	uxtb	r2, r3
    755e:	1c59      	adds	r1, r3, #1
    7560:	5ce3      	ldrb	r3, [r4, r3]
    7562:	b11b      	cbz	r3, 756c <CLI_retreiveHistory+0x34>
	{
		CLILineBuffer[ CLILineBufferCurrent++ ] = *histMatch++;
    7564:	4806      	ldr	r0, [pc, #24]	; (7580 <CLI_retreiveHistory+0x48>)
    7566:	5483      	strb	r3, [r0, r2]
    7568:	460b      	mov	r3, r1
    756a:	e7f7      	b.n	755c <CLI_retreiveHistory+0x24>
    756c:	702a      	strb	r2, [r5, #0]
    756e:	bd70      	pop	{r4, r5, r6, pc}
    7570:	1fff9638 	.word	0x1fff9638
    7574:	1fff9adc 	.word	0x1fff9adc
    7578:	0000c06b 	.word	0x0000c06b
    757c:	0000c071 	.word	0x0000c071
    7580:	1fff9a20 	.word	0x1fff9a20

00007584 <CLI_process>:
	CLIHexDebugMode = 0;
}

// Query the serial input buffer for any new characters
void CLI_process()
{
    7584:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	// Current buffer position
	uint8_t prev_buf_pos = CLILineBufferCurrent;
    7586:	4d74      	ldr	r5, [pc, #464]	; (7758 <CLI_process+0x1d4>)
    7588:	782c      	ldrb	r4, [r5, #0]

	// Process each character while available
	while ( 1 )
	{
		// No more characters to process
		if ( Output_availablechar() == 0 )
    758a:	f7fe fe39 	bl	6200 <Output_availablechar>
    758e:	b1a0      	cbz	r0, 75ba <CLI_process+0x36>
			break;

		// Retrieve from output module
		char cur_char = (char)Output_getchar();
    7590:	f7fe fe38 	bl	6204 <Output_getchar>

		// Make sure buffer isn't full
		if ( CLILineBufferCurrent >= CLILineBufferMaxSize )
    7594:	782b      	ldrb	r3, [r5, #0]
    7596:	4e70      	ldr	r6, [pc, #448]	; (7758 <CLI_process+0x1d4>)
    7598:	2b63      	cmp	r3, #99	; 0x63
		// No more characters to process
		if ( Output_availablechar() == 0 )
			break;

		// Retrieve from output module
		char cur_char = (char)Output_getchar();
    759a:	b2c0      	uxtb	r0, r0

		// Make sure buffer isn't full
		if ( CLILineBufferCurrent >= CLILineBufferMaxSize )
    759c:	d908      	bls.n	75b0 <CLI_process+0x2c>
		{
			print( NL );
    759e:	486f      	ldr	r0, [pc, #444]	; (775c <CLI_process+0x1d8>)
    75a0:	f000 f930 	bl	7804 <_print>
			erro_print("Serial line buffer is full, dropping character and resetting...");
    75a4:	486e      	ldr	r0, [pc, #440]	; (7760 <CLI_process+0x1dc>)
    75a6:	f000 f92d 	bl	7804 <_print>

			// Clear buffer
			CLILineBufferCurrent = 0;
    75aa:	2300      	movs	r3, #0
    75ac:	7033      	strb	r3, [r6, #0]
    75ae:	e03e      	b.n	762e <CLI_process+0xaa>

			return;
		}

		// Place into line buffer
		CLILineBuffer[CLILineBufferCurrent++] = cur_char;
    75b0:	1c5a      	adds	r2, r3, #1
    75b2:	7032      	strb	r2, [r6, #0]
    75b4:	4a6b      	ldr	r2, [pc, #428]	; (7764 <CLI_process+0x1e0>)
    75b6:	54d0      	strb	r0, [r2, r3]
	}
    75b8:	e7e7      	b.n	758a <CLI_process+0x6>

	// Display Hex Key Input if enabled
	if ( CLIHexDebugMode && CLILineBufferCurrent > prev_buf_pos )
    75ba:	4b6b      	ldr	r3, [pc, #428]	; (7768 <CLI_process+0x1e4>)
    75bc:	781b      	ldrb	r3, [r3, #0]
    75be:	b30b      	cbz	r3, 7604 <CLI_process+0x80>
    75c0:	782b      	ldrb	r3, [r5, #0]
    75c2:	42a3      	cmp	r3, r4
    75c4:	d91e      	bls.n	7604 <CLI_process+0x80>
	{
		print("\033[s\r\n"); // Save cursor position, and move to the next line
    75c6:	4869      	ldr	r0, [pc, #420]	; (776c <CLI_process+0x1e8>)
    75c8:	f000 f91c 	bl	7804 <_print>
		print("\033[2K");    // Erases the current line
    75cc:	4868      	ldr	r0, [pc, #416]	; (7770 <CLI_process+0x1ec>)
    75ce:	f000 f919 	bl	7804 <_print>

		uint8_t pos = prev_buf_pos;
		while ( CLILineBufferCurrent > pos )
    75d2:	4623      	mov	r3, r4
    75d4:	782a      	ldrb	r2, [r5, #0]
    75d6:	429a      	cmp	r2, r3
    75d8:	d90b      	bls.n	75f2 <CLI_process+0x6e>
		{
			printHex( CLILineBuffer[pos++] );
    75da:	4a62      	ldr	r2, [pc, #392]	; (7764 <CLI_process+0x1e0>)
    75dc:	1c5e      	adds	r6, r3, #1
    75de:	5cd0      	ldrb	r0, [r2, r3]
    75e0:	2101      	movs	r1, #1
    75e2:	f000 f998 	bl	7916 <printHex_op>
    75e6:	b2f6      	uxtb	r6, r6
			print(" ");
    75e8:	4862      	ldr	r0, [pc, #392]	; (7774 <CLI_process+0x1f0>)
    75ea:	f000 f90b 	bl	7804 <_print>
		print("\033[2K");    // Erases the current line

		uint8_t pos = prev_buf_pos;
		while ( CLILineBufferCurrent > pos )
		{
			printHex( CLILineBuffer[pos++] );
    75ee:	4633      	mov	r3, r6
    75f0:	e7f0      	b.n	75d4 <CLI_process+0x50>
			print(" ");
		}

		print("\033[u"); // Restore cursor position
    75f2:	4861      	ldr	r0, [pc, #388]	; (7778 <CLI_process+0x1f4>)
    75f4:	e026      	b.n	7644 <CLI_process+0xc0>

	// If buffer has changed, output to screen while there are still characters in the buffer not displayed
	while ( CLILineBufferCurrent > prev_buf_pos )
	{
		// Check for control characters
		switch ( CLILineBuffer[prev_buf_pos] )
    75f6:	d830      	bhi.n	765a <CLI_process+0xd6>
    75f8:	2a08      	cmp	r2, #8
    75fa:	d126      	bne.n	764a <CLI_process+0xc6>
		case 0x7F: // Backspace
			// TODO - Does not handle case for arrow editing (arrows disabled atm)
			CLILineBufferCurrent--; // Remove the backspace

			// If there are characters in the buffer
			if ( CLILineBufferCurrent > 0 )
    75fc:	2b01      	cmp	r3, #1
    75fe:	d11e      	bne.n	763e <CLI_process+0xba>
			return;

		case 0x08:
		case 0x7F: // Backspace
			// TODO - Does not handle case for arrow editing (arrows disabled atm)
			CLILineBufferCurrent--; // Remove the backspace
    7600:	2300      	movs	r3, #0
    7602:	702b      	strb	r3, [r5, #0]

		print("\033[u"); // Restore cursor position
	}

	// If buffer has changed, output to screen while there are still characters in the buffer not displayed
	while ( CLILineBufferCurrent > prev_buf_pos )
    7604:	782b      	ldrb	r3, [r5, #0]
    7606:	4f54      	ldr	r7, [pc, #336]	; (7758 <CLI_process+0x1d4>)
    7608:	42a3      	cmp	r3, r4
    760a:	f240 80a3 	bls.w	7754 <CLI_process+0x1d0>
	{
		// Check for control characters
		switch ( CLILineBuffer[prev_buf_pos] )
    760e:	4955      	ldr	r1, [pc, #340]	; (7764 <CLI_process+0x1e0>)
    7610:	5d0a      	ldrb	r2, [r1, r4]
    7612:	2a0a      	cmp	r2, #10
    7614:	460e      	mov	r6, r1
    7616:	d1ee      	bne.n	75f6 <CLI_process+0x72>
		{
		// Enter
		case 0x0A: // LF
		case 0x0D: // CR
			CLILineBuffer[CLILineBufferCurrent - 1] = ' '; // Replace Enter with a space (resolves a bug in args)
    7618:	441e      	add	r6, r3
    761a:	2220      	movs	r2, #32

			// Remove the space if there is no command
			if ( CLILineBufferCurrent == 1 )
    761c:	2b01      	cmp	r3, #1
		switch ( CLILineBuffer[prev_buf_pos] )
		{
		// Enter
		case 0x0A: // LF
		case 0x0D: // CR
			CLILineBuffer[CLILineBufferCurrent - 1] = ' '; // Replace Enter with a space (resolves a bug in args)
    761e:	f806 2c01 	strb.w	r2, [r6, #-1]

			// Remove the space if there is no command
			if ( CLILineBufferCurrent == 1 )
    7622:	d121      	bne.n	7668 <CLI_process+0xe4>
				CLI_saveHistory( NULL ); // delete the old temp buffer

			}

			// Reset the buffer
			CLILineBufferCurrent = 0;
    7624:	2300      	movs	r3, #0

			// Reset the prompt after processing has finished
			print( NL );
    7626:	484d      	ldr	r0, [pc, #308]	; (775c <CLI_process+0x1d8>)
				CLI_saveHistory( NULL ); // delete the old temp buffer

			}

			// Reset the buffer
			CLILineBufferCurrent = 0;
    7628:	702b      	strb	r3, [r5, #0]

			// Reset the prompt after processing has finished
			print( NL );
    762a:	f000 f8eb 	bl	7804 <_print>

// ----- Functions -----

inline void prompt()
{
	print("\033[2K\r"); // Erases the current line and resets cursor to beginning of line
    762e:	4853      	ldr	r0, [pc, #332]	; (777c <CLI_process+0x1f8>)
    7630:	f000 f8e8 	bl	7804 <_print>
	print("\033[1;34m:\033[0m "); // Blue bold prompt
    7634:	4852      	ldr	r0, [pc, #328]	; (7780 <CLI_process+0x1fc>)
			prev_buf_pos++;

			break;
		}
	}
}
    7636:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
// ----- Functions -----

inline void prompt()
{
	print("\033[2K\r"); // Erases the current line and resets cursor to beginning of line
	print("\033[1;34m:\033[0m "); // Blue bold prompt
    763a:	f000 b8e3 	b.w	7804 <_print>

			// If there are characters in the buffer
			if ( CLILineBufferCurrent > 0 )
			{
				// Remove character from current position in the line buffer
				CLILineBufferCurrent--;
    763e:	3b02      	subs	r3, #2

				// Remove character from tty
				print("\b \b");
    7640:	4850      	ldr	r0, [pc, #320]	; (7784 <CLI_process+0x200>)

			// If there are characters in the buffer
			if ( CLILineBufferCurrent > 0 )
			{
				// Remove character from current position in the line buffer
				CLILineBufferCurrent--;
    7642:	702b      	strb	r3, [r5, #0]

				// Remove character from tty
				print("\b \b");
    7644:	f000 f8de 	bl	7804 <_print>
    7648:	e7dc      	b.n	7604 <CLI_process+0x80>

	// If buffer has changed, output to screen while there are still characters in the buffer not displayed
	while ( CLILineBufferCurrent > prev_buf_pos )
	{
		// Check for control characters
		switch ( CLILineBuffer[prev_buf_pos] )
    764a:	2a09      	cmp	r2, #9
    764c:	d17a      	bne.n	7744 <CLI_process+0x1c0>
			//     Doesn't look like it will happen *that* often, so not handling it for now -HaaTa
			return;

		case 0x09: // Tab
			// Tab completion for the current command
			CLI_tabCompletion();
    764e:	f7ff feeb 	bl	7428 <CLI_tabCompletion>

			CLILineBufferCurrent--; // Remove the Tab
    7652:	783b      	ldrb	r3, [r7, #0]
    7654:	3b01      	subs	r3, #1
    7656:	703b      	strb	r3, [r7, #0]

			// XXX There is a potential bug here when resetting the buffer (losing valid keypresses)
			//     Doesn't look like it will happen *that* often, so not handling it for now -HaaTa
			return;
    7658:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

	// If buffer has changed, output to screen while there are still characters in the buffer not displayed
	while ( CLILineBufferCurrent > prev_buf_pos )
	{
		// Check for control characters
		switch ( CLILineBuffer[prev_buf_pos] )
    765a:	2a1b      	cmp	r2, #27
    765c:	d029      	beq.n	76b2 <CLI_process+0x12e>
    765e:	2a7f      	cmp	r2, #127	; 0x7f
    7660:	d0cc      	beq.n	75fc <CLI_process+0x78>
    7662:	2a0d      	cmp	r2, #13
    7664:	d16e      	bne.n	7744 <CLI_process+0x1c0>
    7666:	e7d7      	b.n	7618 <CLI_process+0x94>
				CLILineBufferCurrent--;
			}
			else
			{
				// Add the command to the history
				CLI_saveHistory( CLILineBuffer );
    7668:	483e      	ldr	r0, [pc, #248]	; (7764 <CLI_process+0x1e0>)
    766a:	f7ff ff4f 	bl	750c <CLI_saveHistory>

				// Process the current line buffer
				CLI_commandLookup();
    766e:	f7ff fe29 	bl	72c4 <CLI_commandLookup>

				// Keep the array circular, discarding the older entries
				if ( CLIHistoryTail < CLIHistoryHead )
    7672:	4b45      	ldr	r3, [pc, #276]	; (7788 <CLI_process+0x204>)
    7674:	4a45      	ldr	r2, [pc, #276]	; (778c <CLI_process+0x208>)
    7676:	7819      	ldrb	r1, [r3, #0]
    7678:	7814      	ldrb	r4, [r2, #0]
    767a:	42a1      	cmp	r1, r4
    767c:	d206      	bcs.n	768c <CLI_process+0x108>
					CLIHistoryHead = ( CLIHistoryHead + 1 ) % CLIMaxHistorySize;
    767e:	3401      	adds	r4, #1
    7680:	200a      	movs	r0, #10
    7682:	fb94 f6f0 	sdiv	r6, r4, r0
    7686:	fb00 4016 	mls	r0, r0, r6, r4
    768a:	7010      	strb	r0, [r2, #0]
				CLIHistoryTail++;
    768c:	3101      	adds	r1, #1
    768e:	b2c9      	uxtb	r1, r1
				if ( CLIHistoryTail == CLIMaxHistorySize )
    7690:	290a      	cmp	r1, #10
    7692:	d001      	beq.n	7698 <CLI_process+0x114>
				CLI_commandLookup();

				// Keep the array circular, discarding the older entries
				if ( CLIHistoryTail < CLIHistoryHead )
					CLIHistoryHead = ( CLIHistoryHead + 1 ) % CLIMaxHistorySize;
				CLIHistoryTail++;
    7694:	7019      	strb	r1, [r3, #0]
    7696:	e003      	b.n	76a0 <CLI_process+0x11c>
				if ( CLIHistoryTail == CLIMaxHistorySize )
				{
					CLIHistoryTail = 0;
    7698:	2100      	movs	r1, #0
    769a:	7019      	strb	r1, [r3, #0]
					CLIHistoryHead = 1;
    769c:	2101      	movs	r1, #1
    769e:	7011      	strb	r1, [r2, #0]
				}

				CLIHistoryCurrent = CLIHistoryTail; // 'Up' starts at the last item
    76a0:	781b      	ldrb	r3, [r3, #0]
    76a2:	4a3b      	ldr	r2, [pc, #236]	; (7790 <CLI_process+0x20c>)
    76a4:	7013      	strb	r3, [r2, #0]
inline void CLI_saveHistory( char *buff )
{
	if ( buff == NULL )
	{
		//clear the item
		CLIHistoryBuffer[ CLIHistoryTail ][ 0 ] = '\0';
    76a6:	2264      	movs	r2, #100	; 0x64
    76a8:	4353      	muls	r3, r2
    76aa:	4a3a      	ldr	r2, [pc, #232]	; (7794 <CLI_process+0x210>)
    76ac:	2100      	movs	r1, #0
    76ae:	54d1      	strb	r1, [r2, r3]
    76b0:	e7b8      	b.n	7624 <CLI_process+0xa0>

		case 0x1B: // Esc / Escape codes
			// Check for other escape sequence

			// \e[ is an escape code in vt100 compatible terminals
			if ( CLILineBufferCurrent >= prev_buf_pos + 3
    76b2:	1ca5      	adds	r5, r4, #2
    76b4:	429d      	cmp	r5, r3
    76b6:	da4d      	bge.n	7754 <CLI_process+0x1d0>
				&& CLILineBuffer[ prev_buf_pos ] == 0x1B
				&& CLILineBuffer[ prev_buf_pos + 1] == 0x5B )
    76b8:	190b      	adds	r3, r1, r4
    76ba:	785b      	ldrb	r3, [r3, #1]
    76bc:	2b5b      	cmp	r3, #91	; 0x5b
    76be:	d149      	bne.n	7754 <CLI_process+0x1d0>
			{
				// Arrow Keys: A (0x41) = Up, B (0x42) = Down, C (0x43) = Right, D (0x44) = Left

				if ( CLILineBuffer[ prev_buf_pos + 2 ] == 0x41 ) // Hist prev
    76c0:	5d4b      	ldrb	r3, [r1, r5]
    76c2:	2b41      	cmp	r3, #65	; 0x41
    76c4:	d122      	bne.n	770c <CLI_process+0x188>
				{
					if ( CLIHistoryCurrent == CLIHistoryTail )
    76c6:	4f32      	ldr	r7, [pc, #200]	; (7790 <CLI_process+0x20c>)
    76c8:	4b2f      	ldr	r3, [pc, #188]	; (7788 <CLI_process+0x204>)
    76ca:	f997 2000 	ldrsb.w	r2, [r7]
    76ce:	781b      	ldrb	r3, [r3, #0]
    76d0:	429a      	cmp	r2, r3
    76d2:	d104      	bne.n	76de <CLI_process+0x15a>
					{
						// Is first time pressing arrow. Save the current buffer
						CLILineBuffer[ prev_buf_pos ] = '\0';
    76d4:	2300      	movs	r3, #0
						CLI_saveHistory( CLILineBuffer );
    76d6:	4608      	mov	r0, r1
				if ( CLILineBuffer[ prev_buf_pos + 2 ] == 0x41 ) // Hist prev
				{
					if ( CLIHistoryCurrent == CLIHistoryTail )
					{
						// Is first time pressing arrow. Save the current buffer
						CLILineBuffer[ prev_buf_pos ] = '\0';
    76d8:	550b      	strb	r3, [r1, r4]
						CLI_saveHistory( CLILineBuffer );
    76da:	f7ff ff17 	bl	750c <CLI_saveHistory>
					}

					// Grab the previus item from the history if there is one
					if ( RING_PREV( CLIHistoryCurrent ) != RING_PREV( CLIHistoryHead ) )
    76de:	f997 0000 	ldrsb.w	r0, [r7]
    76e2:	2100      	movs	r1, #0
    76e4:	2209      	movs	r2, #9
    76e6:	3801      	subs	r0, #1
    76e8:	f7ff fefe 	bl	74e8 <CLI_wrap>
    76ec:	4b27      	ldr	r3, [pc, #156]	; (778c <CLI_process+0x208>)
    76ee:	4604      	mov	r4, r0
    76f0:	7818      	ldrb	r0, [r3, #0]
    76f2:	2100      	movs	r1, #0
    76f4:	3801      	subs	r0, #1
    76f6:	2209      	movs	r2, #9
    76f8:	f7ff fef6 	bl	74e8 <CLI_wrap>
    76fc:	4284      	cmp	r4, r0
						CLIHistoryCurrent = RING_PREV( CLIHistoryCurrent );
    76fe:	bf1c      	itt	ne
    7700:	4b23      	ldrne	r3, [pc, #140]	; (7790 <CLI_process+0x20c>)
    7702:	701c      	strbne	r4, [r3, #0]
					CLI_retreiveHistory( CLIHistoryCurrent );
    7704:	f997 0000 	ldrsb.w	r0, [r7]
    7708:	f7ff ff16 	bl	7538 <CLI_retreiveHistory>
				}
				if ( CLILineBuffer[ prev_buf_pos + 2 ] == 0x42 ) // Hist next
    770c:	5d73      	ldrb	r3, [r6, r5]
    770e:	2b42      	cmp	r3, #66	; 0x42
    7710:	d120      	bne.n	7754 <CLI_process+0x1d0>
				{
					// Grab the next item from the history if it exists
					if ( RING_NEXT( CLIHistoryCurrent ) != RING_NEXT( CLIHistoryTail ) )
    7712:	4d1f      	ldr	r5, [pc, #124]	; (7790 <CLI_process+0x20c>)
    7714:	f995 0000 	ldrsb.w	r0, [r5]
    7718:	2100      	movs	r1, #0
    771a:	2209      	movs	r2, #9
    771c:	3001      	adds	r0, #1
    771e:	f7ff fee3 	bl	74e8 <CLI_wrap>
    7722:	4b19      	ldr	r3, [pc, #100]	; (7788 <CLI_process+0x204>)
    7724:	4604      	mov	r4, r0
    7726:	7818      	ldrb	r0, [r3, #0]
    7728:	2100      	movs	r1, #0
    772a:	3001      	adds	r0, #1
    772c:	2209      	movs	r2, #9
    772e:	f7ff fedb 	bl	74e8 <CLI_wrap>
    7732:	4284      	cmp	r4, r0
						CLIHistoryCurrent = RING_NEXT( CLIHistoryCurrent );
    7734:	bf18      	it	ne
    7736:	702c      	strbne	r4, [r5, #0]
					CLI_retreiveHistory( CLIHistoryCurrent );
    7738:	f995 0000 	ldrsb.w	r0, [r5]
			prev_buf_pos++;

			break;
		}
	}
}
    773c:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
				if ( CLILineBuffer[ prev_buf_pos + 2 ] == 0x42 ) // Hist next
				{
					// Grab the next item from the history if it exists
					if ( RING_NEXT( CLIHistoryCurrent ) != RING_NEXT( CLIHistoryTail ) )
						CLIHistoryCurrent = RING_NEXT( CLIHistoryCurrent );
					CLI_retreiveHistory( CLIHistoryCurrent );
    7740:	f7ff befa 	b.w	7538 <CLI_retreiveHistory>

			break;

		default:
			// Place a null on the end (to use with string print)
			CLILineBuffer[CLILineBufferCurrent] = '\0';
    7744:	2200      	movs	r2, #0

			// Output buffer to screen
			dPrint( &CLILineBuffer[prev_buf_pos] );
    7746:	1930      	adds	r0, r6, r4

			// Buffer reset
			prev_buf_pos++;
    7748:	3401      	adds	r4, #1

			break;

		default:
			// Place a null on the end (to use with string print)
			CLILineBuffer[CLILineBufferCurrent] = '\0';
    774a:	54ca      	strb	r2, [r1, r3]

			// Output buffer to screen
			dPrint( &CLILineBuffer[prev_buf_pos] );

			// Buffer reset
			prev_buf_pos++;
    774c:	b2e4      	uxtb	r4, r4
		default:
			// Place a null on the end (to use with string print)
			CLILineBuffer[CLILineBufferCurrent] = '\0';

			// Output buffer to screen
			dPrint( &CLILineBuffer[prev_buf_pos] );
    774e:	f7fe fd5b 	bl	6208 <Output_putstr>

			// Buffer reset
			prev_buf_pos++;

			break;
    7752:	e757      	b.n	7604 <CLI_process+0x80>
    7754:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    7756:	bf00      	nop
    7758:	1fff9adc 	.word	0x1fff9adc
    775c:	0000bafb 	.word	0x0000bafb
    7760:	0000c07f 	.word	0x0000c07f
    7764:	1fff9a20 	.word	0x1fff9a20
    7768:	1fff9634 	.word	0x1fff9634
    776c:	0000c0d6 	.word	0x0000c0d6
    7770:	0000c0dc 	.word	0x0000c0dc
    7774:	00008156 	.word	0x00008156
    7778:	0000c0e1 	.word	0x0000c0e1
    777c:	0000c06b 	.word	0x0000c06b
    7780:	0000c071 	.word	0x0000c071
    7784:	0000c0e5 	.word	0x0000c0e5
    7788:	1fff9ab0 	.word	0x1fff9ab0
    778c:	1fff9a85 	.word	0x1fff9a85
    7790:	1fff9635 	.word	0x1fff9635
    7794:	1fff9638 	.word	0x1fff9638

00007798 <init_errorLED>:

// Kiibohd-dfu
#elif defined(_mk20dx256vlh7_)
	// Kiibohd-dfu
	// Enable pin
	GPIOA_PDDR |= (1<<5);
    7798:	4b05      	ldr	r3, [pc, #20]	; (77b0 <init_errorLED+0x18>)
    779a:	681a      	ldr	r2, [r3, #0]
    779c:	f042 0220 	orr.w	r2, r2, #32
    77a0:	601a      	str	r2, [r3, #0]

	// Setup pin - A5 - See Lib/pin_map.mchck for more details on pins
	PORTA_PCR5 = PORT_PCR_SRE | PORT_PCR_DSE | PORT_PCR_MUX(1);
    77a2:	f5a3 2336 	sub.w	r3, r3, #745472	; 0xb6000
    77a6:	f44f 72a2 	mov.w	r2, #324	; 0x144
    77aa:	601a      	str	r2, [r3, #0]
    77ac:	4770      	bx	lr
    77ae:	bf00      	nop
    77b0:	400ff014 	.word	0x400ff014

000077b4 <errorLED>:

// Kiibohd-dfu
#elif defined(_mk20dx256vlh7_)
	// Kiibohd-dfu
	// Error LED On (A5)
	if ( on ) {
    77b4:	b108      	cbz	r0, 77ba <errorLED+0x6>
		GPIOA_PSOR |= (1<<5);
    77b6:	4b04      	ldr	r3, [pc, #16]	; (77c8 <errorLED+0x14>)
    77b8:	e000      	b.n	77bc <errorLED+0x8>
	}
	// Error LED Off
	else {
		GPIOA_PCOR |= (1<<5);
    77ba:	4b04      	ldr	r3, [pc, #16]	; (77cc <errorLED+0x18>)
    77bc:	681a      	ldr	r2, [r3, #0]
    77be:	f042 0220 	orr.w	r2, r2, #32
    77c2:	601a      	str	r2, [r3, #0]
    77c4:	4770      	bx	lr
    77c6:	bf00      	nop
    77c8:	400ff004 	.word	0x400ff004
    77cc:	400ff008 	.word	0x400ff008

000077d0 <printstrs>:

// ----- Functions -----

// Multiple string Output
void printstrs( char* first, ... )
{
    77d0:	b40f      	push	{r0, r1, r2, r3}
    77d2:	b507      	push	{r0, r1, r2, lr}
    77d4:	ab04      	add	r3, sp, #16
    77d6:	f853 0b04 	ldr.w	r0, [r3], #4
	// Initialize the variadic function parameter list
	va_list ap;

	// Get the first parameter
	va_start( ap, first );
    77da:	9301      	str	r3, [sp, #4]
	char *cur = first;

	// Loop through the variadic list until "\0\0\0" is found
	while ( !( cur[0] == '\0' && cur[1] == '\0' && cur[2] == '\0' ) )
    77dc:	7803      	ldrb	r3, [r0, #0]
    77de:	b133      	cbz	r3, 77ee <printstrs+0x1e>
	{
		// Print out the given string
		Output_putstr( cur );
    77e0:	f7fe fd12 	bl	6208 <Output_putstr>

		// Get the next argument ready
		cur = va_arg( ap, char* );
    77e4:	9b01      	ldr	r3, [sp, #4]
    77e6:	1d1a      	adds	r2, r3, #4
    77e8:	9201      	str	r2, [sp, #4]
    77ea:	6818      	ldr	r0, [r3, #0]
    77ec:	e7f6      	b.n	77dc <printstrs+0xc>
	// Get the first parameter
	va_start( ap, first );
	char *cur = first;

	// Loop through the variadic list until "\0\0\0" is found
	while ( !( cur[0] == '\0' && cur[1] == '\0' && cur[2] == '\0' ) )
    77ee:	7843      	ldrb	r3, [r0, #1]
    77f0:	2b00      	cmp	r3, #0
    77f2:	d1f5      	bne.n	77e0 <printstrs+0x10>
    77f4:	7883      	ldrb	r3, [r0, #2]
    77f6:	2b00      	cmp	r3, #0
    77f8:	d1f2      	bne.n	77e0 <printstrs+0x10>
		// Get the next argument ready
		cur = va_arg( ap, char* );
	}

	va_end( ap ); // Not required, but good practice
}
    77fa:	b003      	add	sp, #12
    77fc:	f85d eb04 	ldr.w	lr, [sp], #4
    7800:	b004      	add	sp, #16
    7802:	4770      	bx	lr

00007804 <_print>:
	while ( ( c = pgm_read_byte( s++ ) ) != '\0' )
	{
		Output_putchar( c );
	}
#elif defined(_mk20dx128_) || defined(_mk20dx128vlf5_) || defined(_mk20dx256_) || defined(_mk20dx256vlh7_) // ARM
	Output_putstr( (char*)s );
    7804:	f7fe bd00 	b.w	6208 <Output_putstr>

00007808 <lenStr>:
	}
}


uint16_t lenStr( char* in )
{
    7808:	4603      	mov	r3, r0
    780a:	461a      	mov	r2, r3
    780c:	3301      	adds	r3, #1
	// Iterator
	char *pos;

	// Loop until null is found
	for ( pos = in; *pos; pos++ );
    780e:	7811      	ldrb	r1, [r2, #0]
    7810:	2900      	cmp	r1, #0
    7812:	d1fa      	bne.n	780a <lenStr+0x2>

	// Return the difference between the pointers of in and pos (which is the string length)
	return (pos - in);
    7814:	1a10      	subs	r0, r2, r0
}
    7816:	b280      	uxth	r0, r0
    7818:	4770      	bx	lr

0000781a <revsStr>:
	revsStr(out);
}


void revsStr( char* in )
{
    781a:	b510      	push	{r4, lr}
    781c:	4604      	mov	r4, r0

	// Temp storage
	char c;

	// Loop through the string, and reverse the order of the characters
	for ( i = 0, j = lenStr( in ) - 1; i < j; i++, j-- )
    781e:	f7ff fff3 	bl	7808 <lenStr>
    7822:	2200      	movs	r2, #0
    7824:	1e43      	subs	r3, r0, #1
    7826:	429a      	cmp	r2, r3
    7828:	da06      	bge.n	7838 <revsStr+0x1e>
	{
		c = in[i];
    782a:	5ca1      	ldrb	r1, [r4, r2]
		in[i] = in[j];
    782c:	5ce0      	ldrb	r0, [r4, r3]
    782e:	54a0      	strb	r0, [r4, r2]
		in[j] = c;
    7830:	54e1      	strb	r1, [r4, r3]

	// Temp storage
	char c;

	// Loop through the string, and reverse the order of the characters
	for ( i = 0, j = lenStr( in ) - 1; i < j; i++, j-- )
    7832:	3201      	adds	r2, #1
    7834:	3b01      	subs	r3, #1
    7836:	e7f6      	b.n	7826 <revsStr+0xc>
	{
		c = in[i];
		in[i] = in[j];
		in[j] = c;
	}
}
    7838:	bd10      	pop	{r4, pc}

0000783a <int8ToStr>:



// String Functions
void int8ToStr( uint8_t in, char* out )
{
    783a:	b530      	push	{r4, r5, lr}
    783c:	4603      	mov	r3, r0
	// Position and sign containers
	uint8_t pos;
	pos = 0;
    783e:	2200      	movs	r2, #0

	// Evaluate through digits as decimal
	do
	{
		out[pos++] = in % 10 + '0';
    7840:	250a      	movs	r5, #10
    7842:	fbb3 f0f5 	udiv	r0, r3, r5
    7846:	fb05 3310 	mls	r3, r5, r0, r3
    784a:	3330      	adds	r3, #48	; 0x30
    784c:	1c54      	adds	r4, r2, #1
    784e:	548b      	strb	r3, [r1, r2]
	}
	while ( (in /= 10) > 0 );
    7850:	f010 03ff 	ands.w	r3, r0, #255	; 0xff
	pos = 0;

	// Evaluate through digits as decimal
	do
	{
		out[pos++] = in % 10 + '0';
    7854:	b2e4      	uxtb	r4, r4
	}
	while ( (in /= 10) > 0 );
    7856:	d001      	beq.n	785c <int8ToStr+0x22>
	pos = 0;

	// Evaluate through digits as decimal
	do
	{
		out[pos++] = in % 10 + '0';
    7858:	4622      	mov	r2, r4
    785a:	e7f1      	b.n	7840 <int8ToStr+0x6>
	}
	while ( (in /= 10) > 0 );

	// Append null
	out[pos] = '\0';
    785c:	550b      	strb	r3, [r1, r4]

	// Reverse the string to the correct order
	revsStr(out);
    785e:	4608      	mov	r0, r1
}
    7860:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}

	// Append null
	out[pos] = '\0';

	// Reverse the string to the correct order
	revsStr(out);
    7864:	f7ff bfd9 	b.w	781a <revsStr>

00007868 <printInt8>:



// Number Printing Functions
void printInt8( uint8_t in )
{
    7868:	b507      	push	{r0, r1, r2, lr}
	// Max number of characters is 3 + 1 for null
	char tmpStr[4];

	// Convert number
	int8ToStr( in, tmpStr );
    786a:	a901      	add	r1, sp, #4
    786c:	f7ff ffe5 	bl	783a <int8ToStr>

	// Print number
	dPrintStr( tmpStr );
    7870:	a801      	add	r0, sp, #4
    7872:	f7fe fcc9 	bl	6208 <Output_putstr>
}
    7876:	b003      	add	sp, #12
    7878:	f85d fb04 	ldr.w	pc, [sp], #4

0000787c <int16ToStr>:
	revsStr(out);
}


void int16ToStr( uint16_t in, char* out )
{
    787c:	b530      	push	{r4, r5, lr}
    787e:	4603      	mov	r3, r0
	// Position and sign containers
	uint16_t pos;
	pos = 0;
    7880:	2200      	movs	r2, #0

	// Evaluate through digits as decimal
	do
	{
		out[pos++] = in % 10 + '0';
    7882:	250a      	movs	r5, #10
    7884:	fbb3 f4f5 	udiv	r4, r3, r5
    7888:	fb05 3314 	mls	r3, r5, r4, r3
    788c:	3330      	adds	r3, #48	; 0x30
    788e:	1c50      	adds	r0, r2, #1
    7890:	548b      	strb	r3, [r1, r2]
	}
	while ( (in /= 10) > 0 );
    7892:	b2a3      	uxth	r3, r4
	pos = 0;

	// Evaluate through digits as decimal
	do
	{
		out[pos++] = in % 10 + '0';
    7894:	b280      	uxth	r0, r0
	}
	while ( (in /= 10) > 0 );
    7896:	b10b      	cbz	r3, 789c <int16ToStr+0x20>
	pos = 0;

	// Evaluate through digits as decimal
	do
	{
		out[pos++] = in % 10 + '0';
    7898:	4602      	mov	r2, r0
    789a:	e7f2      	b.n	7882 <int16ToStr+0x6>
	}
	while ( (in /= 10) > 0 );

	// Append null
	out[pos] = '\0';
    789c:	540b      	strb	r3, [r1, r0]

	// Reverse the string to the correct order
	revsStr(out);
}
    789e:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}

	// Append null
	out[pos] = '\0';

	// Reverse the string to the correct order
	revsStr(out);
    78a2:	4608      	mov	r0, r1
    78a4:	f7ff bfb9 	b.w	781a <revsStr>

000078a8 <printInt16>:
	// Print number
	dPrintStr( tmpStr );
}

void printInt16( uint16_t in )
{
    78a8:	b507      	push	{r0, r1, r2, lr}
	// Max number of characters is 5 + 1 for null
	char tmpStr[6];

	// Convert number
	int16ToStr( in, tmpStr );
    78aa:	4669      	mov	r1, sp
    78ac:	f7ff ffe6 	bl	787c <int16ToStr>

	// Print number
	dPrintStr( tmpStr );
    78b0:	4668      	mov	r0, sp
    78b2:	f7fe fca9 	bl	6208 <Output_putstr>
}
    78b6:	b003      	add	sp, #12
    78b8:	f85d fb04 	ldr.w	pc, [sp], #4

000078bc <hexToStr_op>:
	revsStr(out);
}


void hexToStr_op( uint16_t in, char* out, uint8_t op )
{
    78bc:	b570      	push	{r4, r5, r6, lr}
	// Position container
	uint16_t pos = 0;
    78be:	2400      	movs	r4, #0

	// Evaluate through digits as hex
	do
	{
		uint16_t cur = in % 16;
    78c0:	f000 050f 	and.w	r5, r0, #15
		out[pos++] = cur + (( cur < 10 ) ? '0' : 'A' - 10);
    78c4:	2d09      	cmp	r5, #9
    78c6:	bf8c      	ite	hi
    78c8:	2637      	movhi	r6, #55	; 0x37
    78ca:	2630      	movls	r6, #48	; 0x30
    78cc:	1c63      	adds	r3, r4, #1
    78ce:	4435      	add	r5, r6
	}
	while ( (in /= 16) > 0 );
    78d0:	0900      	lsrs	r0, r0, #4

	// Evaluate through digits as hex
	do
	{
		uint16_t cur = in % 16;
		out[pos++] = cur + (( cur < 10 ) ? '0' : 'A' - 10);
    78d2:	b29b      	uxth	r3, r3
    78d4:	550d      	strb	r5, [r1, r4]
	}
	while ( (in /= 16) > 0 );
    78d6:	d001      	beq.n	78dc <hexToStr_op+0x20>

	// Evaluate through digits as hex
	do
	{
		uint16_t cur = in % 16;
		out[pos++] = cur + (( cur < 10 ) ? '0' : 'A' - 10);
    78d8:	461c      	mov	r4, r3
    78da:	e7f1      	b.n	78c0 <hexToStr_op+0x4>
	}
	while ( (in /= 16) > 0 );

	// Output formatting options
	switch ( op )
    78dc:	2a02      	cmp	r2, #2
    78de:	d00c      	beq.n	78fa <hexToStr_op+0x3e>
    78e0:	2a04      	cmp	r2, #4
    78e2:	d00a      	beq.n	78fa <hexToStr_op+0x3e>
    78e4:	2a01      	cmp	r2, #1
    78e6:	d10f      	bne.n	7908 <hexToStr_op+0x4c>
	{
	case 1: // Add 0x
		out[pos++] = 'x';
    78e8:	2278      	movs	r2, #120	; 0x78
    78ea:	54ca      	strb	r2, [r1, r3]
		out[pos++] = '0';
    78ec:	1ce3      	adds	r3, r4, #3

	// Output formatting options
	switch ( op )
	{
	case 1: // Add 0x
		out[pos++] = 'x';
    78ee:	3402      	adds	r4, #2
		out[pos++] = '0';
    78f0:	b2a4      	uxth	r4, r4
    78f2:	2230      	movs	r2, #48	; 0x30
    78f4:	b29b      	uxth	r3, r3
    78f6:	550a      	strb	r2, [r1, r4]
		break;
    78f8:	e006      	b.n	7908 <hexToStr_op+0x4c>
	case 2: //  8-bit padding
	case 4: // 16-bit padding
		while ( pos < op )
    78fa:	4293      	cmp	r3, r2
    78fc:	d204      	bcs.n	7908 <hexToStr_op+0x4c>
			out[pos++] = '0';
    78fe:	1c58      	adds	r0, r3, #1
    7900:	2430      	movs	r4, #48	; 0x30
    7902:	54cc      	strb	r4, [r1, r3]
    7904:	b283      	uxth	r3, r0
    7906:	e7f8      	b.n	78fa <hexToStr_op+0x3e>
		break;
	}

	// Append null
	out[pos] = '\0';
    7908:	2200      	movs	r2, #0
    790a:	54ca      	strb	r2, [r1, r3]

	// Reverse the string to the correct order
	revsStr(out);
    790c:	4608      	mov	r0, r1
}
    790e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}

	// Append null
	out[pos] = '\0';

	// Reverse the string to the correct order
	revsStr(out);
    7912:	f7ff bf82 	b.w	781a <revsStr>

00007916 <printHex_op>:
	// Print number
	dPrintStr( tmpStr );
}

void printHex_op( uint16_t in, uint8_t op )
{
    7916:	b507      	push	{r0, r1, r2, lr}
    7918:	460a      	mov	r2, r1
	// e.g. "0xFFFF\0"
	// op 2 and 4 require fewer characters (2+1 and 4+1 respectively)
	char tmpStr[7];

	// Convert number
	hexToStr_op( in, tmpStr, op );
    791a:	4669      	mov	r1, sp
    791c:	f7ff ffce 	bl	78bc <hexToStr_op>

	// Print number
	dPrintStr( tmpStr );
    7920:	4668      	mov	r0, sp
    7922:	f7fe fc71 	bl	6208 <Output_putstr>
}
    7926:	b003      	add	sp, #12
    7928:	f85d fb04 	ldr.w	pc, [sp], #4

0000792c <hex32ToStr_op>:
	revsStr(out);
}


void hex32ToStr_op( uint32_t in, char* out, uint8_t op )
{
    792c:	b570      	push	{r4, r5, r6, lr}
	// Position container
	uint32_t pos = 0;
    792e:	2400      	movs	r4, #0

	// Evaluate through digits as hex
	do
	{
		uint32_t cur = in % 16;
    7930:	f000 050f 	and.w	r5, r0, #15
		out[pos++] = cur + (( cur < 10 ) ? '0' : 'A' - 10);
    7934:	2d09      	cmp	r5, #9
    7936:	bf8c      	ite	hi
    7938:	2637      	movhi	r6, #55	; 0x37
    793a:	2630      	movls	r6, #48	; 0x30
    793c:	4435      	add	r5, r6
	}
	while ( (in /= 16) > 0 );
    793e:	0900      	lsrs	r0, r0, #4
    7940:	f104 0301 	add.w	r3, r4, #1

	// Evaluate through digits as hex
	do
	{
		uint32_t cur = in % 16;
		out[pos++] = cur + (( cur < 10 ) ? '0' : 'A' - 10);
    7944:	550d      	strb	r5, [r1, r4]
	}
	while ( (in /= 16) > 0 );
    7946:	d001      	beq.n	794c <hex32ToStr_op+0x20>

	// Evaluate through digits as hex
	do
	{
		uint32_t cur = in % 16;
		out[pos++] = cur + (( cur < 10 ) ? '0' : 'A' - 10);
    7948:	461c      	mov	r4, r3
    794a:	e7f1      	b.n	7930 <hex32ToStr_op+0x4>
	}
	while ( (in /= 16) > 0 );

	// Output formatting options
	switch ( op )
    794c:	2a02      	cmp	r2, #2
    794e:	d00a      	beq.n	7966 <hex32ToStr_op+0x3a>
    7950:	2a04      	cmp	r2, #4
    7952:	d008      	beq.n	7966 <hex32ToStr_op+0x3a>
    7954:	2a01      	cmp	r2, #1
    7956:	d10c      	bne.n	7972 <hex32ToStr_op+0x46>
	{
	case 1: // Add 0x
		out[pos++] = 'x';
    7958:	2278      	movs	r2, #120	; 0x78
    795a:	54ca      	strb	r2, [r1, r3]
		out[pos++] = '0';
    795c:	1ce3      	adds	r3, r4, #3
    795e:	440c      	add	r4, r1
    7960:	2230      	movs	r2, #48	; 0x30
    7962:	70a2      	strb	r2, [r4, #2]
		break;
    7964:	e005      	b.n	7972 <hex32ToStr_op+0x46>
	case 2: //  8-bit padding
	case 4: // 16-bit padding
		while ( pos < op )
    7966:	4293      	cmp	r3, r2
    7968:	d203      	bcs.n	7972 <hex32ToStr_op+0x46>
			out[pos++] = '0';
    796a:	2030      	movs	r0, #48	; 0x30
    796c:	54c8      	strb	r0, [r1, r3]
    796e:	3301      	adds	r3, #1
    7970:	e7f9      	b.n	7966 <hex32ToStr_op+0x3a>
		break;
	}

	// Append null
	out[pos] = '\0';
    7972:	2200      	movs	r2, #0
    7974:	54ca      	strb	r2, [r1, r3]

	// Reverse the string to the correct order
	revsStr(out);
    7976:	4608      	mov	r0, r1
}
    7978:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}

	// Append null
	out[pos] = '\0';

	// Reverse the string to the correct order
	revsStr(out);
    797c:	f7ff bf4d 	b.w	781a <revsStr>

00007980 <printHex32_op>:
	// Print number
	dPrintStr( tmpStr );
}

void printHex32_op( uint32_t in, uint8_t op )
{
    7980:	b507      	push	{r0, r1, r2, lr}
    7982:	460a      	mov	r2, r1
	// e.g. "0xFFFF\0"
	// op 2 and 4 require fewer characters (2+1 and 4+1 respectively)
	char tmpStr[7];

	// Convert number
	hex32ToStr_op( in, tmpStr, op );
    7984:	4669      	mov	r1, sp
    7986:	f7ff ffd1 	bl	792c <hex32ToStr_op>

	// Print number
	dPrintStr( tmpStr );
    798a:	4668      	mov	r0, sp
    798c:	f7fe fc3c 	bl	6208 <Output_putstr>
}
    7990:	b003      	add	sp, #12
    7992:	f85d fb04 	ldr.w	pc, [sp], #4

00007996 <eqStr>:
	return (pos - in);
}


int16_t eqStr( char* str1, char* str2 )
{
    7996:	b510      	push	{r4, lr}
    7998:	4603      	mov	r3, r0
	// Scan each string for NULLs and whether they are the same
	while( *str1 != '\0' && *str1++ == *str2++ );
    799a:	f810 2b01 	ldrb.w	r2, [r0], #1
    799e:	b122      	cbz	r2, 79aa <eqStr+0x14>
    79a0:	f811 4b01 	ldrb.w	r4, [r1], #1
    79a4:	4294      	cmp	r4, r2
    79a6:	4603      	mov	r3, r0
    79a8:	d0f6      	beq.n	7998 <eqStr+0x2>

	// If the strings are still identical (i.e. both NULL), then return -1, otherwise current *str1
	// If *str1 is 0, then str1 ended (and str1 is "like" str2), otherwise strings are different
	return *--str1 == *--str2 ? -1 : *++str1;
    79aa:	f813 0c01 	ldrb.w	r0, [r3, #-1]
    79ae:	f811 2c01 	ldrb.w	r2, [r1, #-1]
    79b2:	4290      	cmp	r0, r2
    79b4:	bf14      	ite	ne
    79b6:	7818      	ldrbne	r0, [r3, #0]
    79b8:	f64f 70ff 	movweq	r0, #65535	; 0xffff
}
    79bc:	b200      	sxth	r0, r0
    79be:	bd10      	pop	{r4, pc}

000079c0 <numToInt>:

int numToInt( char* in )
{
    79c0:	b570      	push	{r4, r5, r6, lr}
    79c2:	4601      	mov	r1, r0
	char* lsd = in;
	char* msd = in;

	int total = 0;
	int sign = 1; // Default to positive
	uint8_t base = 10; // Use base 10 by default TODO Add support for bases other than 10 and 16
    79c4:	250a      	movs	r5, #10
	// Pointers to the LSD (Least Significant Digit) and MSD
	char* lsd = in;
	char* msd = in;

	int total = 0;
	int sign = 1; // Default to positive
    79c6:	2601      	movs	r6, #1
    79c8:	460a      	mov	r2, r1
	uint8_t base = 10; // Use base 10 by default TODO Add support for bases other than 10 and 16

	// Scan the string once to determine the length
	while ( *lsd != '\0' )
    79ca:	f811 3b01 	ldrb.w	r3, [r1], #1
    79ce:	b193      	cbz	r3, 79f6 <numToInt+0x36>
	{
		// Check for positive/negative
		switch ( *lsd++ )
    79d0:	2b2b      	cmp	r3, #43	; 0x2b
    79d2:	460a      	mov	r2, r1
    79d4:	d00d      	beq.n	79f2 <numToInt+0x32>
    79d6:	d802      	bhi.n	79de <numToInt+0x1e>
    79d8:	2b20      	cmp	r3, #32
    79da:	d00a      	beq.n	79f2 <numToInt+0x32>
    79dc:	e003      	b.n	79e6 <numToInt+0x26>
    79de:	2b2d      	cmp	r3, #45	; 0x2d
    79e0:	d003      	beq.n	79ea <numToInt+0x2a>
    79e2:	2b78      	cmp	r3, #120	; 0x78
    79e4:	d004      	beq.n	79f0 <numToInt+0x30>
    79e6:	4602      	mov	r2, r0
    79e8:	e003      	b.n	79f2 <numToInt+0x32>
		{
		// Fall through is intentional, only do something on negative, ignore the rest
		// Update the MSD to remove leading spaces and signs
		case '-': sign = -1;
    79ea:	f04f 36ff 	mov.w	r6, #4294967295	; 0xffffffff
    79ee:	e000      	b.n	79f2 <numToInt+0x32>
		case '+':
		case ' ':
			msd = lsd;
			break;
		case 'x': // Hex Mode
			base = 0x10;
    79f0:	2510      	movs	r5, #16
		// Check for positive/negative
		switch ( *lsd++ )
		{
		// Fall through is intentional, only do something on negative, ignore the rest
		// Update the MSD to remove leading spaces and signs
		case '-': sign = -1;
    79f2:	4610      	mov	r0, r2
    79f4:	e7e8      	b.n	79c8 <numToInt+0x8>
			break;
		}
	}

	// Process string depending on which base
	switch ( base )
    79f6:	2d0a      	cmp	r5, #10
    79f8:	d004      	beq.n	7a04 <numToInt+0x44>
    79fa:	2d10      	cmp	r5, #16
    79fc:	d122      	bne.n	7a44 <numToInt+0x84>
    79fe:	4614      	mov	r4, r2
    7a00:	2101      	movs	r1, #1
    7a02:	e014      	b.n	7a2e <numToInt+0x6e>
    7a04:	2101      	movs	r1, #1
	{
	case 10: // Decimal
		// Rescan the string from the LSD to MSD to convert it to a decimal number
		for ( unsigned int digit = 1; lsd > msd ; digit *= 10 )
    7a06:	4282      	cmp	r2, r0
    7a08:	4614      	mov	r4, r2
    7a0a:	d91b      	bls.n	7a44 <numToInt+0x84>
			total += ( (*--lsd) - '0' ) * digit;
    7a0c:	f814 4c01 	ldrb.w	r4, [r4, #-1]
    7a10:	3c30      	subs	r4, #48	; 0x30
    7a12:	fb01 3304 	mla	r3, r1, r4, r3
	// Process string depending on which base
	switch ( base )
	{
	case 10: // Decimal
		// Rescan the string from the LSD to MSD to convert it to a decimal number
		for ( unsigned int digit = 1; lsd > msd ; digit *= 10 )
    7a16:	240a      	movs	r4, #10
    7a18:	3a01      	subs	r2, #1
    7a1a:	4361      	muls	r1, r4
    7a1c:	e7f3      	b.n	7a06 <numToInt+0x46>

	case 0x10: // Hex
		// Rescan the string from the LSD to MSD to convert it to a hexadecimal number
		for ( unsigned int digit = 1; lsd > msd ; digit *= 0x10 )
		{
			if    ( *--lsd <= '9' ) total += ( *lsd - '0' ) * digit;
    7a1e:	f814 2d01 	ldrb.w	r2, [r4, #-1]!
    7a22:	2a39      	cmp	r2, #57	; 0x39
    7a24:	d806      	bhi.n	7a34 <numToInt+0x74>
    7a26:	3a30      	subs	r2, #48	; 0x30
			else if ( *lsd <= 'F' ) total += ( *lsd - 'A' + 10 ) * digit;
			else if ( *lsd <= 'f' ) total += ( *lsd - 'a' + 10 ) * digit;
    7a28:	fb01 3302 	mla	r3, r1, r2, r3
			total += ( (*--lsd) - '0' ) * digit;
		break;

	case 0x10: // Hex
		// Rescan the string from the LSD to MSD to convert it to a hexadecimal number
		for ( unsigned int digit = 1; lsd > msd ; digit *= 0x10 )
    7a2c:	0109      	lsls	r1, r1, #4
    7a2e:	4284      	cmp	r4, r0
    7a30:	d8f5      	bhi.n	7a1e <numToInt+0x5e>
    7a32:	e007      	b.n	7a44 <numToInt+0x84>
		{
			if    ( *--lsd <= '9' ) total += ( *lsd - '0' ) * digit;
			else if ( *lsd <= 'F' ) total += ( *lsd - 'A' + 10 ) * digit;
    7a34:	2a46      	cmp	r2, #70	; 0x46
    7a36:	d801      	bhi.n	7a3c <numToInt+0x7c>
    7a38:	3a37      	subs	r2, #55	; 0x37
    7a3a:	e7f5      	b.n	7a28 <numToInt+0x68>
			else if ( *lsd <= 'f' ) total += ( *lsd - 'a' + 10 ) * digit;
    7a3c:	2a66      	cmp	r2, #102	; 0x66
    7a3e:	d8f5      	bhi.n	7a2c <numToInt+0x6c>
    7a40:	3a57      	subs	r2, #87	; 0x57
    7a42:	e7f1      	b.n	7a28 <numToInt+0x68>
		break;
	}

	// Propagate sign and return
	return total * sign;
}
    7a44:	fb06 f003 	mul.w	r0, r6, r3
    7a48:	bd70      	pop	{r4, r5, r6, pc}
    7a4a:	4d4e      	.short	0x4d4e
    7a4c:	0a0d2149 	.word	0x0a0d2149
    7a50:	72614800 	.word	0x72614800
    7a54:	61462064 	.word	0x61462064
    7a58:	21746c75 	.word	0x21746c75
    7a5c:	42435320 	.word	0x42435320
    7a60:	5346485f 	.word	0x5346485f
    7a64:	00203a52 	.word	0x00203a52
    7a68:	6f6d654d 	.word	0x6f6d654d
    7a6c:	4d207972 	.word	0x4d207972
    7a70:	67616e61 	.word	0x67616e61
    7a74:	46207265 	.word	0x46207265
    7a78:	746c7561 	.word	0x746c7561
    7a7c:	43532021 	.word	0x43532021
    7a80:	46435f42 	.word	0x46435f42
    7a84:	203a5253 	.word	0x203a5253
    7a88:	43532000 	.word	0x43532000
    7a8c:	4d4d5f42 	.word	0x4d4d5f42
    7a90:	203a5241 	.word	0x203a5241
    7a94:	73754200 	.word	0x73754200
    7a98:	75614620 	.word	0x75614620
    7a9c:	2021746c 	.word	0x2021746c
    7aa0:	5f424353 	.word	0x5f424353
    7aa4:	52534643 	.word	0x52534643
    7aa8:	2000203a 	.word	0x2000203a
    7aac:	5f424353 	.word	0x5f424353
    7ab0:	52414642 	.word	0x52414642
    7ab4:	5500203a 	.word	0x5500203a
    7ab8:	65676173 	.word	0x65676173
    7abc:	75614620 	.word	0x75614620
    7ac0:	2021746c 	.word	0x2021746c
    7ac4:	5f424353 	.word	0x5f424353
    7ac8:	52534643 	.word	0x52534643
    7acc:	203a      	.short	0x203a
    7ace:	00          	.byte	0x00

00007acf <sys_reset_to_loader_magic>:
    7acf:	ff 00 7f 52 45 53 45 54 20 54 4f 20 4c 4f 41 44     ...RESET TO LOAD
    7adf:	45 52 7f 00 ff 00 e8 fd 00                          ER.......

00007ae8 <ledWPageCLIDict_DescEntry>:
    7ae8:	57 72 69 74 65 20 74 6f 20 67 69 76 65 6e 20 72     Write to given r
    7af8:	65 67 69 73 74 65 72 20 70 61 67 65 20 73 74 61     egister page sta
    7b08:	72 74 69 6e 67 20 61 74 20 61 64 64 72 65 73 73     rting at address
    7b18:	2e 20 69 2e 65 2e 20 30 78 32 20 30 78 32 34 20     . i.e. 0x2 0x24 
    7b28:	30 78 46 30 20 30 78 31 32 00                       0xF0 0x12.

00007b32 <ledTestCLIDict_DescEntry>:
    7b32:	54 65 73 74 20 6f 75 74 20 74 68 65 20 6c 65 64     Test out the led
    7b42:	20 70 61 67 65 73 2e 00 00 00                        pages....

00007b4c <ledCLIDict>:
    7b4c:	9d 7d 00 00 d6 7e 00 00 89 2c 00 00 a5 7d 00 00     .}...~...,...}..
    7b5c:	4f 7f 00 00 01 2c 00 00 ad 7d 00 00 e0 7d 00 00     O....,...}...}..
    7b6c:	45 2e 00 00 b5 7d 00 00 b8 7b 00 00 d5 2b 00 00     E....}...{...+..
    7b7c:	be 7d 00 00 d6 7b 00 00 09 2b 00 00 c7 7d 00 00     .}...{...+...}..
    7b8c:	32 7b 00 00 e1 29 00 00 cf 7d 00 00 e8 7a 00 00     2{...)...}...z..
    7b9c:	11 2d 00 00 d8 7d 00 00 a5 7e 00 00 81 29 00 00     .-...}...~...)..
    7bac:	00 00 00 00 00 00 00 00 00 00 00 00                 ............

00007bb8 <ledRPageCLIDict_DescEntry>:
    7bb8:	52 65 61 64 20 74 68 65 20 67 69 76 65 6e 20 72     Read the given r
    7bc8:	65 67 69 73 74 65 72 20 70 61 67 65 2e 00           egister page..

00007bd6 <ledStartCLIDict_DescEntry>:
    7bd6:	44 69 73 61 62 6c 65 20 73 6f 66 74 77 61 72 65     Disable software
    7be6:	20 73 68 75 74 64 6f 77 6e 2e 00 1b 5b 31 3b 33      shutdown...[1;3
    7bf6:	35 6d 44 45 42 55 47 1b 5b 30 6d 20 2d 20 44 41     5mDEBUG.[0m - DA
    7c06:	54 41 3a 20 00 1b 5b 31 3b 33 33 6d 57 41 52 4e     TA: ..[1;33mWARN
    7c16:	49 4e 47 1b 5b 30 6d 20 2d 20 49 32 43 5f 42 75     ING.[0m - I2C_Bu
    7c26:	66 66 65 72 50 75 73 68 20 66 61 69 6c 65 64 2c     fferPush failed,
    7c36:	20 62 75 66 66 65 72 20 66 75 6c 6c 3a 20 00 1b      buffer full: ..
    7c46:	5b 31 3b 35 3b 33 31 6d 45 52 52 4f 52 1b 5b 30     [1;5;31mERROR.[0
    7c56:	6d 20 2d 20 4e 6f 20 62 75 66 66 65 72 20 74 6f     m - No buffer to
    7c66:	20 70 6f 70 20 61 6e 20 65 6e 74 72 79 20 66 72      pop an entry fr
    7c76:	6f 6d 2e 2e 2e 20 00 1b 5b 31 3b 35 3b 33 31 6d     om... ..[1;5;31m
    7c86:	45 52 52 4f 52 1b 5b 30 6d 20 2d 20 49 32 43 20     ERROR.[0m - I2C 
    7c96:	4e 41 4b 20 64 65 74 65 63 74 65 64 2e 2e 2e 0d     NAK detected....
    7ca6:	0a 00 1b 5b 31 3b 35 3b 33 31 6d 45 52 52 4f 52     ...[1;5;31mERROR
    7cb6:	1b 5b 30 6d 20 2d 20 41 72 62 69 74 72 61 74 69     .[0m - Arbitrati
    7cc6:	6f 6e 20 6c 6f 73 74 2e 2e 2e 0d 0a 00 1b 5b 31     on lost.......[1
    7cd6:	3b 35 3b 33 31 6d 45 52 52 4f 52 1b 5b 30 6d 20     ;5;31mERROR.[0m 
    7ce6:	2d 20 53 6c 61 76 65 20 41 64 64 72 65 73 73 20     - Slave Address 
    7cf6:	49 32 43 20 4e 41 4b 20 64 65 74 65 63 74 65 64     I2C NAK detected
    7d06:	2e 2e 2e 0d 0a 00 1b 5b 31 3b 33 35 6d 44 45 42     .......[1;35mDEB
    7d16:	55 47 1b 5b 30 6d 20 2d 20 41 74 74 65 6d 70 74     UG.[0m - Attempt
    7d26:	69 6e 67 20 74 6f 20 72 65 61 64 20 62 79 74 65     ing to read byte
    7d36:	20 2d 20 00 1b 5b 31 3b 33 35 6d 44 45 42 55 47      - ..[1;35mDEBUG
    7d46:	1b 5b 30 6d 20 2d 20 4e 45 58 54 0d 0a 00 1b 5b     .[0m - NEXT....[
    7d56:	31 3b 33 32 6d 49 4e 46 4f 1b 5b 30 6d 20 2d 20     1;32mINFO.[0m - 
    7d66:	53 65 6e 64 69 6e 67 3a 20 00 7c 20 00 4c 45 44     Sending: .| .LED
    7d76:	5f 63 6f 6e 74 72 6f 6c 5f 63 61 70 61 62 69 6c     _control_capabil
    7d86:	69 74 79 28 6d 6f 64 65 2c 61 6d 6f 75 6e 74 2c     ity(mode,amount,
    7d96:	69 6e 64 65 78 29 00 69 32 63 52 65 63 76 00 69     index).i2cRecv.i
    7da6:	32 63 53 65 6e 64 00 6c 65 64 43 74 72 6c 00 6c     2cSend.ledCtrl.l
    7db6:	65 64 52 50 61 67 65 00 6c 65 64 53 74 61 72 74     edRPage.ledStart
    7dc6:	00 6c 65 64 54 65 73 74 00 6c 65 64 57 50 61 67     .ledTest.ledWPag
    7dd6:	65 00 6c 65 64 5a 65 72 6f 00                       e.ledZero.

00007de0 <ledCtrlCLIDict_DescEntry>:
    7de0:	42 61 73 69 63 20 4c 45 44 20 63 6f 6e 74 72 6f     Basic LED contro
    7df0:	6c 2e 20 41 72 67 73 3a 20 3c 6d 6f 64 65 3e 20     l. Args: <mode> 
    7e00:	3c 61 6d 6f 75 6e 74 3e 20 5b 3c 69 6e 64 65 78     <amount> [<index
    7e10:	3e 5d 00                                            >].

00007e13 <LED_defaultBrightness1>:
    7e13:	e8 24 ff ff ff ff ff ff ff ff 00 00 00 00 00 00     .$..............
    7e23:	00 00 ff ff ff ff ff ff ff ff 00 00 00 00 00 00     ................
    7e33:	00 00 ff ff ff ff ff ff ff ff 00 00 00 00 00 00     ................
    7e43:	00 00 ff ff ff ff ff ff ff ff 00 00 00 00 00 00     ................
    7e53:	00 00 ff ff ff ff ff ff 00 00 00 00 00 00 00 00     ................
    7e63:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    7e73:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    7e83:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    7e93:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    7ea3:	00 00                                               ..

00007ea5 <ledZeroCLIDict_DescEntry>:
    7ea5:	5a 65 72 6f 20 6f 75 74 20 4c 45 44 20 72 65 67     Zero out LED reg
    7eb5:	69 73 74 65 72 20 70 61 67 65 73 20 28 6e 6f 6e     ister pages (non
    7ec5:	2d 63 6f 6e 66 69 67 75 72 61 74 69 6f 6e 29 2e     -configuration).
    7ed5:	00                                                  .

00007ed6 <i2cRecvCLIDict_DescEntry>:
    7ed6:	53 65 6e 64 20 49 32 43 20 73 65 71 75 65 6e 63     Send I2C sequenc
    7ee6:	65 20 6f 66 20 62 79 74 65 73 20 61 6e 64 20 65     e of bytes and e
    7ef6:	78 70 65 63 74 20 61 20 72 65 70 6c 79 20 6f 66     xpect a reply of
    7f06:	20 31 20 62 79 74 65 20 6f 6e 20 74 68 65 20 6c      1 byte on the l
    7f16:	61 73 74 20 73 65 71 75 65 6e 63 65 2e 0d 0a 09     ast sequence....
    7f26:	09 55 73 65 20 7c 27 73 20 74 6f 20 73 70 6c 69     .Use |'s to spli
    7f36:	74 20 73 65 71 75 65 6e 63 65 73 20 77 69 74 68     t sequences with
    7f46:	20 61 20 73 74 6f 70 2e 00                           a stop..

00007f4f <i2cSendCLIDict_DescEntry>:
    7f4f:	53 65 6e 64 20 49 32 43 20 73 65 71 75 65 6e 63     Send I2C sequenc
    7f5f:	65 20 6f 66 20 62 79 74 65 73 2e 20 55 73 65 20     e of bytes. Use 
    7f6f:	7c 27 73 20 74 6f 20 73 70 6c 69 74 20 73 65 71     |'s to split seq
    7f7f:	75 65 6e 63 65 73 20 77 69 74 68 20 61 20 73 74     uences with a st
    7f8f:	6f 70 2e 00                                         op..

00007f93 <LED_ledEnableMask1>:
    7f93:	e8 00 ff 00 ff 00 ff 00 ff 00 3f 00 00 00 00 00     ..........?.....
    7fa3:	00 00 00 00                                         ....

00007fa7 <ledCLIDictName>:
    7fa7:	49 53 53 49 20 4c 45 44 20 4d 6f 64 75 6c 65 20     ISSI LED Module 
    7fb7:	43 6f 6d 6d 61 6e 64 73 00                          Commands.

00007fc0 <matrixDebugCLIDict_DescEntry>:
    7fc0:	45 6e 61 62 6c 65 73 20 6d 61 74 72 69 78 20 64     Enables matrix d
    7fd0:	65 62 75 67 20 6d 6f 64 65 2c 20 70 72 69 6e 74     ebug mode, print
    7fe0:	73 20 6f 75 74 20 65 61 63 68 20 73 63 61 6e 20     s out each scan 
    7ff0:	63 6f 64 65 2e 0d 0a 09 09 49 66 20 61 72 67 75     code.....If argu
    8000:	6d 65 6e 74 20 1b 5b 33 35 6d 54 1b 5b 30 6d 20     ment .[35mT.[0m 
    8010:	69 73 20 67 69 76 65 6e 2c 20 70 72 69 6e 74 73     is given, prints
    8020:	20 6f 75 74 20 65 61 63 68 20 73 63 61 6e 20 63      out each scan c
    8030:	6f 64 65 20 73 74 61 74 65 20 74 72 61 6e 73 69     ode state transi
    8040:	74 69 6f 6e 2e 00 1b 5b 31 3b 33 32 6d 49 4e 46     tion...[1;32mINF
    8050:	4f 1b 5b 30 6d 20 2d 20 4d 61 74 72 69 78 20 44     O.[0m - Matrix D
    8060:	65 62 75 67 20 4d 6f 64 65 3a 20 00 1b 5b 31 3b     ebug Mode: ..[1;
    8070:	33 32 6d 49 4e 46 4f 1b 5b 30 6d 20 2d 20 43 6f     32mINFO.[0m - Co
    8080:	6c 75 6d 6e 73 3a 20 20 00 1b 5b 31 3b 33 32 6d     lumns:  ..[1;32m
    8090:	49 4e 46 4f 1b 5b 30 6d 20 2d 20 52 6f 77 73 3a     INFO.[0m - Rows:
    80a0:	20 20 20 20 20 00 1b 5b 31 3b 33 32 6d 49 4e 46          ..[1;32mINF
    80b0:	4f 1b 5b 30 6d 20 2d 20 4d 61 78 20 4b 65 79 73     O.[0m - Max Keys
    80c0:	3a 20 00 1b 5b 31 6d 4f 1b 5b 30 6d 00 1b 5b 31     : ..[1mO.[0m..[1
    80d0:	3b 33 33 6d 50 1b 5b 30 6d 00 1b 5b 31 3b 33 32     ;33mP.[0m..[1;32
    80e0:	6d 48 1b 5b 30 6d 00 1b 5b 31 3b 33 35 6d 52 1b     mH.[0m..[1;35mR.
    80f0:	5b 30 6d 00 1b 5b 31 3b 33 31 6d 49 1b 5b 30 6d     [0m..[1;31mI.[0m
    8100:	00 1b 5b 31 3b 35 3b 33 31 6d 45 52 52 4f 52 1b     ..[1;5;31mERROR.
    8110:	5b 30 6d 20 2d 20 4d 61 74 72 69 78 20 73 63 61     [0m - Matrix sca
    8120:	6e 20 62 75 67 21 21 20 52 65 70 6f 72 74 20 6d     n bug!! Report m
    8130:	65 21 0d 0a 00 1b 5b 31 3b 33 32 6d 49 4e 46 4f     e!....[1;32mINFO
    8140:	1b 5b 30 6d 20 2d 20 4d 61 78 20 73 63 61 6e 73     .[0m - Max scans
    8150:	3a 20 20 20 20 20 20 00 1b 5b 31 3b 33 32 6d 49     :      ..[1;32mI
    8160:	4e 46 4f 1b 5b 30 6d 20 2d 20 50 72 65 76 69 6f     NFO.[0m - Previo
    8170:	75 73 20 73 63 61 6e 73 3a 20 00 1b 5b 31 3b 33     us scans: ..[1;3
    8180:	32 6d 49 4e 46 4f 1b 5b 30 6d 20 2d 20 53 63 61     2mINFO.[0m - Sca
    8190:	6e 20 4e 75 6d 62 65 72 3a 20 20 20 20 00 3c 6b     n Number:    .<k
    81a0:	65 79 3e 3a 3c 70 72 65 76 69 6f 75 73 20 73 74     ey>:<previous st
    81b0:	61 74 65 3e 3c 63 75 72 72 65 6e 74 20 73 74 61     ate><current sta
    81c0:	74 65 3e 20 3c 61 63 74 69 76 65 20 63 6f 75 6e     te> <active coun
    81d0:	74 3e 20 3c 69 6e 61 63 74 69 76 65 20 63 6f 75     t> <inactive cou
    81e0:	6e 74 3e 00 1b 5b 31 6d 30 78 00 3a 00 20 30 78     nt>..[1m0x.:. 0x
    81f0:	00 6d 61 74 72 69 78 44 65 62 75 67 00 6d 61 74     .matrixDebug.mat
    8200:	72 69 78 53 74 61 74 65 00                          rixState.

00008209 <matrixStateCLIDict_DescEntry>:
    8209:	50 72 69 6e 74 73 20 6f 75 74 20 74 68 65 20 63     Prints out the c
    8219:	75 72 72 65 6e 74 20 73 63 61 6e 20 74 61 62 6c     urrent scan tabl
    8229:	65 20 4e 20 74 69 6d 65 73 2e 0d 0a 09 09 20 1b     e N times..... .
    8239:	5b 31 6d 4f 1b 5b 30 6d 20 2d 20 4f 66 66 2c 20     [1mO.[0m - Off, 
    8249:	1b 5b 31 3b 33 33 6d 50 1b 5b 30 6d 20 2d 20 50     .[1;33mP.[0m - P
    8259:	72 65 73 73 2c 20 1b 5b 31 3b 33 32 6d 48 1b 5b     ress, .[1;32mH.[
    8269:	30 6d 20 2d 20 48 6f 6c 64 2c 20 1b 5b 31 3b 33     0m - Hold, .[1;3
    8279:	35 6d 52 1b 5b 30 6d 20 2d 20 52 65 6c 65 61 73     5mR.[0m - Releas
    8289:	65 2c 20 1b 5b 31 3b 33 31 6d 49 1b 5b 30 6d 20     e, .[1;31mI.[0m 
    8299:	2d 20 49 6e 76 61 6c 69 64 00                       - Invalid.

000082a3 <matrixCLIDictName>:
    82a3:	4d 61 74 72 69 78 20 4d 6f 64 75 6c 65 20 43 6f     Matrix Module Co
    82b3:	6d 6d 61 6e 64 73 00 00 00                          mmands...

000082bc <matrixCLIDict>:
    82bc:	f1 81 00 00 c0 7f 00 00 5d 2f 00 00 fd 81 00 00     ........]/......
    82cc:	09 82 00 00 39 2f 00 00 00 00 00 00 00 00 00 00     ....9/..........
    82dc:	00 00 00 00 00 00 00 ff ff ff ff ff ff 3f 3f 3f     .............???
    82ec:	3f 3f 3f 3f 3f 3f 3f 3f 3f 3f 3f ff ff ff ff ff     ???????????.....
    82fc:	ff 00 00 00 00 00 00 ff ff ff ff ff ff 00 00 00     ................
    830c:	00 00 00 00 00 00 00 00 00 00 00 ff ff ff ff ff     ................
    831c:	ff 00 00 00 00 00 00 ff ff ff ff ff ff 00 00 00     ................
    832c:	00 00 00 00 00 00 00 00 00 00 00 ff ff ff ff ff     ................
    833c:	ff 00 00 00 00 00 00 ff ff ff ff ff ff fc fc fc     ................
    834c:	fc fc fc fc fc fc fc fc fc fc fc ff ff ff ff ff     ................
    835c:	ff 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    836c:	ff ff ff ff ff ff ff ff 00 00 00 00 00 00 00 00     ................
    837c:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    838c:	ff ff ff ff ff ff ff ff 00 00 00 00 00 00 00 00     ................
    839c:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    83ac:	ff ff ff ff ff ff ff ff 00 00 00 00 00 00 00 00     ................
    83bc:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    83cc:	ff ff ff ff ff ff ff ff 00 00 00 00 00 00 00 00     ................
    83dc:	00 00 00 00 00 00 00 ff ff ff ff ff ff 3f 3f 3f     .............???
    83ec:	3f 3f 3f 3f 3f 3f 3f 3f 3f 3f 3f 3f 3f 3f 3f 3f     ????????????????
    83fc:	3f 00 00 00 00 00 00 ff ff ff ff ff ff e0 e0 e0     ?...............
    840c:	e0 e0 e0 e0 e0 e0 e0 e0 e0 e0 e0 e0 e0 e0 e0 e0     ................
    841c:	e0 00 00 00 00 00 00 07 07 07 07 07 07 07 07 07     ................
    842c:	07 07 07 07 07 07 07 07 07 07 07 ff ff ff ff ff     ................
    843c:	ff 00 00 00 00 00 00 fc fc fc fc fc fc fc fc fc     ................
    844c:	fc fc fc fc fc fc fc fc fc fc fc ff ff ff ff ff     ................
    845c:	ff 00 00 00 00 00 00 3f 3f 3f 3f 3f 3f 3f 3f 3f     .......?????????
    846c:	3f 3f 3f 3f 3f 3f 3f 3f 3f 3f 3f ff ff ff ff ff     ???????????.....
    847c:	ff 00 00 00 00 00 00 00 00 00 00 00 00 e0 e0 e0     ................
    848c:	e0 e0 e0 e0 e0 e0 e0 e0 e0 e0 e0 ff ff ff ff ff     ................
    849c:	ff 00 00 00 00 00 00 00 00 00 00 00 00 07 07 07     ................
    84ac:	07 07 07 07 07 07 07 07 07 07 07 ff ff ff ff ff     ................
    84bc:	ff 00 00 00 00 00 00 fc fc fc fc fc fc fc fc fc     ................
    84cc:	fc fc fc fc fc fc fc fc fc fc fc ff ff ff ff ff     ................
    84dc:	ff 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    84ec:	00 00 00 00 00 00 00 00 00 00 00 ff ff ff ff ff     ................
    84fc:	ff 00 00 00 00 00 00 e0 e0 e0 e0 e0 e0 e0 e0 e0     ................
    850c:	e0 e0 e0 e0 e0 e0 e0 e0 e0 e0 e0 ff ff ff ff ff     ................
    851c:	ff 00 00 00 00 00 00 ff ff ff ff ff ff 07 07 07     ................
    852c:	07 07 07 07 07 07 07 07 07 07 07 ff ff ff ff ff     ................
    853c:	ff 00 00 00 00 00 00 ff ff ff ff ff ff 00 00 00     ................
    854c:	00 00 00 00 00 00 00 00 00 00 00 ff ff ff ff ff     ................
    855c:	ff 00 00 00 00 00 00 3f 3f 3f 3f 3f 3f 3f 3f 3f     .......?????????
    856c:	3f 3f 3f 3f 3f 3f 3f 3f 3f 3f 3f ff ff ff ff ff     ???????????.....
    857c:	ff 00 00 00 00 00 00 e0 e0 e0 e0 e0 e0 e0 e0 e0     ................
    858c:	e0 e0 e0 e0 e0 e0 e0 e0 e0 e0 e0 ff ff ff ff ff     ................
    859c:	ff 00 00 00 00 00 00 ff ff ff ff ff ff 07 07 07     ................
    85ac:	07 07 07 07 07 07 07 07 07 07 07 07 07 07 07 07     ................
    85bc:	07 00 00 00 00 00 00 ff ff ff ff ff ff fc fc fc     ................
    85cc:	fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc     ................
    85dc:	fc 00 00 00 00 00 00 ff ff ff ff ff ff 3f 3f 3f     .............???
    85ec:	3f 3f 3f 3f 3f 3f 3f 3f 3f 3f 3f ff ff ff ff ff     ???????????.....
    85fc:	ff 00 00 00 00 00 00 ff ff ff ff ff ff e0 e0 e0     ................
    860c:	e0 e0 e0 e0 e0 e0 e0 e0 e0 e0 e0 ff ff ff ff ff     ................
    861c:	ff 00 00 00 00 00 00 ff ff ff ff ff ff 07 07 07     ................
    862c:	07 07 07 07 07 07 07 07 07 07 07 07 07 07 07 07     ................
    863c:	07 00 00 00 00 00 00 ff ff ff ff ff ff fc fc fc     ................
    864c:	fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc     ................
    865c:	fc 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    866c:	00 00 00 00 00 00 00 00 00 00 00 ff ff ff ff ff     ................
    867c:	ff 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    868c:	00 00 00 00 e0 e0 e0 e0 e0 e0 e0 ff ff ff ff ff     ................
    869c:	ff 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    86ac:	00 00 00 00 07 07 07 07 07 07 07 ff ff ff ff ff     ................
    86bc:	ff 00 00 00 00 00 00 fc fc fc fc fc fc fc fc fc     ................
    86cc:	fc fc fc fc fc fc fc fc fc fc fc ff ff ff ff ff     ................
    86dc:	ff 00 00 00 00 00 00 ff ff ff ff ff ff 3f 3f 3f     .............???
    86ec:	3f 3f 3f 3f 3f 3f 3f 3f 3f 3f 3f ff ff ff ff ff     ???????????.....
    86fc:	ff 00 00 00 00 00 00 ff ff ff ff ff ff e0 e0 e0     ................
    870c:	e0 e0 e0 e0 e0 e0 e0 e0 e0 e0 e0 ff ff ff ff ff     ................
    871c:	ff 00 00 00 00 00 00 ff ff ff ff ff ff 07 07 07     ................
    872c:	07 07 07 07 07 07 07 07 07 07 07 ff ff ff ff ff     ................
    873c:	ff 00 00 00 00 00 00 ff ff ff ff ff ff fc fc fc     ................
    874c:	fc fc fc fc fc fc fc fc fc fc fc ff ff ff ff ff     ................
    875c:	ff 00 00 00 00 00 00 3f 3f 3f 3f 3f 3f 3f 3f 3f     .......?????????
    876c:	3f 3f 3f 3f 3f 3f 3f 3f 3f 3f 3f ff ff ff ff ff     ???????????.....
    877c:	ff 00 00 00 00 00 00 e0 e0 e0 e0 e0 e0 e0 e0 e0     ................
    878c:	e0 e0 e0 e0 e0 e0 e0 e0 e0 e0 e0 ff ff ff ff ff     ................
    879c:	ff 00 00 00 00 00 00 ff ff ff ff ff ff 07 07 07     ................
    87ac:	07 07 07 07 07 07 07 07 07 07 07 ff ff ff ff ff     ................
    87bc:	ff 00 00 00 00 00 00 ff ff ff ff ff ff fc fc fc     ................
    87cc:	fc fc fc fc fc fc fc fc fc fc fc ff ff ff ff ff     ................
    87dc:	ff 00 00 00 39 b9 ea aa 8d 8d a8 a8 27 27 a0 1f     ....9.......''..
    87ec:	4b 4b 8d 8d b5 34 00 00 42 82 f3 b3 f6 f6 a5 a5     KK...4..B.......
    87fc:	49 49 b7 b7 5d 5d 45 85 fc bc f6 b6 2d 2d c1 00     II..]]E.....--..
    880c:	7e 7e 3c 3c 03 83 94 13 f9 b9 ca 09 d3 12 84 84     ~~<<............

0000881c <lcdTestCLIDict_DescEntry>:
    881c:	54 65 73 74 20 6f 75 74 20 74 68 65 20 4c 43 44     Test out the LCD
    882c:	20 64 69 73 70 6c 61 79 2e 00                        display..

00008836 <lcdCLIDictName>:
    8836:	53 54 20 4c 43 44 20 4d 6f 64 75 6c 65 20 43 6f     ST LCD Module Co
    8846:	6d 6d 61 6e 64 73 00 00 00 00                       mmands....

00008850 <lcdCLIDict>:
    8850:	11 89 00 00 39 89 00 00 0d 35 00 00 18 89 00 00     ....9....5......
    8860:	7d 8b 00 00 35 34 00 00 21 89 00 00 c2 8b 00 00     }...54..!.......
    8870:	5d 35 00 00 29 89 00 00 10 8c 00 00 d3 36 00 00     ]5..)........6..
    8880:	31 89 00 00 1c 88 00 00 05 36 00 00 00 00 00 00     1........6......
    8890:	00 00 00 00 00 00 00 00 1b 5b 31 3b 33 32 6d 49     .........[1;32mI
    88a0:	4e 46 4f 1b 5b 30 6d 20 2d 20 53 65 6e 64 69 6e     NFO.[0m - Sendin
    88b0:	67 20 2d 20 00 4c 43 44 5f 6c 61 79 65 72 53 74     g - .LCD_layerSt
    88c0:	61 63 6b 45 78 61 63 74 5f 63 61 70 61 62 69 6c     ackExact_capabil
    88d0:	69 74 79 28 6e 75 6d 2c 6c 61 79 65 72 31 2c 6c     ity(num,layer1,l
    88e0:	61 79 65 72 32 2c 6c 61 79 65 72 33 2c 6c 61 79     ayer2,layer3,lay
    88f0:	65 72 34 29 00 4c 43 44 5f 6c 61 79 65 72 53 74     er4).LCD_layerSt
    8900:	61 63 6b 5f 63 61 70 61 62 69 6c 69 74 79 28 29     ack_capability()
    8910:	00 6c 63 64 43 6d 64 00 6c 63 64 43 6f 6c 6f 72     .lcdCmd.lcdColor
    8920:	00 6c 63 64 44 69 73 70 00 6c 63 64 49 6e 69 74     .lcdDisp.lcdInit
    8930:	00 6c 63 64 54 65 73 74 00                          .lcdTest.

00008939 <lcdCmdCLIDict_DescEntry>:
    8939:	53 65 6e 64 20 62 79 74 65 20 76 69 61 20 53 50     Send byte via SP
    8949:	49 2c 20 73 65 63 6f 6e 64 20 61 72 67 75 6d 65     I, second argume
    8959:	6e 74 20 65 6e 61 62 6c 65 73 20 61 30 2e 20 44     nt enables a0. D
    8969:	65 66 61 75 6c 74 73 20 74 6f 20 63 6f 6e 74 72     efaults to contr
    8979:	6f 6c 2e 00                                         ol..

0000897d <STLcdDefaultImage>:
    897d:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    898d:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    899d:	ff ff ff ff ff 00 00 00 00 00 00 00 00 00 00 00     ................
    89ad:	c0 c0 c0 c0 c0 00 00 00 00 00 00 00 00 00 00 00     ................
    89bd:	ff ff ff ff ff 1f 1f 1f 1f 1f 1f 1f 1f 1f 1f 1f     ................
    89cd:	1f 1f 1f 1f 1f 1f 1f 1f 1f 1f 1f 1f 1f 1f 1f 1f     ................
    89dd:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    89ed:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    89fd:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    8a0d:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    8a1d:	ff ff ff ff ff 00 00 00 00 00 00 00 00 00 00 00     ................
    8a2d:	03 03 03 03 03 00 00 00 00 00 00 00 00 00 00 00     ................
    8a3d:	ff ff ff ff ff 00 00 00 00 00 00 00 00 00 00 00     ................
    8a4d:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    8a5d:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    8a6d:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    8a7d:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    8a8d:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    8a9d:	ff ff ff ff ff 00 00 00 00 00 00 00 00 00 00 00     ................
    8aad:	c0 c0 c0 c0 c0 00 00 00 00 00 00 00 00 00 00 00     ................
    8abd:	ff ff ff ff ff 00 00 00 00 00 00 00 00 00 00 00     ................
    8acd:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    8add:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    8aed:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    8afd:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    8b0d:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    8b1d:	ff ff ff ff ff 00 00 00 00 00 00 00 00 00 00 00     ................
    8b2d:	03 03 03 03 03 00 00 00 00 00 00 00 00 00 00 00     ................
    8b3d:	ff ff ff ff ff f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8     ................
    8b4d:	f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8     ................
    8b5d:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    8b6d:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................

00008b7d <lcdColorCLIDict_DescEntry>:
    8b7d:	53 65 74 20 62 61 63 6b 6c 69 67 68 74 20 63 6f     Set backlight co
    8b8d:	6c 6f 72 2e 20 33 20 31 36 2d 62 69 74 20 6e 75     lor. 3 16-bit nu
    8b9d:	6d 62 65 72 73 3a 20 52 20 47 20 42 2e 20 69 2e     mbers: R G B. i.
    8bad:	65 2e 20 30 78 46 46 46 20 30 78 31 34 34 34 20     e. 0xFFF 0x1444 
    8bbd:	30 78 33 32 00                                      0x32.

00008bc2 <lcdDispCLIDict_DescEntry>:
    8bc2:	57 72 69 74 65 20 62 79 74 65 28 73 29 20 74 6f     Write byte(s) to
    8bd2:	20 67 69 76 65 6e 20 70 61 67 65 20 73 74 61 72      given page star
    8be2:	74 69 6e 67 20 61 74 20 67 69 76 65 6e 20 61 64     ting at given ad
    8bf2:	64 72 65 73 73 2e 20 69 2e 65 2e 20 30 78 31 20     dress. i.e. 0x1 
    8c02:	30 78 35 20 30 78 46 46 20 30 78 30 30 00           0x5 0xFF 0x00.

00008c10 <lcdInitCLIDict_DescEntry>:
    8c10:	52 65 2d 69 6e 69 74 69 61 6c 69 7a 65 20 74 68     Re-initialize th
    8c20:	65 20 4c 43 44 20 64 69 73 70 6c 61 79 2e 00 00     e LCD display...
    8c30:	e3 91 00 00 ee 91 00 00 f8 91 00 00 06 92 00 00     ................
    8c40:	0f 92 00 00 18 92 00 00 22 92 00 00 33 92 00 00     ........"...3...
    8c50:	40 92 00 00 16 01 16 01 01 00 01 05 00 03 16 00     @...............

00008c60 <uartConnectCLIDict>:
    8c60:	4c 92 00 00 60 93 00 00 15 43 00 00 57 92 00 00     L...`....C..W...
    8c70:	c0 8c 00 00 d5 39 00 00 62 92 00 00 cc 93 00 00     .....9..b.......
    8c80:	a9 44 00 00 6d 92 00 00 99 92 00 00 11 3b 00 00     .D..m........;..
    8c90:	78 92 00 00 e7 92 00 00 b1 3c 00 00 83 92 00 00     x........<......
    8ca0:	25 93 00 00 29 45 00 00 8e 92 00 00 df 8c 00 00     %...)E..........
    8cb0:	69 3b 00 00 00 00 00 00 00 00 00 00 00 00 00 00     i;..............

00008cc0 <connectDbgCLIDict_DescEntry>:
    8cc0:	54 6f 67 67 6c 65 20 55 41 52 54 43 6f 6e 6e 65     Toggle UARTConne
    8cd0:	63 74 20 64 65 62 75 67 20 6d 6f 64 65 2e 00        ct debug mode..

00008cdf <connectStsCLIDict_DescEntry>:
    8cdf:	55 41 52 54 43 6f 6e 6e 65 63 74 20 73 74 61 74     UARTConnect stat
    8cef:	75 73 2e 00 1b 5b 31 3b 33 35 6d 44 45 42 55 47     us...[1;35mDEBUG
    8cff:	1b 5b 30 6d 20 2d 20 41 6e 69 6d 61 74 69 6f 6e     .[0m - Animation
    8d0f:	0d 0a 00 1b 5b 31 3b 33 32 6d 49 4e 46 4f 1b 5b     ....[1;32mINFO.[
    8d1f:	30 6d 20 2d 20 43 6f 6e 6e 65 63 74 20 44 65 62     0m - Connect Deb
    8d2f:	75 67 20 4d 6f 64 65 20 54 6f 67 67 6c 65 00 1b     ug Mode Toggle..
    8d3f:	5b 31 3b 33 35 6d 44 45 42 55 47 1b 5b 30 6d 20     [1;35mDEBUG.[0m 
    8d4f:	2d 20 50 45 4e 44 49 4e 47 20 53 45 54 20 2d 3e     - PENDING SET ->
    8d5f:	20 00 1b 5b 31 3b 33 33 6d 57 41 52 4e 49 4e 47      ..[1;33mWARNING
    8d6f:	1b 5b 30 6d 20 2d 20 43 61 62 6c 65 20 46 61 75     .[0m - Cable Fau
    8d7f:	6c 74 21 0d 0a 00 20 53 6c 61 76 65 20 00 20 4d     lt!... Slave . M
    8d8f:	61 73 74 65 72 20 00 1b 5b 31 3b 33 35 6d 44 45     aster ..[1;35mDE
    8d9f:	42 55 47 1b 5b 30 6d 20 2d 20 43 41 42 4c 45 43     BUG.[0m - CABLEC
    8daf:	48 45 43 4b 20 52 45 43 45 49 56 45 20 2d 20 00     HECK RECEIVE - .
    8dbf:	1b 5b 31 3b 33 32 6d 49 4e 46 4f 1b 5b 30 6d 20     .[1;32mINFO.[0m 
    8dcf:	2d 20 4c 69 73 74 20 6f 66 20 55 41 52 54 43 6f     - List of UARTCo
    8ddf:	6e 6e 65 63 74 20 63 6f 6d 6d 61 6e 64 73 00 4d     nnect commands.M
    8def:	61 73 74 65 72 00 53 6c 61 76 65 00 1b 5b 31 3b     aster.Slave..[1;
    8dff:	33 32 6d 49 4e 46 4f 1b 5b 30 6d 20 2d 20 55 41     32mINFO.[0m - UA
    8e0f:	52 54 43 6f 6e 6e 65 63 74 20 53 74 61 74 75 73     RTConnect Status
    8e1f:	00 0d 0a 44 65 76 69 63 65 20 54 79 70 65 3a 09     ...Device Type:.
    8e2f:	00 0d 0a 44 65 76 69 63 65 20 49 64 3a 09 00 0d     ...Device Id:...
    8e3f:	0a 4d 61 78 20 49 64 3a 09 00 0d 0a 4d 61 73 74     .Max Id:....Mast
    8e4f:	65 72 20 3c 3d 0d 0a 09 53 74 61 74 75 73 3a 09     er <=...Status:.
    8e5f:	00 0d 0a 09 46 61 75 6c 74 73 3a 09 00 2f 00 0d     ....Faults:../..
    8e6f:	0a 09 52 78 3a 09 00 0d 0a 09 54 78 3a 09 00 0d     ..Rx:.....Tx:...
    8e7f:	0a 53 6c 61 76 65 20 3c 3d 0d 0a 09 53 74 61 74     .Slave <=...Stat
    8e8f:	75 73 3a 09 00 1b 5b 31 3b 33 32 6d 49 4e 46 4f     us:...[1;32mINFO
    8e9f:	1b 5b 30 6d 20 2d 20 53 65 74 74 69 6e 67 20 64     .[0m - Setting d
    8eaf:	65 76 69 63 65 20 61 73 20 73 6c 61 76 65 2e 00     evice as slave..
    8ebf:	1b 5b 31 3b 33 32 6d 49 4e 46 4f 1b 5b 30 6d 20     .[1;32mINFO.[0m 
    8ecf:	2d 20 53 65 74 74 69 6e 67 20 64 65 76 69 63 65     - Setting device
    8edf:	20 61 73 20 6d 61 73 74 65 72 2e 00 1b 5b 31 3b      as master...[1;
    8eef:	33 33 6d 57 41 52 4e 49 4e 47 1b 5b 30 6d 20 2d     33mWARNING.[0m -
    8eff:	20 54 6f 6f 20 6d 75 63 68 20 64 61 74 61 20 74      Too much data t
    8f0f:	6f 20 73 65 6e 64 20 6f 6e 20 55 41 52 54 00 2c     o send on UART.,
    8f1f:	20 77 61 69 74 69 6e 67 2e 2e 2e 0d 0a 00 20 2b      waiting...... +
    8f2f:	00 1b 5b 31 3b 35 3b 33 31 6d 45 52 52 4f 52 1b     ..[1;5;31mERROR.
    8f3f:	5b 30 6d 20 2d 20 49 6e 76 61 6c 69 64 20 53 63     [0m - Invalid Sc
    8f4f:	61 6e 43 6f 64 65 20 64 69 72 65 63 74 69 6f 6e     anCode direction
    8f5f:	2e 2e 2e 0d 0a 00 1b 5b 31 3b 33 33 6d 57 41 52     .......[1;33mWAR
    8f6f:	4e 49 4e 47 1b 5b 30 6d 20 2d 20 4e 6f 74 20 65     NING.[0m - Not e
    8f7f:	6e 6f 75 67 68 20 69 6e 74 65 72 63 6f 6e 6e 65     nough interconne
    8f8f:	63 74 20 6c 61 79 6f 75 74 20 6e 6f 64 65 73 20     ct layout nodes 
    8f9f:	63 6f 6e 66 69 67 75 72 65 64 3a 20 00 1b 5b 31     configured: ..[1
    8faf:	3b 33 35 6d 44 45 42 55 47 1b 5b 30 6d 20 2d 20     ;35mDEBUG.[0m - 
    8fbf:	00 1b 5b 31 3b 35 3b 33 31 6d 45 52 52 4f 52 1b     ..[1;5;31mERROR.
    8fcf:	5b 30 6d 20 2d 20 54 6f 6f 20 62 69 67 20 6f 66     [0m - Too big of
    8fdf:	20 61 20 63 6f 6d 6d 61 6e 64 20 74 6f 20 66 69      a command to fi
    8fef:	74 20 69 6e 74 6f 20 74 68 65 20 62 75 66 66 65     t into the buffe
    8fff:	72 2e 2e 2e 00 1b 5b 31 3b 35 3b 33 31 6d 45 52     r.....[1;5;31mER
    900f:	52 4f 52 1b 5b 30 6d 20 2d 20 49 6e 76 61 6c 69     ROR.[0m - Invali
    901f:	64 20 55 41 52 54 20 74 6f 20 73 65 6e 64 20 66     d UART to send f
    902f:	72 6f 6d 2e 2e 2e 0d 0a 00 1b 5b 31 3b 33 35 6d     rom.......[1;35m
    903f:	44 45 42 55 47 1b 5b 30 6d 20 2d 20 49 64 52 65     DEBUG.[0m - IdRe
    904f:	71 75 65 73 74 0d 0a 00 1b 5b 31 3b 35 3b 33 31     quest....[1;5;31
    905f:	6d 45 52 52 4f 52 1b 5b 30 6d 20 2d 20 49 6e 76     mERROR.[0m - Inv
    906f:	61 6c 69 64 20 49 64 52 65 71 75 65 73 74 20 64     alid IdRequest d
    907f:	69 72 65 63 74 69 6f 6e 2e 2e 2e 0d 0a 00 1b 5b     irection.......[
    908f:	31 3b 33 35 6d 44 45 42 55 47 1b 5b 30 6d 20 2d     1;35mDEBUG.[0m -
    909f:	20 49 64 45 6e 75 6d 65 72 61 74 69 6f 6e 0d 0a      IdEnumeration..
    90af:	00 1b 5b 31 3b 35 3b 33 31 6d 45 52 52 4f 52 1b     ..[1;5;31mERROR.
    90bf:	5b 30 6d 20 2d 20 49 6e 76 61 6c 69 64 20 49 64     [0m - Invalid Id
    90cf:	45 6e 75 6d 65 72 61 74 69 6f 6e 20 64 69 72 65     Enumeration dire
    90df:	63 74 69 6f 6e 2e 2e 2e 0d 0a 00 1b 5b 31 3b 33     ction.......[1;3
    90ef:	35 6d 44 45 42 55 47 1b 5b 30 6d 20 2d 20 49 64     5mDEBUG.[0m - Id
    90ff:	52 65 70 6f 72 74 0d 0a 00 1b 5b 31 3b 33 32 6d     Report....[1;32m
    910f:	49 4e 46 4f 1b 5b 30 6d 20 2d 20 49 64 20 52 65     INFO.[0m - Id Re
    911f:	70 6f 72 74 65 64 3a 20 00 1b 5b 31 3b 33 32 6d     ported: ..[1;32m
    912f:	49 4e 46 4f 1b 5b 30 6d 20 2d 20 53 65 6e 64 69     INFO.[0m - Sendi
    913f:	6e 67 20 53 79 6e 63 20 49 64 6c 65 73 2e 2e 2e     ng Sync Idles...
    914f:	00 1b 5b 31 3b 33 32 6d 49 4e 46 4f 1b 5b 30 6d     ..[1;32mINFO.[0m
    915f:	20 2d 20 52 65 73 65 74 74 69 6e 67 20 55 41 52      - Resetting UAR
    916f:	54 43 6f 6e 6e 65 63 74 20 73 74 61 74 65 2e 2e     TConnect state..
    917f:	2e 00 20 57 61 69 74 20 00 20 53 59 4e 20 00 20     .. Wait . SYN . 
    918f:	53 4f 48 20 00 20 23 23 23 20 00 20 43 4d 44 20     SOH . ### . CMD 
    919f:	00 1b 5b 31 3b 35 3b 33 31 6d 45 52 52 4f 52 1b     ..[1;5;31mERROR.
    91af:	5b 30 6d 20 2d 20 49 6e 76 61 6c 69 64 20 55 41     [0m - Invalid UA
    91bf:	52 54 53 74 61 74 75 73 2e 2e 2e 00 54 78 46 49     RTStatus....TxFI
    91cf:	46 4f 20 30 20 2d 20 00 54 78 46 49 46 4f 20 31     FO 0 - .TxFIFO 1
    91df:	20 2d 20 00 43 61 62 6c 65 43 68 65 63 6b 00 49      - .CableCheck.I
    91ef:	64 52 65 71 75 65 73 74 00 49 64 45 6e 75 6d 65     dRequest.IdEnume
    91ff:	72 61 74 69 6f 6e 00 49 64 52 65 70 6f 72 74 00     ration.IdReport.
    920f:	53 63 61 6e 43 6f 64 65 00 41 6e 69 6d 61 74 69     ScanCode.Animati
    921f:	6f 6e 00 52 65 6d 6f 74 65 43 61 70 61 62 69 6c     on.RemoteCapabil
    922f:	69 74 79 00 52 65 6d 6f 74 65 4f 75 74 70 75 74     ity.RemoteOutput
    923f:	00 52 65 6d 6f 74 65 49 6e 70 75 74 00 63 6f 6e     .RemoteInput.con
    924f:	6e 65 63 74 43 6d 64 00 63 6f 6e 6e 65 63 74 44     nectCmd.connectD
    925f:	62 67 00 63 6f 6e 6e 65 63 74 49 64 6c 00 63 6f     bg.connectIdl.co
    926f:	6e 6e 65 63 74 4c 73 74 00 63 6f 6e 6e 65 63 74     nnectLst.connect
    927f:	4d 73 74 00 63 6f 6e 6e 65 63 74 52 73 74 00 63     Mst.connectRst.c
    928f:	6f 6e 6e 65 63 74 53 74 73 00                       onnectSts.

00009299 <connectLstCLIDict_DescEntry>:
    9299:	4c 69 73 74 73 20 61 76 61 69 6c 61 62 6c 65 20     Lists available 
    92a9:	55 41 52 54 43 6f 6e 6e 65 63 74 20 63 6f 6d 6d     UARTConnect comm
    92b9:	61 6e 64 73 20 61 6e 64 20 69 6e 64 65 78 20 69     ands and index i
    92c9:	64 00                                               d.

000092cb <uartConnectCLIDictName>:
    92cb:	55 41 52 54 43 6f 6e 6e 65 63 74 20 4d 6f 64 75     UARTConnect Modu
    92db:	6c 65 20 43 6f 6d 6d 61 6e 64 73 00                 le Commands.

000092e7 <connectMstCLIDict_DescEntry>:
    92e7:	53 65 74 73 20 74 68 65 20 64 65 76 69 63 65 20     Sets the device 
    92f7:	61 73 20 6d 61 73 74 65 72 2e 20 55 73 65 20 61     as master. Use a
    9307:	72 67 75 6d 65 6e 74 20 6f 66 20 73 20 74 6f 20     rgument of s to 
    9317:	73 65 74 20 61 73 20 73 6c 61 76 65 2e 00           set as slave..

00009325 <connectRstCLIDict_DescEntry>:
    9325:	52 65 73 65 74 73 20 62 6f 74 68 20 52 78 20 61     Resets both Rx a
    9335:	6e 64 20 54 78 20 63 6f 6e 6e 65 63 74 20 62 75     nd Tx connect bu
    9345:	66 66 65 72 73 20 61 6e 64 20 73 74 61 74 65 20     ffers and state 
    9355:	76 61 72 69 61 62 6c 65 73 2e 00                    variables..

00009360 <connectCmdCLIDict_DescEntry>:
    9360:	53 65 6e 64 73 20 61 20 63 6f 6d 6d 61 6e 64 20     Sends a command 
    9370:	76 69 61 20 55 41 52 54 20 43 6f 6e 6e 65 63 74     via UART Connect
    9380:	2c 20 66 69 72 73 74 20 61 72 67 20 69 73 20 77     , first arg is w
    9390:	68 69 63 68 20 75 61 72 74 2c 20 6e 65 78 74 20     hich uart, next 
    93a0:	61 72 67 20 69 73 20 74 68 65 20 63 6f 6d 6d 61     arg is the comma
    93b0:	6e 64 2c 20 72 65 73 74 20 61 72 65 20 74 68 65     nd, rest are the
    93c0:	20 61 72 67 75 6d 65 6e 74 73 2e 00                  arguments..

000093cc <connectIdlCLIDict_DescEntry>:
    93cc:	53 65 6e 64 73 20 4e 20 6e 75 6d 62 65 72 20 6f     Sends N number o
    93dc:	66 20 49 64 6c 65 20 63 6f 6d 6d 61 6e 64 73 2c     f Idle commands,
    93ec:	20 32 20 69 73 20 74 68 65 20 64 65 66 61 75 6c      2 is the defaul
    93fc:	74 20 76 61 6c 75 65 2c 20 61 6e 64 20 73 68 6f     t value, and sho
    940c:	75 6c 64 20 62 65 20 73 75 66 66 69 63 69 65 6e     uld be sufficien
    941c:	74 20 69 6e 20 6d 6f 73 74 20 63 61 73 65 73 2e     t in most cases.
    942c:	00                                                  .

0000942d <tm136_guide>:
    942d:	01 00 01 0d 00 00 00                                .......

00009434 <default_tl_0x2C>:
    9434:	01 00 00 00 47 00 00 00                             ....G...

0000943c <default_tl_0x2D>:
    943c:	00 00 00 00                                         ....

00009440 <default_tl_0x2E>:
    9440:	00 00 00 00 1b 5b 31 3b 33 32 6d 49 4e 46 4f 1b     .....[1;32mINFO.
    9450:	5b 30 6d 20 2d 20 43 61 70 61 62 69 6c 69 74 69     [0m - Capabiliti
    9460:	65 73 20 4c 69 73 74 20 00 0d 0a 09 00 1b 5b 31     es List ......[1
    9470:	3b 33 32 6d 49 4e 46 4f 1b 5b 30 6d 20 2d 20 4b     ;32mINFO.[0m - K
    9480:	00 1b 5b 31 3b 33 33 6d 57 41 52 4e 49 4e 47 1b     ..[1;33mWARNING.
    9490:	5b 30 6d 20 2d 20 66 6c 61 73 68 4d 6f 64 65 45     [0m - flashModeE
    94a0:	6e 61 62 6c 65 64 20 6e 6f 74 20 73 65 74 2c 20     nabled not set, 
    94b0:	63 61 6e 63 65 6c 6c 69 6e 67 20 66 69 72 6d 77     cancelling firmw
    94c0:	61 72 65 20 72 65 6c 6f 61 64 2e 2e 2e 0d 0a 00     are reload......
    94d0:	1b 5b 31 3b 33 32 6d 49 4e 46 4f 1b 5b 30 6d 20     .[1;32mINFO.[0m 
    94e0:	2d 20 53 65 74 20 66 6c 61 73 68 4d 6f 64 65 45     - Set flashModeE
    94f0:	6e 61 62 6c 65 64 20 74 6f 20 31 20 69 6e 20 79     nabled to 1 in y
    9500:	6f 75 72 20 6b 6c 6c 20 63 6f 6e 66 69 67 75 72     our kll configur
    9510:	61 74 69 6f 6e 2e 00 1b 5b 31 3b 33 32 6d 49 4e     ation...[1;32mIN
    9520:	46 4f 1b 5b 30 6d 20 2d 20 4c 61 79 65 72 20 44     FO.[0m - Layer D
    9530:	65 62 75 67 20 4d 6f 64 65 3a 20 00 1b 5b 31 3b     ebug Mode: ..[1;
    9540:	33 32 6d 49 4e 46 4f 1b 5b 30 6d 20 2d 20 53 65     32mINFO.[0m - Se
    9550:	74 74 69 6e 67 20 4c 61 79 65 72 20 4c 00 20 74     tting Layer L. t
    9560:	6f 20 2d 20 00 1b 5b 31 3b 33 32 6d 49 4e 46 4f     o - ..[1;32mINFO
    9570:	1b 5b 30 6d 20 2d 20 4d 61 63 72 6f 20 44 65 62     .[0m - Macro Deb
    9580:	75 67 20 4d 6f 64 65 3a 20 00 1b 5b 31 3b 33 32     ug Mode: ..[1;32
    9590:	6d 49 4e 46 4f 1b 5b 30 6d 20 2d 20 4d 61 63 72     mINFO.[0m - Macr
    95a0:	6f 20 50 72 6f 63 65 73 73 69 6e 67 20 4d 6f 64     o Processing Mod
    95b0:	65 3a 20 00 1b 5b 31 3b 33 32 6d 49 4e 46 4f 1b     e: ..[1;32mINFO.
    95c0:	5b 30 6d 20 2d 20 4c 61 79 65 72 20 4c 69 73 74     [0m - Layer List
    95d0:	00 20 1b 5b 31 6d 28 64 65 66 61 75 6c 74 29 1b     . .[1m(default).
    95e0:	5b 30 6d 00 0d 0a 09 09 20 4c 61 79 65 72 20 53     [0m..... Layer S
    95f0:	74 61 74 65 3a 20 00 20 46 69 72 73 74 20 2d 3e     tate: . First ->
    9600:	20 4c 61 73 74 20 49 6e 64 69 63 65 73 3a 20 00      Last Indices: .
    9610:	1b 5b 31 3b 33 32 6d 49 4e 46 4f 1b 5b 30 6d 20     .[1;32mINFO.[0m 
    9620:	2d 20 50 65 6e 64 69 6e 67 20 4b 65 79 20 45 76     - Pending Key Ev
    9630:	65 6e 74 73 3a 20 00 20 3a 20 00 1b 5b 31 3b 33     ents: . : ..[1;3
    9640:	32 6d 49 4e 46 4f 1b 5b 30 6d 20 2d 20 50 65 6e     2mINFO.[0m - Pen
    9650:	64 69 6e 67 20 54 72 69 67 67 65 72 20 4d 61 63     ding Trigger Mac
    9660:	72 6f 73 3a 20 00 1b 5b 31 3b 33 32 6d 49 4e 46     ros: ..[1;32mINF
    9670:	4f 1b 5b 30 6d 20 2d 20 50 65 6e 64 69 6e 67 20     O.[0m - Pending 
    9680:	52 65 73 75 6c 74 20 4d 61 63 72 6f 73 3a 20 00     Result Macros: .
    9690:	1b 5b 31 3b 33 32 6d 49 4e 46 4f 1b 5b 30 6d 20     .[1;32mINFO.[0m 
    96a0:	2d 20 54 72 69 67 67 65 72 20 4d 61 63 72 6f 73     - Trigger Macros
    96b0:	20 52 61 6e 67 65 3a 20 54 30 20 2d 3e 20 54 00      Range: T0 -> T.
    96c0:	1b 5b 31 3b 33 32 6d 49 4e 46 4f 1b 5b 30 6d 20     .[1;32mINFO.[0m 
    96d0:	2d 20 52 65 73 75 6c 74 20 20 4d 61 63 72 6f 73     - Result  Macros
    96e0:	20 52 61 6e 67 65 3a 20 52 30 20 2d 3e 20 52 00      Range: R0 -> R.
    96f0:	1b 5b 31 3b 33 32 6d 49 4e 46 4f 1b 5b 30 6d 20     .[1;32mINFO.[0m 
    9700:	2d 20 54 72 69 67 67 65 72 20 3a 20 52 65 73 75     - Trigger : Resu
    9710:	6c 74 20 4d 61 63 72 6f 20 50 61 69 72 73 00 09     lt Macro Pairs..
    9720:	54 00 20 3a 20 52 00 1b 5b 31 3b 33 35 6d 44 45     T. : R..[1;35mDE
    9730:	42 55 47 1b 5b 30 6d 20 2d 20 4c 61 79 65 72 20     BUG.[0m - Layer 
    9740:	00 20 30 00 4d 61 63 72 6f 5f 6c 61 79 65 72 53     . 0.Macro_layerS
    9750:	74 61 74 65 28 6c 61 79 65 72 49 6e 64 65 78 2c     tate(layerIndex,
    9760:	6c 61 79 65 72 53 74 61 74 65 29 00 4d 61 63 72     layerState).Macr
    9770:	6f 5f 6c 61 79 65 72 4c 61 74 63 68 28 6c 61 79     o_layerLatch(lay
    9780:	65 72 49 6e 64 65 78 29 00 4d 61 63 72 6f 5f 6c     erIndex).Macro_l
    9790:	61 79 65 72 4c 6f 63 6b 28 6c 61 79 65 72 49 6e     ayerLock(layerIn
    97a0:	64 65 78 29 00 4d 61 63 72 6f 5f 6c 61 79 65 72     dex).Macro_layer
    97b0:	53 68 69 66 74 28 6c 61 79 65 72 49 6e 64 65 78     Shift(layerIndex
    97c0:	29 00 4d 61 63 72 6f 5f 6c 61 79 65 72 52 6f 74     ).Macro_layerRot
    97d0:	61 74 65 28 70 72 65 76 69 6f 75 73 29 00 1b 5b     ate(previous)..[
    97e0:	31 3b 35 3b 33 31 6d 45 52 52 4f 52 1b 5b 30 6d     1;5;31mERROR.[0m
    97f0:	20 2d 20 53 63 61 6e 20 43 6f 64 65 20 68 61 73      - Scan Code has
    9800:	20 6e 6f 20 64 65 66 69 6e 65 64 20 54 72 69 67      no defined Trig
    9810:	67 65 72 20 4d 61 63 72 6f 3a 20 00 1b 5b 31 3b     ger Macro: ..[1;
    9820:	35 3b 33 31 6d 45 52 52 4f 52 1b 5b 30 6d 20 2d     5;31mERROR.[0m -
    9830:	20 49 6e 76 61 6c 69 64 20 6b 65 79 20 73 74 61      Invalid key sta
    9840:	74 65 20 2d 20 00 1b 5b 31 3b 35 3b 33 31 6d 45     te - ..[1;5;31mE
    9850:	52 52 4f 52 1b 5b 30 6d 20 2d 20 49 6e 76 61 6c     RROR.[0m - Inval
    9860:	69 64 20 74 79 70 65 20 2d 20 00 1b 5b 31 3b 33     id type - ..[1;3
    9870:	33 6d 57 41 52 4e 49 4e 47 1b 5b 30 6d 20 2d 20     3mWARNING.[0m - 
    9880:	53 63 61 6e 43 6f 64 65 20 69 73 20 6f 75 74 20     ScanCode is out 
    9890:	6f 66 20 72 61 6e 67 65 2f 6e 6f 74 20 64 65 66     of range/not def
    98a0:	69 6e 65 64 20 2d 20 00 1b 5b 31 3b 33 33 6d 57     ined - ..[1;33mW
    98b0:	41 52 4e 49 4e 47 1b 5b 30 6d 20 2d 20 53 63 61     ARNING.[0m - Sca
    98c0:	6e 43 6f 64 65 20 69 73 20 6f 75 74 20 6f 66 20     nCode is out of 
    98d0:	72 61 6e 67 65 2f 6e 6f 74 20 64 65 66 69 6e 65     range/not define
    98e0:	64 3a 20 00 1b 5b 31 3b 35 3b 33 31 6d 45 52 52     d: ..[1;5;31mERR
    98f0:	4f 52 1b 5b 30 6d 20 2d 20 4c 45 44 20 53 74 61     OR.[0m - LED Sta
    9900:	74 65 20 54 79 70 65 20 2d 20 4e 6f 74 20 69 6d     te Type - Not im
    9910:	70 6c 65 6d 65 6e 74 65 64 2e 2e 2e 0d 0a 00 1b     plemented.......
    9920:	5b 31 3b 35 3b 33 31 6d 45 52 52 4f 52 1b 5b 30     [1;5;31mERROR.[0
    9930:	6d 20 2d 20 41 6e 61 6c 6f 67 20 53 74 61 74 65     m - Analog State
    9940:	20 54 79 70 65 20 2d 20 4e 6f 74 20 69 6d 70 6c      Type - Not impl
    9950:	65 6d 65 6e 74 65 64 2e 2e 2e 0d 0a 00 1b 5b 31     emented.......[1
    9960:	3b 35 3b 33 31 6d 45 52 52 4f 52 1b 5b 30 6d 20     ;5;31mERROR.[0m 
    9970:	2d 20 49 6e 76 61 6c 69 64 20 53 74 61 74 65 20     - Invalid State 
    9980:	54 79 70 65 2e 20 54 68 69 73 20 69 73 20 61 20     Type. This is a 
    9990:	62 75 67 2e 0d 0a 00 1b 5b 31 3b 33 35 6d 44 45     bug.....[1;35mDE
    99a0:	42 55 47 1b 5b 30 6d 20 2d 20 4d 61 63 72 6f 20     BUG.[0m - Macro 
    99b0:	53 74 65 70 0d 0a 00 1b 5b 31 3b 33 32 6d 49 4e     Step....[1;32mIN
    99c0:	46 4f 1b 5b 30 6d 20 2d 20 54 72 69 67 67 65 72     FO.[0m - Trigger
    99d0:	20 4d 61 63 72 6f 20 49 6e 64 65 78 3a 20 00 7c      Macro Index: .|
    99e0:	00 3b 00 0d 0a 50 6f 73 69 74 69 6f 6e 3a 20 00     .;...Position: .
    99f0:	0d 0a 52 65 73 75 6c 74 20 4d 61 63 72 6f 20 49     ..Result Macro I
    9a00:	6e 64 65 78 3a 20 00 0d 0a 54 72 69 67 67 65 72     ndex: ...Trigger
    9a10:	20 4d 61 63 72 6f 20 53 74 61 74 65 3a 20 00 57      Macro State: .W
    9a20:	61 69 74 69 6e 67 00 1b 5b 31 3b 33 32 6d 49 4e     aiting..[1;32mIN
    9a30:	46 4f 1b 5b 30 6d 20 2d 20 52 65 73 75 6c 74 20     FO.[0m - Result 
    9a40:	4d 61 63 72 6f 20 49 6e 64 65 78 3a 20 00 28 00     Macro Index: .(.
    9a50:	2c 00 0d 0a 46 69 6e 61 6c 20 54 72 69 67 67 65     ,...Final Trigge
    9a60:	72 20 53 74 61 74 65 20 28 53 74 61 74 65 2f 54     r State (State/T
    9a70:	79 70 65 29 3a 20 00 63 61 70 4c 69 73 74 00 63     ype): .capList.c
    9a80:	61 70 53 65 6c 65 63 74 00 6b 65 79 48 6f 6c 64     apSelect.keyHold
    9a90:	00 6b 65 79 50 72 65 73 73 00 6b 65 79 52 65 6c     .keyPress.keyRel
    9aa0:	65 61 73 65 00 6c 61 79 65 72 44 65 62 75 67 00     ease.layerDebug.
    9ab0:	6c 61 79 65 72 4c 69 73 74 00 6c 61 79 65 72 53     layerList.layerS
    9ac0:	74 61 74 65 00 6d 61 63 72 6f 44 65 62 75 67 00     tate.macroDebug.
    9ad0:	6d 61 63 72 6f 4c 69 73 74 00 6d 61 63 72 6f 50     macroList.macroP
    9ae0:	72 6f 63 00 6d 61 63 72 6f 53 68 6f 77 00 6d 61     roc.macroShow.ma
    9af0:	63 72 6f 53 74 65 70 00 44 3a 20 70 63 65 20 2b     croStep.D: pce +
    9b00:	20 6c 63 64 46 75 6e 63 4d 61 70 00 31 3a 20 70      lcdFuncMap.1: p
    9b10:	63 65 31 00 32 3a 20 70 63 65 32 00 33 3a 20 70     ce1.2: pce2.3: p
    9b20:	63 65 00                                            ce.

00009b23 <rm102_guide>:
    9b23:	01 0e 42 00                                         ..B.

00009b27 <tm24_guide>:
    9b27:	01 00 01 3e 00                                      ...>.

00009b2c <rm40_guide>:
    9b2c:	01 0e 1d 00                                         ....

00009b30 <tm129_guide>:
    9b30:	01 00 01 0e 00                                      .....

00009b35 <tm0_guide>:
    9b35:	01 00 01 06 00                                      .....

00009b3a <tm18_guide>:
    9b3a:	01 00 01 3d 00                                      ...=.

00009b3f <rm93_guide>:
    9b3f:	02 0e e1 0e 23 00 00 00 00                          ....#....

00009b48 <default_tl_0x44>:
    9b48:	01 00 00 00 0a 00 00 00                             ........

00009b50 <default_tl_0x45>:
    9b50:	01 00 00 00 3e 00 00 00                             ....>...

00009b58 <rm87_guide>:
    9b58:	01 0e 25 00                                         ..%.

00009b5c <default_tl_0x47>:
    9b5c:	01 00 00 00 07 00 00 00                             ........

00009b64 <macroCLIDictName>:
    9b64:	4d 61 63 72 6f 20 4d 6f 64 75 6c 65 20 43 6f 6d     Macro Module Com
    9b74:	6d 61 6e 64 73 00                                   mands.

00009b7a <tm41_guide>:
    9b7a:	01 00 01 21 00                                      ...!.

00009b7f <tm93_guide>:
    9b7f:	01 00 01 22 00                                      ...".

00009b84 <keyReleaseCLIDict_DescEntry>:
    9b84:	53 65 6e 64 20 6b 65 79 2d 72 65 6c 65 61 73 65     Send key-release
    9b94:	20 65 76 65 6e 74 20 74 6f 20 6d 61 63 72 6f 20      event to macro 
    9ba4:	6d 6f 64 75 6c 65 2e 20 44 75 70 6c 69 63 61 74     module. Duplicat
    9bb4:	65 73 20 68 61 76 65 20 75 6e 64 65 66 69 6e 65     es have undefine
    9bc4:	64 20 62 65 68 61 76 69 6f 75 72 2e 0d 0a 09 09     d behaviour.....
    9bd4:	1b 5b 33 35 6d 53 31 30 1b 5b 30 6d 20 53 63 61     .[35mS10.[0m Sca
    9be4:	6e 63 6f 64 65 20 30 78 30 41 00                    ncode 0x0A.

00009bef <tm65_guide>:
    9bef:	01 00 01 49 00                                      ...I.

00009bf4 <tm2_guide>:
    9bf4:	01 00 01 16 00                                      .....

00009bf9 <tm37_guide>:
    9bf9:	01 00 01 0f 00 00 00                                .......

00009c00 <default_tl_0x30>:
    9c00:	01 00 00 00 36 00 00 00                             ....6...

00009c08 <default_tl_0x31>:
    9c08:	01 00 00 00 43 00 00 00                             ....C...

00009c10 <default_tl_0x32>:
    9c10:	01 00 00 00 49 00 00 00                             ....I...

00009c18 <default_tl_0x33>:
    9c18:	01 00 00 00 32 00 00 00                             ....2...

00009c20 <default_tl_0x34>:
    9c20:	01 00 00 00 38 00 00 00                             ....8...

00009c28 <default_tl_0x35>:
    9c28:	01 00 00 00 3c 00 00 00                             ....<...

00009c30 <default_tl_0x36>:
    9c30:	00 00 00 00                                         ....

00009c34 <default_tl_0x37>:
    9c34:	00 00 00 00                                         ....

00009c38 <default_tl_0x38>:
    9c38:	01 00 00 00 27 00 00 00                             ....'...

00009c40 <default_tl_0x39>:
    9c40:	01 00 00 00 2b 00 00 00                             ....+...

00009c48 <tm72_guide>:
    9c48:	01 00 01 55 00                                      ...U.

00009c4d <tm125_guide>:
    9c4d:	01 00 01 18 00                                      .....

00009c52 <rm54_guide>:
    9c52:	01 0e 0d 00 00 00                                   ......

00009c58 <default_tl_0x3A>:
    9c58:	01 00 00 00 16 00 00 00                             ........

00009c60 <default_tl_0x3B>:
    9c60:	01 00 00 00 24 00 00 00                             ....$...

00009c68 <default_tl_0x3C>:
    9c68:	01 00 00 00 28 00 00 00                             ....(...

00009c70 <default_tl_0x3D>:
    9c70:	01 00 00 00 12 00 00 00                             ........

00009c78 <default_tl_0x3E>:
    9c78:	01 00 00 00 18 00 00 00                             ........

00009c80 <default_tl_0x3F>:
    9c80:	00 00 00 00                                         ....

00009c84 <rm81_guide>:
    9c84:	02 0e e1 0e 21 00                                   ....!.

00009c8a <macroStepCLIDict_DescEntry>:
    9c8a:	44 6f 20 4e 20 6d 61 63 72 6f 20 70 72 6f 63 65     Do N macro proce
    9c9a:	73 73 69 6e 67 20 73 74 65 70 73 2e 20 44 65 66     ssing steps. Def
    9caa:	61 75 6c 74 73 20 74 6f 20 31 2e 00                 aults to 1..

00009cb6 <rm53_guide>:
    9cb6:	01 0e 11 00                                         ....

00009cba <rm25_guide>:
    9cba:	01 0e 07 00                                         ....

00009cbe <rm21_guide>:
    9cbe:	01 0e 0a 00                                         ....

00009cc2 <capSelectCLIDict_DescEntry>:
    9cc2:	54 72 69 67 67 65 72 73 20 74 68 65 20 73 70 65     Triggers the spe
    9cd2:	63 69 66 69 65 64 20 63 61 70 61 62 69 6c 69 74     cified capabilit
    9ce2:	69 65 73 2e 20 46 69 72 73 74 20 74 77 6f 20 61     ies. First two a
    9cf2:	72 67 73 20 61 72 65 20 73 74 61 74 65 20 61 6e     rgs are state an
    9d02:	64 20 73 74 61 74 65 54 79 70 65 2e 0d 0a 09 09     d stateType.....
    9d12:	1b 5b 33 35 6d 4b 31 31 1b 5b 30 6d 20 4b 65 79     .[35mK11.[0m Key
    9d22:	62 6f 61 72 64 20 43 61 70 61 62 69 6c 69 74 79     board Capability
    9d32:	20 30 78 30 42 00                                    0x0B.

00009d38 <rm77_guide>:
    9d38:	02 0e e1 0e 33 00                                   ....3.

00009d3e <InterconnectOffsetList>:
    9d3e:	2d 59                                               -Y

00009d40 <tm76_guide>:
    9d40:	01 00 01 16 00                                      .....

00009d45 <rm49_guide>:
    9d45:	01 0e 0e 00                                         ....

00009d49 <rm99_guide>:
    9d49:	01 0e 4c 00                                         ..L.

00009d4d <tm82_guide>:
    9d4d:	01 00 01 18 00                                      .....

00009d52 <tm54_guide>:
    9d52:	01 00 01 30 00                                      ...0.

00009d57 <tm26_guide>:
    9d57:	01 00 01 27 00                                      ...'.

00009d5c <tm78_guide>:
    9d5c:	01 00 01 43 00 00 00 00                             ...C....

00009d64 <macroCLIDict>:
    9d64:	77 9a 00 00 58 ac 00 00 e9 4a 00 00 7f 9a 00 00     w...X....J......
    9d74:	c2 9c 00 00 69 4b 00 00 89 9a 00 00 b0 a9 00 00     ....iK..........
    9d84:	7d 53 00 00 91 9a 00 00 74 a2 00 00 ab 53 00 00     }S......t....S..
    9d94:	9a 9a 00 00 84 9b 00 00 d9 53 00 00 a5 9a 00 00     .........S......
    9da4:	3c aa 00 00 65 4c 00 00 b0 9a 00 00 f9 af 00 00     <...eL..........
    9db4:	71 4d 00 00 ba 9a 00 00 10 af 00 00 99 4c 00 00     qM...........L..
    9dc4:	c5 9a 00 00 84 a3 00 00 09 4d 00 00 d0 9a 00 00     .........M......
    9dd4:	9c ae 00 00 09 4e 00 00 da 9a 00 00 d8 aa 00 00     .....N..........
    9de4:	3d 4d 00 00 e4 9a 00 00 79 b1 00 00 09 5d 00 00     =M......y....]..
    9df4:	ee 9a 00 00 8a 9c 00 00 41 4b 00 00 00 00 00 00     ........AK......
    9e04:	00 00 00 00 00 00 00 00                             ........

00009e0c <rm85_guide>:
    9e0c:	01 0e 21 00                                         ..!.

00009e10 <default_tl_0x40>:
    9e10:	00 00 00 00                                         ....

00009e14 <default_tl_0x41>:
    9e14:	00 00 00 00                                         ....

00009e18 <default_tl_0x42>:
    9e18:	01 00 00 00 1c 00 00 00                             ........

00009e20 <default_tl_0x43>:
    9e20:	01 00 00 00 05 00 00 00                             ........

00009e28 <layer1_tl_0x0C>:
    9e28:	01 00 00 00 5e 00 00 00                             ....^...

00009e30 <layer1_tl_0x0D>:
    9e30:	01 00 00 00 61 00 00 00                             ....a...

00009e38 <default_tl_0x46>:
    9e38:	01 00 00 00 03 00 00 00                             ........

00009e40 <layer1_tl_0x0F>:
    9e40:	01 00 00 00 58 00 00 00                             ....X...

00009e48 <default_tl_0x48>:
    9e48:	01 00 00 00 3b 00 00 00                             ....;...

00009e50 <default_tl_0x49>:
    9e50:	01 00 00 00 41 00 00 00                             ....A...

00009e58 <tm7_guide>:
    9e58:	01 00 01 47 00                                      ...G.

00009e5d <rm79_guide>:
    9e5d:	02 0e e1 0e 27 00                                   ....'.

00009e63 <tm138_guide>:
    9e63:	01 00 01 45 00                                      ...E.

00009e68 <default_tl_0x4A>:
    9e68:	01 00 00 00 46 00 00 00                             ....F...

00009e70 <default_tl_0x4B>:
    9e70:	01 00 00 00 2f 00 00 00                             ..../...

00009e78 <default_tl_0x4C>:
    9e78:	01 00 00 00 35 00 00 00                             ....5...

00009e80 <default_tl_0x4D>:
    9e80:	01 00 00 00 1e 00 00 00                             ........

00009e88 <default_tl_0x4E>:
    9e88:	01 00 00 00 2d 00 00 00                             ....-...

00009e90 <default_tl_0x4F>:
    9e90:	01 00 00 00 31 00 00 00                             ....1...

00009e98 <layer1_tl_0x47>:
    9e98:	00 00 00 00                                         ....

00009e9c <tm20_guide>:
    9e9c:	01 00 01 11 00                                      .....

00009ea1 <rm70_guide>:
    9ea1:	01 0e 30 00                                         ..0.

00009ea5 <rm98_guide>:
    9ea5:	01 0e 41 00 00 00 00                                ..A....

00009eac <default_tl_0x57>:
    9eac:	01 00 00 00 11 00 00 00                             ........

00009eb4 <rm42_guide>:
    9eb4:	01 0e 0f 00                                         ....

00009eb8 <rm46_guide>:
    9eb8:	01 0e 23 00                                         ..#.

00009ebc <ResultMacroList>:
    9ebc:	b3 af 00 00 58 ad 00 00 fd a8 00 00 68 ad 00 00     ....X.......h...
    9ecc:	1d ac 00 00 b0 a0 00 00 98 ad 00 00 1f a3 00 00     ................
    9edc:	ec ac 00 00 3e a9 00 00 66 b2 00 00 6a ab 00 00     ....>...f...j...
    9eec:	35 a9 00 00 34 ad 00 00 ed a3 00 00 7f ad 00 00     5...4...........
    9efc:	06 a3 00 00 a4 af 00 00 9c a0 00 00 75 b1 00 00     ............u...
    9f0c:	c4 a8 00 00 be 9c 00 00 01 a9 00 00 64 b1 00 00     ............d...
    9f1c:	2d ae 00 00 ba 9c 00 00 15 a3 00 00 74 a1 00 00     -...........t...
    9f2c:	48 ae 00 00 f7 a3 00 00 b1 ac 00 00 5e a1 00 00     H...........^...
    9f3c:	31 ae 00 00 e9 a3 00 00 84 b0 00 00 ac a9 00 00     1...............
    9f4c:	83 ad 00 00 75 a8 00 00 4b ab 00 00 8b ad 00 00     ....u...K.......
    9f5c:	2c 9b 00 00 d2 ab 00 00 b4 9e 00 00 7b ad 00 00     ,...........{...
    9f6c:	fd a2 00 00 a0 af 00 00 b8 9e 00 00 71 b1 00 00     ............q...
    9f7c:	17 ab 00 00 45 9d 00 00 f9 a8 00 00 54 ae 00 00     ....E.......T...
    9f8c:	42 ab 00 00 b6 9c 00 00 52 9c 00 00 e5 ae 00 00     B.......R.......
    9f9c:	44 ae 00 00 f3 a3 00 00 88 b0 00 00 99 ac 00 00     D...............
    9fac:	29 ae 00 00 e5 a3 00 00 7e b0 00 00 ab ad 00 00     ).......~.......
    9fbc:	a0 aa 00 00 91 b0 00 00 84 a0 00 00 87 ad 00 00     ................
    9fcc:	0a a3 00 00 a8 af 00 00 a1 9e 00 00 70 ad 00 00     ............p...
    9fdc:	ed a2 00 00 9c af 00 00 05 a9 00 00 6d b1 00 00     ............m...
    9fec:	0c ab 00 00 38 9d 00 00 55 ab 00 00 5d 9e 00 00     ....8...U...]...
    9ffc:	da a3 00 00 84 9c 00 00 b6 ac 00 00 64 a1 00 00     ............d...
    a00c:	40 ae 00 00 0c 9e 00 00 70 ae 00 00 58 9b 00 00     @.......p...X...
    a01c:	62 ae 00 00 9a aa 00 00 78 b0 00 00 ba aa 00 00     b.......x.......
    a02c:	e7 a2 00 00 3f 9b 00 00 3d a1 00 00 38 b1 00 00     ....?...=...8...
    a03c:	6c ad 00 00 46 a1 00 00 a5 9e 00 00 49 9d 00 00     l...F.......I...
    a04c:	30 ad 00 00 6a a9 00 00 23 9b 00 00 78 ab 00 00     0...j...#...x...
    a05c:	8f ad 00 00 5e ad 00 00 70 a2 00 00 04 af 00 00     ....^...p.......
    a06c:	f0 a8 00 00 c0 aa 00 00 e4 a1 00 00 e1 ae 00 00     ................

0000a07c <default_tl_0x50>:
    a07c:	01 00 00 00 1b 00 00 00                             ........

0000a084 <rm66_guide>:
    a084:	02 0e e1 0e 24 00 00 00                             ....$...

0000a08c <default_tl_0x52>:
    a08c:	01 00 00 00 26 00 00 00                             ....&...

0000a094 <default_tl_0x53>:
    a094:	01 00 00 00 0f 00 00 00                             ........

0000a09c <rm18_guide>:
    a09c:	01 0e 13 00                                         ....

0000a0a0 <default_tl_0x54>:
    a0a0:	01 00 00 00 15 00 00 00                             ........

0000a0a8 <default_tl_0x55>:
    a0a8:	01 00 00 00 48 00 00 00                             ....H...

0000a0b0 <rm5_guide>:
    a0b0:	01 0e 0b 00                                         ....

0000a0b4 <default_tl_0x56>:
    a0b4:	01 00 00 00 0c 00 00 00                             ........

0000a0bc <layer1_tl_0x10>:
    a0bc:	00 00 00 00                                         ....

0000a0c0 <layer1_tl_0x11>:
    a0c0:	00 00 00 00                                         ....

0000a0c4 <layer1_tl_0x12>:
    a0c4:	00 00 00 00                                         ....

0000a0c8 <layer1_tl_0x13>:
    a0c8:	00 00 00 00                                         ....

0000a0cc <layer1_tl_0x14>:
    a0cc:	00 00 00 00                                         ....

0000a0d0 <layer1_tl_0x15>:
    a0d0:	01 00 00 00 53 00 00 00                             ....S...

0000a0d8 <layer1_tl_0x16>:
    a0d8:	01 00 00 00 4c 00 00 00                             ....L...

0000a0e0 <layer1_tl_0x17>:
    a0e0:	01 00 00 00 50 00 00 00                             ....P...

0000a0e8 <layer1_tl_0x18>:
    a0e8:	01 00 00 00 52 00 00 00                             ....R...

0000a0f0 <layer1_tl_0x19>:
    a0f0:	01 00 00 00 65 00 00 00                             ....e...

0000a0f8 <tm39_guide>:
    a0f8:	01 00 01 38 00                                      ...8.

0000a0fd <tm131_guide>:
    a0fd:	01 00 01 21 00 00 00                                ...!...

0000a104 <default_tl_0x51>:
    a104:	01 00 00 00 21 00 00 00                             ....!...

0000a10c <layer1_tl_0x1A>:
    a10c:	00 00 00 00                                         ....

0000a110 <layer1_tl_0x1B>:
    a110:	00 00 00 00                                         ....

0000a114 <layer1_tl_0x1C>:
    a114:	00 00 00 00                                         ....

0000a118 <layer1_tl_0x1D>:
    a118:	00 00 00 00                                         ....

0000a11c <layer1_tl_0x1E>:
    a11c:	00 00 00 00                                         ....

0000a120 <layer1_tl_0x1F>:
    a120:	01 00 00 00 62 00 00 00                             ....b...

0000a128 <default_tl_0x58>:
    a128:	01 00 00 00 44 00 00 00                             ....D...

0000a130 <default_tl_0x59>:
    a130:	01 00 00 00 4b 00 00 00                             ....K...

0000a138 <tm127_guide>:
    a138:	01 00 01 42 00                                      ...B.

0000a13d <rm94_guide>:
    a13d:	01 0e 40 00                                         ..@.

0000a141 <tm97_guide>:
    a141:	01 00 01 0d 00                                      .....

0000a146 <rm97_guide>:
    a146:	01 0e 3e 00                                         ..>.

0000a14a <tm4_guide>:
    a14a:	01 00 01 1a 00                                      .....

0000a14f <tm95_guide>:
    a14f:	01 00 01 4f 00                                      ...O.

0000a154 <tm30_guide>:
    a154:	01 00 01 4d 00                                      ...M.

0000a159 <tm89_guide>:
    a159:	01 00 01 3c 00                                      ...<.

0000a15e <rm31_guide>:
    a15e:	02 06 01 00 01 00                                   ......

0000a164 <rm83_guide>:
    a164:	02 0e e1 0e 35 00                                   ....5.

0000a16a <tm69_guide>:
    a16a:	01 00 01 05 00                                      .....

0000a16f <tm29_guide>:
    a16f:	01 00 01 24 00                                      ...$.

0000a174 <rm27_guide>:
    a174:	01 0e 1a 00                                         ....

0000a178 <tm60_guide>:
    a178:	01 00 01 35 00                                      ...5.

0000a17d <tm56_guide>:
    a17d:	01 00 01 34 00                                      ...4.

0000a182 <tm108_guide>:
    a182:	01 00 01 18 00                                      .....

0000a187 <tm84_guide>:
    a187:	01 00 01 42 00                                      ...B.

0000a18c <layer1_tl_0x20>:
    a18c:	01 00 00 00 64 00 00 00                             ....d...

0000a194 <layer1_tl_0x21>:
    a194:	01 00 00 00 5a 00 00 00                             ....Z...

0000a19c <layer1_tl_0x22>:
    a19c:	01 00 00 00 5d 00 00 00                             ....]...

0000a1a4 <layer1_tl_0x23>:
    a1a4:	00 00 00 00                                         ....

0000a1a8 <layer1_tl_0x24>:
    a1a8:	00 00 00 00                                         ....

0000a1ac <layer1_tl_0x25>:
    a1ac:	00 00 00 00                                         ....

0000a1b0 <layer1_tl_0x26>:
    a1b0:	00 00 00 00                                         ....

0000a1b4 <layer1_tl_0x27>:
    a1b4:	00 00 00 00                                         ....

0000a1b8 <layer1_tl_0x28>:
    a1b8:	00 00 00 00                                         ....

0000a1bc <layer1_tl_0x29>:
    a1bc:	00 00 00 00                                         ....

0000a1c0 <tm120_guide>:
    a1c0:	01 00 01 16 00 00 00 00                             ........

0000a1c8 <layer1_tl_0x2A>:
    a1c8:	00 00 00 00                                         ....

0000a1cc <layer1_tl_0x2B>:
    a1cc:	00 00 00 00                                         ....

0000a1d0 <layer1_tl_0x2C>:
    a1d0:	00 00 00 00                                         ....

0000a1d4 <layer3_tl_0x0D>:
    a1d4:	01 00 00 00 88 00 00 00                             ........

0000a1dc <layer1_tl_0x2E>:
    a1dc:	00 00 00 00                                         ....

0000a1e0 <layer1_tl_0x2F>:
    a1e0:	00 00 00 00                                         ....

0000a1e4 <rm110_guide>:
    a1e4:	01 0e 3b 00                                         ..;.

0000a1e8 <layer1_tl_0x0E>:
    a1e8:	01 00 00 00 56 00 00 00                             ....V...

0000a1f0 <tm23_guide>:
    a1f0:	01 00 01 18 00 00 00 00                             ........

0000a1f8 <CapabilitiesList>:
    a1f8:	ed 37 00 00 09 00 00 00 09 39 00 00 00 00 00 00     .7.......9......
    a208:	a1 2e 00 00 04 00 00 00 5d 50 00 00 02 00 00 00     ........]P......
    a218:	81 50 00 00 02 00 00 00 c9 50 00 00 01 00 00 00     .P.......P......
    a228:	a5 50 00 00 02 00 00 00 39 50 00 00 03 00 00 00     .P......9P......
    a238:	35 5e 00 00 02 00 00 00 f9 5e 00 00 00 00 00 00     5^.......^......
    a248:	3d 5f 00 00 00 00 00 00 6d 5f 00 00 00 00 00 00     =_......m_......
    a258:	8d 5e 00 00 00 00 00 00 a1 5e 00 00 01 00 00 00     .^.......^......
    a268:	a1 5f 00 00 01 00 00 00                             ._......

0000a270 <rm106_guide>:
    a270:	01 0e 4d 00                                         ..M.

0000a274 <keyPressCLIDict_DescEntry>:
    a274:	53 65 6e 64 20 6b 65 79 2d 70 72 65 73 73 20 65     Send key-press e
    a284:	76 65 6e 74 73 20 74 6f 20 74 68 65 20 6d 61 63     vents to the mac
    a294:	72 6f 20 6d 6f 64 75 6c 65 2e 20 44 75 70 6c 69     ro module. Dupli
    a2a4:	63 61 74 65 73 20 68 61 76 65 20 75 6e 64 65 66     cates have undef
    a2b4:	69 6e 65 64 20 62 65 68 61 76 69 6f 75 72 2e 0d     ined behaviour..
    a2c4:	0a 09 09 1b 5b 33 35 6d 53 31 30 1b 5b 30 6d 20     ....[35mS10.[0m 
    a2d4:	53 63 61 6e 63 6f 64 65 20 30 78 30 41 00           Scancode 0x0A.

0000a2e2 <tm17_guide>:
    a2e2:	01 00 01 57 00                                      ...W.

0000a2e7 <rm92_guide>:
    a2e7:	02 0e e1 0e 37 00                                   ....7.

0000a2ed <rm72_guide>:
    a2ed:	02 0e e1 0e 31 00                                   ....1.

0000a2f3 <tm130_guide>:
    a2f3:	01 00 01 0f 00                                      .....

0000a2f8 <tm15_guide>:
    a2f8:	01 00 01 53 00                                      ...S.

0000a2fd <rm44_guide>:
    a2fd:	01 0e 1e 00                                         ....

0000a301 <tm55_guide>:
    a301:	01 00 01 0d 00                                      .....

0000a306 <rm16_guide>:
    a306:	01 0e 08 00                                         ....

0000a30a <rm68_guide>:
    a30a:	02 0e e1 0e 1e 00                                   ......

0000a310 <tm87_guide>:
    a310:	01 00 01 3b 00                                      ...;.

0000a315 <rm26_guide>:
    a315:	01 04 02 00 00                                      .....

0000a31a <tm73_guide>:
    a31a:	01 00 01 32 00                                      ...2.

0000a31f <rm7_guide>:
    a31f:	01 0e e5 00                                         ....

0000a323 <tm45_guide>:
    a323:	01 00 01 4e 00                                      ...N.

0000a328 <layer1_tl_0x30>:
    a328:	00 00 00 00                                         ....

0000a32c <layer1_tl_0x31>:
    a32c:	00 00 00 00                                         ....

0000a330 <layer1_tl_0x32>:
    a330:	00 00 00 00                                         ....

0000a334 <layer1_tl_0x33>:
    a334:	00 00 00 00                                         ....

0000a338 <layer1_tl_0x34>:
    a338:	00 00 00 00                                         ....

0000a33c <layer1_tl_0x35>:
    a33c:	00 00 00 00                                         ....

0000a340 <layer1_tl_0x36>:
    a340:	00 00 00 00                                         ....

0000a344 <layer1_tl_0x37>:
    a344:	00 00 00 00                                         ....

0000a348 <layer1_tl_0x38>:
    a348:	00 00 00 00                                         ....

0000a34c <tm134_guide>:
    a34c:	01 00 01 4f 00                                      ...O.

0000a351 <tm133_guide>:
    a351:	01 00 01 0c 00                                      .....

0000a356 <tm105_guide>:
    a356:	01 00 01 44 00                                      ...D.

0000a35b <tm11_guide>:
    a35b:	01 00 01 26 00                                      ...&.

0000a360 <layer1_tl_0x3A>:
    a360:	01 00 00 00 51 00 00 00                             ....Q...

0000a368 <layer1_tl_0x3B>:
    a368:	01 00 00 00 57 00 00 00                             ....W...

0000a370 <layer1_tl_0x3C>:
    a370:	01 00 00 00 59 00 00 00                             ....Y...

0000a378 <layer1_tl_0x3D>:
    a378:	00 00 00 00                                         ....

0000a37c <layer1_tl_0x3E>:
    a37c:	00 00 00 00                                         ....

0000a380 <layer1_tl_0x3F>:
    a380:	00 00 00 00                                         ....

0000a384 <macroDebugCLIDict_DescEntry>:
    a384:	44 69 73 61 62 6c 65 73 2f 45 6e 61 62 6c 65 73     Disables/Enables
    a394:	20 73 65 6e 64 69 6e 67 20 55 53 42 20 6b 65 79      sending USB key
    a3a4:	63 6f 64 65 73 20 74 6f 20 74 68 65 20 4f 75 74     codes to the Out
    a3b4:	70 75 74 20 4d 6f 64 75 6c 65 20 61 6e 64 20 70     put Module and p
    a3c4:	72 69 6e 74 73 20 55 2f 4b 20 63 6f 64 65 73 2e     rints U/K codes.
    a3d4:	00                                                  .

0000a3d5 <tm99_guide>:
    a3d5:	01 00 01 45 00                                      ...E.

0000a3da <rm80_guide>:
    a3da:	02 0e e1 0e 25 00                                   ....%.

0000a3e0 <tm32_guide>:
    a3e0:	01 00 01 0e 00                                      .....

0000a3e5 <rm61_guide>:
    a3e5:	01 0e 04 00                                         ....

0000a3e9 <rm33_guide>:
    a3e9:	01 0e 19 00                                         ....

0000a3ed <rm14_guide>:
    a3ed:	02 06 03 00 01 00                                   ......

0000a3f3 <rm57_guide>:
    a3f3:	01 0e e0 00                                         ....

0000a3f7 <rm29_guide>:
    a3f7:	01 0e 1b 00                                         ....

0000a3fb <tm90_guide>:
    a3fb:	01 00 01 21 00                                      ...!.

0000a400 <tm62_guide>:
    a400:	01 00 01 45 00 00 00 00                             ...E....

0000a408 <TriggerMacroList>:
    a408:	35 9b 00 00 00 00 00 00 8b aa 00 00 01 00 00 00     5...............
    a418:	f4 9b 00 00 02 00 00 00 4e ac 00 00 03 00 00 00     ........N.......
    a428:	4a a1 00 00 04 00 00 00 b4 ad 00 00 05 00 00 00     J...............
    a438:	51 a9 00 00 06 00 00 00 58 9e 00 00 07 00 00 00     Q.......X.......
    a448:	54 b0 00 00 08 00 00 00 ac ac 00 00 09 00 00 00     T...............
    a458:	5b ab 00 00 0a 00 00 00 5b a3 00 00 0b 00 00 00     [.......[.......
    a468:	cd ab 00 00 0c 00 00 00 b5 aa 00 00 0d 00 00 00     ................
    a478:	76 ad 00 00 0e 00 00 00 f8 a2 00 00 0f 00 00 00     v...............
    a488:	a1 ad 00 00 10 00 00 00 e2 a2 00 00 11 00 00 00     ................
    a498:	3a 9b 00 00 12 00 00 00 47 a9 00 00 13 00 00 00     :.......G.......
    a4a8:	9c 9e 00 00 06 00 00 00 f4 a8 00 00 14 00 00 00     ................
    a4b8:	ab aa 00 00 15 00 00 00 f0 a1 00 00 16 00 00 00     ................
    a4c8:	27 9b 00 00 06 00 00 00 3d ab 00 00 17 00 00 00     '.......=.......
    a4d8:	57 9d 00 00 18 00 00 00 1c ad 00 00 07 00 00 00     W...............
    a4e8:	26 ad 00 00 19 00 00 00 6f a1 00 00 1a 00 00 00     &.......o.......
    a4f8:	54 a1 00 00 1b 00 00 00 c8 ab 00 00 1c 00 00 00     T...............
    a508:	e0 a3 00 00 1d 00 00 00 5d ae 00 00 1a 00 00 00     ........].......
    a518:	70 a8 00 00 1e 00 00 00 61 b2 00 00 1f 00 00 00     p.......a.......
    a528:	90 aa 00 00 20 00 00 00 f9 9b 00 00 21 00 00 00     .... .......!...
    a538:	53 ac 00 00 1e 00 00 00 f8 a0 00 00 22 00 00 00     S..........."...
    a548:	b9 ab 00 00 23 00 00 00 7a 9b 00 00 24 00 00 00     ....#...z...$...
    a558:	24 ae 00 00 24 00 00 00 59 b0 00 00 25 00 00 00     $...$...Y...%...
    a568:	9c ad 00 00 26 00 00 00 23 a3 00 00 27 00 00 00     ....&...#...'...
    a578:	74 ae 00 00 28 00 00 00 65 ab 00 00 26 00 00 00     t...(...e...&...
    a588:	07 b2 00 00 29 00 00 00 50 ab 00 00 2a 00 00 00     ....)...P...*...
    a598:	ae af 00 00 2b 00 00 00 30 a9 00 00 04 00 00 00     ....+...0.......
    a5a8:	02 b2 00 00 2c 00 00 00 38 ab 00 00 2d 00 00 00     ....,...8...-...
    a5b8:	52 9d 00 00 2e 00 00 00 01 a3 00 00 12 00 00 00     R...............
    a5c8:	7d a1 00 00 2f 00 00 00 6b ae 00 00 30 00 00 00     }.../...k...0...
    a5d8:	7e a8 00 00 31 00 00 00 b0 aa 00 00 32 00 00 00     ~...1.......2...
    a5e8:	78 a1 00 00 33 00 00 00 58 ae 00 00 34 00 00 00     x...3...X...4...
    a5f8:	00 a4 00 00 35 00 00 00 95 b0 00 00 36 00 00 00     ....5.......6...
    a608:	81 aa 00 00 37 00 00 00 ef 9b 00 00 38 00 00 00     ....7.......8...
    a618:	49 ac 00 00 39 00 00 00 42 a9 00 00 37 00 00 00     I...9...B...7...
    a628:	af ad 00 00 3a 00 00 00 6a a1 00 00 3b 00 00 00     ....:...j...;...
    a638:	18 ac 00 00 3c 00 00 00 60 a9 00 00 09 00 00 00     ....<...`.......
    a648:	48 9c 00 00 1c 00 00 00 1a a3 00 00 3b 00 00 00     H...........;...
    a658:	b4 ab 00 00 3d 00 00 00 39 a9 00 00 32 00 00 00     ....=...9...2...
    a668:	40 9d 00 00 3e 00 00 00 46 ab 00 00 3f 00 00 00     @...>...F...?...
    a678:	5c 9d 00 00 40 00 00 00 21 ad 00 00 22 00 00 00     \...@...!..."...
    a688:	fd b1 00 00 41 00 00 00 e0 b0 00 00 42 00 00 00     ....A.......B...
    a698:	4d 9d 00 00 43 00 00 00 fc ac 00 00 44 00 00 00     M...C.......D...
    a6a8:	87 a1 00 00 45 00 00 00 66 ae 00 00 46 00 00 00     ....E...f...F...
    a6b8:	79 a8 00 00 47 00 00 00 10 a3 00 00 48 00 00 00     y...G.......H...
    a6c8:	95 aa 00 00 49 00 00 00 59 a1 00 00 4a 00 00 00     ....I...Y...J...
    a6d8:	fb a3 00 00 13 00 00 00 8c b0 00 00 4b 00 00 00     ............K...
    a6e8:	7c aa 00 00 4c 00 00 00 7f 9b 00 00 4d 00 00 00     |...L.......M...
    a6f8:	44 ac 00 00 33 00 00 00 4f a1 00 00 4e 00 00 00     D...3...O...N...
    a708:	a6 ad 00 00 4f 00 00 00 41 a1 00 00 50 00 00 00     ....O...A...P...
    a718:	01 ae 00 00 51 00 00 00 d5 a3 00 00 52 00 00 00     ....Q.......R...
    a728:	0c ac 00 00 53 00 00 00 b9 ad 00 00 54 00 00 00     ....S.......T...
    a738:	94 ac 00 00 55 00 00 00 0b a9 00 00 2f 00 00 00     ....U......./...
    a748:	ec ad 00 00 56 00 00 00 56 a3 00 00 57 00 00 00     ....V...V...W...
    a758:	12 ab 00 00 58 00 00 00 5b a9 00 00 59 00 00 00     ....X...[...Y...
    a768:	82 a1 00 00 00 00 00 00 73 ab 00 00 0d 00 00 00     ........s.......
    a778:	f4 af 00 00 2e 00 00 00 4c a9 00 00 33 00 00 00     ........L...3...
    a788:	5c b2 00 00 5a 00 00 00 60 ab 00 00 5b 00 00 00     \...Z...`...[...
    a798:	65 a9 00 00 5c 00 00 00 2b ad 00 00 5d 00 00 00     e...\...+...]...
    a7a8:	68 b1 00 00 3f 00 00 00 dc ae 00 00 30 00 00 00     h...?.......0...
    a7b8:	86 aa 00 00 2b 00 00 00 1b ab 00 00 2c 00 00 00     ....+.......,...
    a7c8:	c0 a1 00 00 5e 00 00 00 84 ae 00 00 3a 00 00 00     ....^.......:...
    a7d8:	b4 a8 00 00 5f 00 00 00 e5 b0 00 00 11 00 00 00     ...._...........
    a7e8:	a6 aa 00 00 60 00 00 00 4d 9c 00 00 61 00 00 00     ....`...M...a...
    a7f8:	9e ac 00 00 62 00 00 00 38 a1 00 00 63 00 00 00     ....b...8...c...
    a808:	fc ad 00 00 64 00 00 00 30 9b 00 00 65 00 00 00     ....d...0...e...
    a818:	f3 a2 00 00 66 00 00 00 fd a0 00 00 67 00 00 00     ....f.......g...
    a828:	d4 ad 00 00 68 00 00 00 51 a3 00 00 69 00 00 00     ....h...Q...i...
    a838:	4c a3 00 00 6a 00 00 00 56 a9 00 00 6b 00 00 00     L...j...V...k...
    a848:	2d 94 00 00 6c 00 00 00 6e ab 00 00 6d 00 00 00     -...l...n...m...
    a858:	63 9e 00 00 0c 00 00 00 40 ad 00 00 6e 00 00 00     c.......@...n...
    a868:	4c b2 00 00 6f 00 00 00                             L...o...

0000a870 <tm34_guide>:
    a870:	01 00 01 25 00                                      ...%.

0000a875 <rm37_guide>:
    a875:	01 0e 09 00                                         ....

0000a879 <tm86_guide>:
    a879:	01 00 01 0e 00                                      .....

0000a87e <tm58_guide>:
    a87e:	01 00 01 1f 00 00                                   ......

0000a884 <layer1_tl_0x40>:
    a884:	00 00 00 00                                         ....

0000a888 <layer1_tl_0x41>:
    a888:	00 00 00 00                                         ....

0000a88c <layer1_tl_0x42>:
    a88c:	01 00 00 00 54 00 00 00                             ....T...

0000a894 <layer1_tl_0x43>:
    a894:	01 00 00 00 4e 00 00 00                             ....N...

0000a89c <layer1_tl_0x44>:
    a89c:	01 00 00 00 4f 00 00 00                             ....O...

0000a8a4 <layer1_tl_0x45>:
    a8a4:	01 00 00 00 63 00 00 00                             ....c...

0000a8ac <layer1_tl_0x46>:
    a8ac:	01 00 00 00 4d 00 00 00                             ....M...

0000a8b4 <tm122_guide>:
    a8b4:	01 00 01 43 00 00 00 00                             ...C....

0000a8bc <layer1_tl_0x48>:
    a8bc:	00 00 00 00                                         ....

0000a8c0 <layer1_tl_0x49>:
    a8c0:	00 00 00 00                                         ....

0000a8c4 <rm20_guide>:
    a8c4:	01 0e 2c 00                                         ..,.

0000a8c8 <layer1_tl_0x4A>:
    a8c8:	00 00 00 00                                         ....

0000a8cc <layer1_tl_0x4B>:
    a8cc:	00 00 00 00                                         ....

0000a8d0 <layer1_tl_0x4C>:
    a8d0:	01 00 00 00 60 00 00 00                             ....`...

0000a8d8 <layer1_tl_0x4D>:
    a8d8:	01 00 00 00 55 00 00 00                             ....U...

0000a8e0 <layer1_tl_0x4E>:
    a8e0:	01 00 00 00 5c 00 00 00                             ....\...

0000a8e8 <layer1_tl_0x4F>:
    a8e8:	01 00 00 00 5f 00 00 00                             ...._...

0000a8f0 <rm108_guide>:
    a8f0:	01 0e 44 00                                         ..D.

0000a8f4 <tm21_guide>:
    a8f4:	01 00 01 54 00                                      ...T.

0000a8f9 <rm50_guide>:
    a8f9:	01 0e e7 00                                         ....

0000a8fd <rm2_guide>:
    a8fd:	01 0e 18 00                                         ....

0000a901 <rm22_guide>:
    a901:	01 0e 12 00                                         ....

0000a905 <rm74_guide>:
    a905:	02 0e e1 0e 20 00                                   .... .

0000a90b <tm103_guide>:
    a90b:	01 00 01 46 00                                      ...F.

0000a910 <layer2_tl_0x0C>:
    a910:	01 00 00 00 74 00 00 00                             ....t...

0000a918 <layer2_tl_0x0D>:
    a918:	01 00 00 00 61 00 00 00                             ....a...

0000a920 <layer2_tl_0x0E>:
    a920:	01 00 00 00 6f 00 00 00                             ....o...

0000a928 <layer2_tl_0x0F>:
    a928:	01 00 00 00 71 00 00 00                             ....q...

0000a930 <tm51_guide>:
    a930:	01 00 01 23 00                                      ...#.

0000a935 <rm12_guide>:
    a935:	01 0e 51 00                                         ..Q.

0000a939 <tm75_guide>:
    a939:	01 00 01 59 00                                      ...Y.

0000a93e <rm9_guide>:
    a93e:	01 0e e3 00                                         ....

0000a942 <tm67_guide>:
    a942:	01 00 01 31 00                                      ...1.

0000a947 <tm19_guide>:
    a947:	01 00 01 2b 00                                      ...+.

0000a94c <tm111_guide>:
    a94c:	01 00 01 0e 00                                      .....

0000a951 <tm6_guide>:
    a951:	01 00 01 02 00                                      .....

0000a956 <tm135_guide>:
    a956:	01 00 01 4c 00                                      ...L.

0000a95b <tm107_guide>:
    a95b:	01 00 01 3a 00                                      ...:.

0000a960 <tm71_guide>:
    a960:	01 00 01 2c 00                                      ...,.

0000a965 <tm114_guide>:
    a965:	01 00 01 3c 00                                      ...<.

0000a96a <rm101_guide>:
    a96a:	01 0e 43 00 00 00                                   ..C...

0000a970 <layer2_tl_0x10>:
    a970:	00 00 00 00                                         ....

0000a974 <layer2_tl_0x11>:
    a974:	00 00 00 00                                         ....

0000a978 <layer2_tl_0x12>:
    a978:	00 00 00 00                                         ....

0000a97c <layer2_tl_0x13>:
    a97c:	00 00 00 00                                         ....

0000a980 <layer2_tl_0x14>:
    a980:	00 00 00 00                                         ....

0000a984 <layer2_tl_0x15>:
    a984:	01 00 00 00 6d 00 00 00                             ....m...

0000a98c <layer2_tl_0x16>:
    a98c:	01 00 00 00 66 00 00 00                             ....f...

0000a994 <layer2_tl_0x17>:
    a994:	01 00 00 00 6a 00 00 00                             ....j...

0000a99c <layer2_tl_0x18>:
    a99c:	01 00 00 00 6c 00 00 00                             ....l...

0000a9a4 <layer2_tl_0x19>:
    a9a4:	01 00 00 00 77 00 00 00                             ....w...

0000a9ac <rm35_guide>:
    a9ac:	01 0e 15 00                                         ....

0000a9b0 <keyHoldCLIDict_DescEntry>:
    a9b0:	53 65 6e 64 20 6b 65 79 2d 68 6f 6c 64 20 65 76     Send key-hold ev
    a9c0:	65 6e 74 73 20 74 6f 20 74 68 65 20 6d 61 63 72     ents to the macr
    a9d0:	6f 20 6d 6f 64 75 6c 65 2e 20 44 75 70 6c 69 63     o module. Duplic
    a9e0:	61 74 65 73 20 68 61 76 65 20 75 6e 64 65 66 69     ates have undefi
    a9f0:	6e 65 64 20 62 65 68 61 76 69 6f 75 72 2e 0d 0a     ned behaviour...
    aa00:	09 09 1b 5b 33 35 6d 53 31 30 1b 5b 30 6d 20 53     ...[35mS10.[0m S
    aa10:	63 61 6e 63 6f 64 65 20 30 78 30 41 00 00 00 00     cancode 0x0A....

0000aa20 <layer2_tl_0x1A>:
    aa20:	00 00 00 00                                         ....

0000aa24 <layer2_tl_0x1B>:
    aa24:	00 00 00 00                                         ....

0000aa28 <layer2_tl_0x1C>:
    aa28:	00 00 00 00                                         ....

0000aa2c <layer2_tl_0x1D>:
    aa2c:	00 00 00 00                                         ....

0000aa30 <layer2_tl_0x1E>:
    aa30:	00 00 00 00                                         ....

0000aa34 <layer2_tl_0x1F>:
    aa34:	01 00 00 00 75 00 00 00                             ....u...

0000aa3c <layerDebugCLIDict_DescEntry>:
    aa3c:	4c 61 79 65 72 20 64 65 62 75 67 20 6d 6f 64 65     Layer debug mode
    aa4c:	2e 20 53 68 6f 77 73 20 6c 61 79 65 72 20 73 74     . Shows layer st
    aa5c:	61 63 6b 20 61 6e 64 20 61 6e 79 20 63 68 61 6e     ack and any chan
    aa6c:	67 65 73 2e 00 00 00 00                             ges.....

0000aa74 <layer3_tl_0x20>:
    aa74:	01 00 00 00 8b 00 00 00                             ........

0000aa7c <tm92_guide>:
    aa7c:	01 00 01 4e 00                                      ...N.

0000aa81 <tm64_guide>:
    aa81:	01 00 01 04 00                                      .....

0000aa86 <tm118_guide>:
    aa86:	01 00 01 45 00                                      ...E.

0000aa8b <tm1_guide>:
    aa8b:	01 00 01 2f 00                                      .../.

0000aa90 <tm36_guide>:
    aa90:	01 00 01 3b 00                                      ...;.

0000aa95 <tm88_guide>:
    aa95:	01 00 01 0f 00                                      .....

0000aa9a <rm89_guide>:
    aa9a:	02 0e e1 0e 22 00                                   ....".

0000aaa0 <rm64_guide>:
    aaa0:	02 0e e1 0e 26 00                                   ....&.

0000aaa6 <tm124_guide>:
    aaa6:	01 00 01 17 00                                      .....

0000aaab <tm22_guide>:
    aaab:	01 00 01 3a 00                                      ...:.

0000aab0 <tm59_guide>:
    aab0:	01 00 01 48 00                                      ...H.

0000aab5 <tm13_guide>:
    aab5:	01 00 01 03 00                                      .....

0000aaba <rm91_guide>:
    aaba:	02 0e e1 0e 2e 00                                   ......

0000aac0 <rm109_guide>:
    aac0:	01 0e 3c 00                                         ..<.

0000aac4 <layer1_tl_0x2D>:
    aac4:	00 00 00 00                                         ....

0000aac8 <layer2_tl_0x20>:
    aac8:	00 00 00 00                                         ....

0000aacc <layer2_tl_0x21>:
    aacc:	00 00 00 00                                         ....

0000aad0 <layer2_tl_0x22>:
    aad0:	00 00 00 00                                         ....

0000aad4 <layer2_tl_0x23>:
    aad4:	00 00 00 00                                         ....

0000aad8 <macroProcCLIDict_DescEntry>:
    aad8:	50 61 75 73 65 2f 52 65 73 75 6d 65 20 6d 61 63     Pause/Resume mac
    aae8:	72 6f 20 70 72 6f 63 65 73 73 69 6e 67 2e 00 00     ro processing...

0000aaf8 <layer2_tl_0x25>:
    aaf8:	00 00 00 00                                         ....

0000aafc <layer2_tl_0x26>:
    aafc:	00 00 00 00                                         ....

0000ab00 <layer2_tl_0x27>:
    ab00:	00 00 00 00                                         ....

0000ab04 <layer2_tl_0x28>:
    ab04:	00 00 00 00                                         ....

0000ab08 <layer2_tl_0x29>:
    ab08:	00 00 00 00                                         ....

0000ab0c <rm76_guide>:
    ab0c:	02 0e e1 0e 30 00                                   ....0.

0000ab12 <tm106_guide>:
    ab12:	01 00 01 17 00                                      .....

0000ab17 <rm48_guide>:
    ab17:	01 0e 2e 00                                         ....

0000ab1b <tm119_guide>:
    ab1b:	01 00 01 19 00                                      .....

0000ab20 <layer2_tl_0x2A>:
    ab20:	00 00 00 00                                         ....

0000ab24 <layer2_tl_0x2B>:
    ab24:	00 00 00 00                                         ....

0000ab28 <layer2_tl_0x2C>:
    ab28:	00 00 00 00                                         ....

0000ab2c <layer2_tl_0x2D>:
    ab2c:	00 00 00 00                                         ....

0000ab30 <layer2_tl_0x2E>:
    ab30:	00 00 00 00                                         ....

0000ab34 <layer2_tl_0x2F>:
    ab34:	00 00 00 00                                         ....

0000ab38 <tm53_guide>:
    ab38:	01 00 01 4c 00                                      ...L.

0000ab3d <tm25_guide>:
    ab3d:	01 00 01 15 00                                      .....

0000ab42 <rm52_guide>:
    ab42:	01 0e e2 00                                         ....

0000ab46 <tm77_guide>:
    ab46:	01 00 01 46 00                                      ...F.

0000ab4b <rm38_guide>:
    ab4b:	01 06 02 00 00                                      .....

0000ab50 <tm49_guide>:
    ab50:	01 00 01 4f 00                                      ...O.

0000ab55 <rm78_guide>:
    ab55:	02 0e e1 0e 1f 00                                   ......

0000ab5b <tm10_guide>:
    ab5b:	01 00 01 44 00                                      ...D.

0000ab60 <tm113_guide>:
    ab60:	01 00 01 0f 00                                      .....

0000ab65 <tm47_guide>:
    ab65:	01 00 01 4b 00                                      ...K.

0000ab6a <rm11_guide>:
    ab6a:	01 0e 2b 00                                         ..+.

0000ab6e <tm137_guide>:
    ab6e:	01 00 01 1f 00                                      .....

0000ab73 <tm109_guide>:
    ab73:	01 00 01 15 00                                      .....

0000ab78 <rm103_guide>:
    ab78:	01 0e 3a 00                                         ..:.

0000ab7c <layer3_tl_0x15>:
    ab7c:	01 00 00 00 7e 00 00 00                             ....~...

0000ab84 <LayerIndex>:
    ab84:	04 8c ff 1f f8 9a 00 00 02 59 00 00 f4 8a ff 1f     .........Y......
    ab94:	0c 9b 00 00 0c 4f 00 00 64 8d ff 1f 14 9b 00 00     .....O..d.......
    aba4:	0c 46 00 00 e4 89 ff 1f 1c 9b 00 00 0c 4f 00 00     .F...........O..

0000abb4 <tm74_guide>:
    abb4:	01 00 01 19 00                                      .....

0000abb9 <tm40_guide>:
    abb9:	01 00 01 3c 00 00 00                                ...<...

0000abc0 <layer3_tl_0x18>:
    abc0:	01 00 00 00 7d 00 00 00                             ....}...

0000abc8 <tm31_guide>:
    abc8:	01 00 01 28 00                                      ...(.

0000abcd <tm12_guide>:
    abcd:	01 00 01 56 00                                      ...V.

0000abd2 <rm41_guide>:
    abd2:	01 0e 1c 00 00 00                                   ......

0000abd8 <layer2_tl_0x30>:
    abd8:	00 00 00 00                                         ....

0000abdc <layer2_tl_0x31>:
    abdc:	00 00 00 00                                         ....

0000abe0 <layer2_tl_0x32>:
    abe0:	00 00 00 00                                         ....

0000abe4 <layer2_tl_0x33>:
    abe4:	00 00 00 00                                         ....

0000abe8 <default_tl_0x2B>:
    abe8:	01 00 00 00 13 00 00 00                             ........

0000abf0 <layer2_tl_0x35>:
    abf0:	00 00 00 00                                         ....

0000abf4 <layer2_tl_0x36>:
    abf4:	00 00 00 00                                         ....

0000abf8 <layer2_tl_0x37>:
    abf8:	00 00 00 00                                         ....

0000abfc <layer2_tl_0x38>:
    abfc:	00 00 00 00                                         ....

0000ac00 <layer2_tl_0x39>:
    ac00:	01 00 00 00 73 00 00 00                             ....s...

0000ac08 <layer2_tl_0x24>:
    ac08:	00 00 00 00                                         ....

0000ac0c <tm100_guide>:
    ac0c:	01 00 01 20 00 00 00 00                             ... ....

0000ac14 <layer3_tl_0x1A>:
    ac14:	00 00 00 00                                         ....

0000ac18 <tm70_guide>:
    ac18:	01 00 01 4a 00                                      ...J.

0000ac1d <rm4_guide>:
    ac1d:	01 0e e1 00 00 00 00                                .......

0000ac24 <layer2_tl_0x3A>:
    ac24:	01 00 00 00 6b 00 00 00                             ....k...

0000ac2c <layer2_tl_0x3B>:
    ac2c:	01 00 00 00 70 00 00 00                             ....p...

0000ac34 <layer2_tl_0x3C>:
    ac34:	01 00 00 00 72 00 00 00                             ....r...

0000ac3c <layer2_tl_0x3D>:
    ac3c:	00 00 00 00                                         ....

0000ac40 <layer2_tl_0x3E>:
    ac40:	00 00 00 00                                         ....

0000ac44 <tm94_guide>:
    ac44:	01 00 01 0c 00                                      .....

0000ac49 <tm66_guide>:
    ac49:	01 00 01 1d 00                                      .....

0000ac4e <tm3_guide>:
    ac4e:	01 00 01 46 00                                      ...F.

0000ac53 <tm38_guide>:
    ac53:	01 00 01 52 00                                      ...R.

0000ac58 <capListCLIDict_DescEntry>:
    ac58:	50 72 69 6e 74 73 20 61 6e 20 69 6e 64 65 78 65     Prints an indexe
    ac68:	64 20 6c 69 73 74 20 6f 66 20 61 6c 6c 20 6e 6f     d list of all no
    ac78:	6e 20 55 53 42 20 6b 65 79 63 6f 64 65 20 63 61     n USB keycode ca
    ac88:	70 61 62 69 6c 69 74 69 65 73 2e 00                 pabilities..

0000ac94 <tm102_guide>:
    ac94:	01 00 01 16 00                                      .....

0000ac99 <rm59_guide>:
    ac99:	01 06 03 00 00                                      .....

0000ac9e <tm126_guide>:
    ac9e:	01 00 01 15 00 00                                   ......

0000aca4 <layer1_tl_0x39>:
    aca4:	01 00 00 00 5b 00 00 00                             ....[...

0000acac <tm9_guide>:
    acac:	01 00 01 1b 00                                      .....

0000acb1 <rm30_guide>:
    acb1:	01 03 01 00 00                                      .....

0000acb6 <rm82_guide>:
    acb6:	02 0e e1 0e 2f 00                                   ..../.

0000acbc <layer2_tl_0x40>:
    acbc:	00 00 00 00                                         ....

0000acc0 <layer2_tl_0x41>:
    acc0:	00 00 00 00                                         ....

0000acc4 <layer2_tl_0x42>:
    acc4:	01 00 00 00 6e 00 00 00                             ....n...

0000accc <layer2_tl_0x43>:
    accc:	01 00 00 00 68 00 00 00                             ....h...

0000acd4 <layer2_tl_0x44>:
    acd4:	01 00 00 00 69 00 00 00                             ....i...

0000acdc <layer2_tl_0x45>:
    acdc:	01 00 00 00 76 00 00 00                             ....v...

0000ace4 <layer2_tl_0x46>:
    ace4:	01 00 00 00 67 00 00 00                             ....g...

0000acec <rm8_guide>:
    acec:	02 06 04 00 01 00 00 00                             ........

0000acf4 <default_tl_0x1C>:
    acf4:	01 00 00 00 3d 00 00 00                             ....=...

0000acfc <tm83_guide>:
    acfc:	01 00 01 15 00 00 00 00                             ........

0000ad04 <default_tl_0x1D>:
    ad04:	01 00 00 00 42 00 00 00                             ....B...

0000ad0c <default_tl_0x1E>:
    ad0c:	01 00 00 00 2c 00 00 00                             ....,...

0000ad14 <default_tl_0x1F>:
    ad14:	01 00 00 00 3a 00 00 00                             ....:...

0000ad1c <tm27_guide>:
    ad1c:	01 00 01 50 00                                      ...P.

0000ad21 <tm79_guide>:
    ad21:	01 00 01 44 00                                      ...D.

0000ad26 <tm28_guide>:
    ad26:	01 00 01 42 00                                      ...B.

0000ad2b <tm115_guide>:
    ad2b:	01 00 01 39 00                                      ...9.

0000ad30 <rm100_guide>:
    ad30:	01 0e 4b 00                                         ..K.

0000ad34 <rm13_guide>:
    ad34:	01 0e 22 00                                         ..".

0000ad38 <layer3_tl_0x0C>:
    ad38:	01 00 00 00 85 00 00 00                             ........

0000ad40 <tm139_guide>:
    ad40:	01 00 01 20 00 00 00 00                             ... ....

0000ad48 <layer3_tl_0x0E>:
    ad48:	01 00 00 00 81 00 00 00                             ........

0000ad50 <layer3_tl_0x0F>:
    ad50:	01 00 00 00 82 00 00 00                             ........

0000ad58 <rm1_guide>:
    ad58:	02 06 06 00 01 00                                   ......

0000ad5e <rm105_guide>:
    ad5e:	01 0e 45 00 00 00                                   ..E...

0000ad64 <layer3_tl_0x24>:
    ad64:	00 00 00 00                                         ....

0000ad68 <rm3_guide>:
    ad68:	01 0e 16 00                                         ....

0000ad6c <rm96_guide>:
    ad6c:	01 0e 3f 00                                         ..?.

0000ad70 <rm71_guide>:
    ad70:	02 0e e1 0e 34 00                                   ....4.

0000ad76 <tm14_guide>:
    ad76:	01 00 01 2a 00                                      ...*.

0000ad7b <rm43_guide>:
    ad7b:	01 0e 26 00                                         ..&.

0000ad7f <rm15_guide>:
    ad7f:	01 0e 28 00                                         ..(.

0000ad83 <rm36_guide>:
    ad83:	01 0e 14 00                                         ....

0000ad87 <rm67_guide>:
    ad87:	01 0e 33 00                                         ..3.

0000ad8b <rm39_guide>:
    ad8b:	01 0e 05 00                                         ....

0000ad8f <rm104_guide>:
    ad8f:	01 0e 4e 00 00                                      ..N..

0000ad94 <layer2_tl_0x34>:
    ad94:	00 00 00 00                                         ....

0000ad98 <rm6_guide>:
    ad98:	01 0e 29 00                                         ..).

0000ad9c <tm44_guide>:
    ad9c:	01 00 01 1e 00                                      .....

0000ada1 <tm16_guide>:
    ada1:	01 00 01 17 00                                      .....

0000ada6 <tm96_guide>:
    ada6:	01 00 01 4c 00                                      ...L.

0000adab <rm63_guide>:
    adab:	01 0e 38 00                                         ..8.

0000adaf <tm68_guide>:
    adaf:	01 00 01 58 00                                      ...X.

0000adb4 <tm5_guide>:
    adb4:	01 00 01 43 00                                      ...C.

0000adb9 <tm101_guide>:
    adb9:	01 00 01 19 00 00 00                                .......

0000adc0 <layer3_tl_0x10>:
    adc0:	00 00 00 00                                         ....

0000adc4 <layer3_tl_0x11>:
    adc4:	00 00 00 00                                         ....

0000adc8 <layer3_tl_0x12>:
    adc8:	00 00 00 00                                         ....

0000adcc <layer3_tl_0x13>:
    adcc:	00 00 00 00                                         ....

0000add0 <layer3_tl_0x14>:
    add0:	00 00 00 00                                         ....

0000add4 <tm132_guide>:
    add4:	01 00 01 4e 00 00 00 00                             ...N....

0000addc <layer3_tl_0x16>:
    addc:	01 00 00 00 78 00 00 00                             ....x...

0000ade4 <layer3_tl_0x17>:
    ade4:	01 00 00 00 7c 00 00 00                             ....|...

0000adec <tm104_guide>:
    adec:	01 00 01 43 00 00 00 00                             ...C....

0000adf4 <layer3_tl_0x19>:
    adf4:	01 00 00 00 8c 00 00 00                             ........

0000adfc <tm128_guide>:
    adfc:	01 00 01 4d 00                                      ...M.

0000ae01 <tm98_guide>:
    ae01:	01 00 01 1f 00 00 00                                .......

0000ae08 <layer3_tl_0x1B>:
    ae08:	00 00 00 00                                         ....

0000ae0c <layer3_tl_0x1C>:
    ae0c:	00 00 00 00                                         ....

0000ae10 <layer3_tl_0x1D>:
    ae10:	00 00 00 00                                         ....

0000ae14 <layer3_tl_0x1E>:
    ae14:	00 00 00 00                                         ....

0000ae18 <layer3_tl_0x1F>:
    ae18:	01 00 00 00 89 00 00 00                             ........

0000ae20 <layer2_tl_0x3F>:
    ae20:	00 00 00 00                                         ....

0000ae24 <tm42_guide>:
    ae24:	01 00 01 10 00                                      .....

0000ae29 <rm60_guide>:
    ae29:	01 0e e4 00                                         ....

0000ae2d <rm24_guide>:
    ae2d:	01 0e 2a 00                                         ..*.

0000ae31 <rm32_guide>:
    ae31:	01 0e 06 00 00 00 00                                .......

0000ae38 <default_tl_0x28>:
    ae38:	01 00 00 00 1f 00 00 00                             ........

0000ae40 <rm84_guide>:
    ae40:	01 0e 36 00                                         ..6.

0000ae44 <rm56_guide>:
    ae44:	01 0e e6 00                                         ....

0000ae48 <rm28_guide>:
    ae48:	01 06 01 00 00 00 00 00                             ........

0000ae50 <layer3_tl_0x30>:
    ae50:	00 00 00 00                                         ....

0000ae54 <rm51_guide>:
    ae54:	01 0e 2d 00                                         ..-.

0000ae58 <tm61_guide>:
    ae58:	01 00 01 1c 00                                      .....

0000ae5d <tm33_guide>:
    ae5d:	01 00 01 51 00                                      ...Q.

0000ae62 <rm88_guide>:
    ae62:	01 0e 20 00                                         .. .

0000ae66 <tm85_guide>:
    ae66:	01 00 01 4d 00                                      ...M.

0000ae6b <tm57_guide>:
    ae6b:	01 00 01 08 00                                      .....

0000ae70 <rm86_guide>:
    ae70:	01 0e 24 00                                         ..$.

0000ae74 <tm46_guide>:
    ae74:	01 00 01 22 00 00 00 00                             ..."....

0000ae7c <default_tl_0x2F>:
    ae7c:	01 00 00 00 01 00 00 00                             ........

0000ae84 <tm121_guide>:
    ae84:	01 00 01 46 00 00 00 00                             ...F....

0000ae8c <layer3_tl_0x21>:
    ae8c:	01 00 00 00 83 00 00 00                             ........

0000ae94 <layer3_tl_0x22>:
    ae94:	00 00 00 00                                         ....

0000ae98 <layer3_tl_0x23>:
    ae98:	00 00 00 00                                         ....

0000ae9c <macroListCLIDict_DescEntry>:
    ae9c:	4c 69 73 74 20 74 68 65 20 64 65 66 69 6e 65 64     List the defined
    aeac:	20 74 72 69 67 67 65 72 20 61 6e 64 20 72 65 73      trigger and res
    aebc:	75 6c 74 20 6d 61 63 72 6f 73 2e 00                 ult macros..

0000aec8 <layer3_tl_0x25>:
    aec8:	00 00 00 00                                         ....

0000aecc <layer3_tl_0x26>:
    aecc:	00 00 00 00                                         ....

0000aed0 <layer3_tl_0x27>:
    aed0:	00 00 00 00                                         ....

0000aed4 <layer3_tl_0x28>:
    aed4:	00 00 00 00                                         ....

0000aed8 <layer3_tl_0x29>:
    aed8:	00 00 00 00                                         ....

0000aedc <tm117_guide>:
    aedc:	01 00 01 1f 00                                      .....

0000aee1 <rm111_guide>:
    aee1:	01 0e 3d 00                                         ..=.

0000aee5 <rm55_guide>:
    aee5:	01 04 03 00 00 00 00                                .......

0000aeec <layer3_tl_0x2A>:
    aeec:	00 00 00 00                                         ....

0000aef0 <layer3_tl_0x2B>:
    aef0:	00 00 00 00                                         ....

0000aef4 <layer3_tl_0x2C>:
    aef4:	00 00 00 00                                         ....

0000aef8 <layer3_tl_0x2D>:
    aef8:	00 00 00 00                                         ....

0000aefc <layer3_tl_0x2E>:
    aefc:	00 00 00 00                                         ....

0000af00 <layer3_tl_0x2F>:
    af00:	00 00 00 00                                         ....

0000af04 <rm107_guide>:
    af04:	01 0e 4a 00                                         ..J.

0000af08 <layer3_tl_0x31>:
    af08:	00 00 00 00                                         ....

0000af0c <layer3_tl_0x32>:
    af0c:	00 00 00 00                                         ....

0000af10 <layerStateCLIDict_DescEntry>:
    af10:	4d 6f 64 69 66 79 20 73 70 65 63 69 66 69 65 64     Modify specified
    af20:	20 69 6e 64 65 78 65 64 20 6c 61 79 65 72 20 73      indexed layer s
    af30:	74 61 74 65 20 3c 6c 61 79 65 72 3e 20 3c 73 74     tate <layer> <st
    af40:	61 74 65 20 62 79 74 65 3e 2e 0d 0a 09 09 1b 5b     ate byte>......[
    af50:	33 35 6d 4c 32 1b 5b 30 6d 20 49 6e 64 65 78 65     35mL2.[0m Indexe
    af60:	64 20 4c 61 79 65 72 20 30 78 30 32 0d 0a 09 09     d Layer 0x02....
    af70:	30 20 4f 66 66 2c 20 31 20 53 68 69 66 74 2c 20     0 Off, 1 Shift, 
    af80:	32 20 4c 61 74 63 68 2c 20 34 20 4c 6f 63 6b 20     2 Latch, 4 Lock 
    af90:	53 74 61 74 65 73 00 00                             States..

0000af98 <layer3_tl_0x33>:
    af98:	00 00 00 00                                         ....

0000af9c <rm73_guide>:
    af9c:	01 0e 34 00                                         ..4.

0000afa0 <rm45_guide>:
    afa0:	01 0e 10 00                                         ....

0000afa4 <rm17_guide>:
    afa4:	01 0e 52 00                                         ..R.

0000afa8 <rm69_guide>:
    afa8:	02 0e e1 0e 2d 00                                   ....-.

0000afae <tm50_guide>:
    afae:	01 00 01 33 00                                      ...3.

0000afb3 <rm0_guide>:
    afb3:	01 0e 1f 00 00                                      .....

0000afb8 <default_tl_0x02>:
    afb8:	01 00 00 00 06 00 00 00                             ........

0000afc0 <default_tl_0x03>:
    afc0:	01 00 00 00 0d 00 00 00                             ........

0000afc8 <default_tl_0x04>:
    afc8:	01 00 00 00 40 00 00 00                             ....@...

0000afd0 <default_tl_0x05>:
    afd0:	01 00 00 00 45 00 00 00                             ....E...

0000afd8 <default_tl_0x06>:
    afd8:	01 00 00 00 00 00 00 00                             ........

0000afe0 <default_tl_0x07>:
    afe0:	01 00 00 00 34 00 00 00                             ....4...

0000afe8 <default_tl_0x08>:
    afe8:	01 00 00 00 39 00 00 00                             ....9...

0000aff0 <default_tl_0x09>:
    aff0:	00 00 00 00                                         ....

0000aff4 <tm110_guide>:
    aff4:	01 00 01 42 00                                      ...B.

0000aff9 <layerListCLIDict_DescEntry>:
    aff9:	4c 69 73 74 20 61 76 61 69 6c 61 62 6c 65 20 6c     List available l
    b009:	61 79 65 72 73 2e 00                                ayers..

0000b010 <default_tl_0x0A>:
    b010:	00 00 00 00                                         ....

0000b014 <default_tl_0x0B>:
    b014:	01 00 00 00 23 00 00 00                             ....#...

0000b01c <default_tl_0x0C>:
    b01c:	01 00 00 00 30 00 00 00                             ....0...

0000b024 <default_tl_0x0D>:
    b024:	01 00 00 00 37 00 00 00                             ....7...

0000b02c <default_tl_0x0E>:
    b02c:	01 00 00 00 20 00 00 00                             .... ...

0000b034 <default_tl_0x0F>:
    b034:	01 00 00 00 25 00 00 00                             ....%...

0000b03c <layer3_tl_0x34>:
    b03c:	00 00 00 00                                         ....

0000b040 <layer3_tl_0x35>:
    b040:	00 00 00 00                                         ....

0000b044 <layer3_tl_0x36>:
    b044:	00 00 00 00                                         ....

0000b048 <layer3_tl_0x37>:
    b048:	00 00 00 00                                         ....

0000b04c <layer3_tl_0x38>:
    b04c:	00 00 00 00                                         ....

0000b050 <layer3_tl_0x39>:
    b050:	00 00 00 00                                         ....

0000b054 <tm8_guide>:
    b054:	01 00 01 29 00                                      ...).

0000b059 <tm43_guide>:
    b059:	01 00 01 39 00 00 00                                ...9...

0000b060 <layer3_tl_0x3A>:
    b060:	00 00 00 00                                         ....

0000b064 <layer3_tl_0x3B>:
    b064:	00 00 00 00                                         ....

0000b068 <layer3_tl_0x3C>:
    b068:	00 00 00 00                                         ....

0000b06c <layer3_tl_0x3D>:
    b06c:	00 00 00 00                                         ....

0000b070 <layer3_tl_0x3E>:
    b070:	00 00 00 00                                         ....

0000b074 <layer3_tl_0x3F>:
    b074:	00 00 00 00                                         ....

0000b078 <rm90_guide>:
    b078:	02 0e e1 0e 36 00                                   ....6.

0000b07e <rm62_guide>:
    b07e:	02 0e e1 0e 38 00                                   ....8.

0000b084 <rm34_guide>:
    b084:	01 0e 2f 00                                         ../.

0000b088 <rm58_guide>:
    b088:	01 0e 4f 00                                         ..O.

0000b08c <tm91_guide>:
    b08c:	01 00 01 39 00                                      ...9.

0000b091 <rm65_guide>:
    b091:	01 0e 37 00                                         ..7.

0000b095 <tm63_guide>:
    b095:	01 00 01 20 00 00 00                                ... ...

0000b09c <default_tl_0x10>:
    b09c:	01 00 00 00 2a 00 00 00                             ....*...

0000b0a4 <default_tl_0x11>:
    b0a4:	01 00 00 00 14 00 00 00                             ........

0000b0ac <default_tl_0x12>:
    b0ac:	00 00 00 00                                         ....

0000b0b0 <default_tl_0x13>:
    b0b0:	00 00 00 00                                         ....

0000b0b4 <default_tl_0x14>:
    b0b4:	00 00 00 00                                         ....

0000b0b8 <default_tl_0x15>:
    b0b8:	01 00 00 00 19 00 00 00                             ........

0000b0c0 <default_tl_0x16>:
    b0c0:	01 00 00 00 02 00 00 00                             ........

0000b0c8 <default_tl_0x17>:
    b0c8:	01 00 00 00 10 00 00 00                             ........

0000b0d0 <default_tl_0x18>:
    b0d0:	01 00 00 00 17 00 00 00                             ........

0000b0d8 <default_tl_0x19>:
    b0d8:	01 00 00 00 4a 00 00 00                             ....J...

0000b0e0 <tm81_guide>:
    b0e0:	01 00 01 3a 00                                      ...:.

0000b0e5 <tm123_guide>:
    b0e5:	01 00 01 44 00 00 00                                ...D...

0000b0ec <default_tl_0x1A>:
    b0ec:	01 00 00 00 04 00 00 00                             ........

0000b0f4 <default_tl_0x1B>:
    b0f4:	01 00 00 00 09 00 00 00                             ........

0000b0fc <layer3_tl_0x40>:
    b0fc:	00 00 00 00                                         ....

0000b100 <layer3_tl_0x41>:
    b100:	00 00 00 00                                         ....

0000b104 <layer3_tl_0x42>:
    b104:	01 00 00 00 7f 00 00 00                             ........

0000b10c <layer3_tl_0x43>:
    b10c:	01 00 00 00 7a 00 00 00                             ....z...

0000b114 <layer3_tl_0x44>:
    b114:	01 00 00 00 7b 00 00 00                             ....{...

0000b11c <layer3_tl_0x45>:
    b11c:	01 00 00 00 8a 00 00 00                             ........

0000b124 <layer3_tl_0x46>:
    b124:	01 00 00 00 79 00 00 00                             ....y...

0000b12c <layer3_tl_0x47>:
    b12c:	00 00 00 00                                         ....

0000b130 <layer3_tl_0x48>:
    b130:	00 00 00 00                                         ....

0000b134 <layer3_tl_0x49>:
    b134:	00 00 00 00                                         ....

0000b138 <rm95_guide>:
    b138:	01 0e 50 00                                         ..P.

0000b13c <layer3_tl_0x4A>:
    b13c:	00 00 00 00                                         ....

0000b140 <layer3_tl_0x4B>:
    b140:	00 00 00 00                                         ....

0000b144 <layer3_tl_0x4C>:
    b144:	01 00 00 00 87 00 00 00                             ........

0000b14c <layer3_tl_0x4D>:
    b14c:	01 00 00 00 80 00 00 00                             ........

0000b154 <layer3_tl_0x4E>:
    b154:	01 00 00 00 84 00 00 00                             ........

0000b15c <layer3_tl_0x4F>:
    b15c:	01 00 00 00 86 00 00 00                             ........

0000b164 <rm23_guide>:
    b164:	01 0e 0c 00                                         ....

0000b168 <tm116_guide>:
    b168:	01 00 01 0c 00                                      .....

0000b16d <rm75_guide>:
    b16d:	01 0e 31 00                                         ..1.

0000b171 <rm47_guide>:
    b171:	01 0e 27 00                                         ..'.

0000b175 <rm19_guide>:
    b175:	01 0e 35 00                                         ..5.

0000b179 <macroShowCLIDict_DescEntry>:
    b179:	53 68 6f 77 20 74 68 65 20 6d 61 63 72 6f 20 63     Show the macro c
    b189:	6f 72 72 65 73 70 6f 6e 64 69 6e 67 20 74 6f 20     orresponding to 
    b199:	74 68 65 20 67 69 76 65 6e 20 69 6e 64 65 78 2e     the given index.
    b1a9:	0d 0a 09 09 1b 5b 33 35 6d 54 31 36 1b 5b 30 6d     .....[35mT16.[0m
    b1b9:	20 49 6e 64 65 78 65 64 20 54 72 69 67 67 65 72      Indexed Trigger
    b1c9:	20 4d 61 63 72 6f 20 30 78 31 30 2c 20 1b 5b 33      Macro 0x10, .[3
    b1d9:	35 6d 52 31 32 1b 5b 30 6d 20 49 6e 64 65 78 65     5mR12.[0m Indexe
    b1e9:	64 20 52 65 73 75 6c 74 20 4d 61 63 72 6f 20 30     d Result Macro 0
    b1f9:	78 30 43 00                                         x0C.

0000b1fd <tm80_guide>:
    b1fd:	01 00 01 17 00                                      .....

0000b202 <tm52_guide>:
    b202:	01 00 01 07 00                                      .....

0000b207 <tm48_guide>:
    b207:	01 00 01 0c 00                                      .....

0000b20c <default_tl_0x20>:
    b20c:	01 00 00 00 3f 00 00 00                             ....?...

0000b214 <default_tl_0x21>:
    b214:	01 00 00 00 29 00 00 00                             ....)...

0000b21c <default_tl_0x22>:
    b21c:	01 00 00 00 2e 00 00 00                             ........

0000b224 <default_tl_0x23>:
    b224:	01 00 00 00 33 00 00 00                             ....3...

0000b22c <default_tl_0x24>:
    b22c:	01 00 00 00 1d 00 00 00                             ........

0000b234 <default_tl_0x25>:
    b234:	01 00 00 00 22 00 00 00                             ...."...

0000b23c <default_tl_0x26>:
    b23c:	01 00 00 00 0b 00 00 00                             ........

0000b244 <default_tl_0x27>:
    b244:	01 00 00 00 1a 00 00 00                             ........

0000b24c <tm140_guide>:
    b24c:	01 00 01 19 00 00 00 00                             ........

0000b254 <default_tl_0x29>:
    b254:	01 00 00 00 08 00 00 00                             ........

0000b25c <tm112_guide>:
    b25c:	01 00 01 3b 00                                      ...;.

0000b261 <tm35_guide>:
    b261:	01 00 01 0b 00                                      .....

0000b266 <rm10_guide>:
    b266:	01 0e 17 00 00 00                                   ......

0000b26c <default_tl_0x2A>:
    b26c:	01 00 00 00 0e 00 00 00                             ........

0000b274 <CSWTCH.65>:
    b274:	00 01 02 03 04 05 06 07 00 01 02 03 04 05 06 07     ................
    b284:	00 01 02 03 04 05 06 07 00 01 02 03 04 05 06 07     ................
    b294:	00 01 02 03 04 05 06 07 00 01 02 03 04 05 06 07     ................

0000b2a4 <kbdProtocolCLIDict_DescEntry>:
    b2a4:	4b 65 79 62 6f 61 72 64 20 50 72 6f 74 6f 63 6f     Keyboard Protoco
    b2b4:	6c 20 4d 6f 64 65 3a 20 30 20 2d 20 42 6f 6f 74     l Mode: 0 - Boot
    b2c4:	2c 20 31 20 2d 20 4f 53 2f 4e 4b 52 4f 20 4d 6f     , 1 - OS/NKRO Mo
    b2d4:	64 65 00                                            de.

0000b2d7 <setKeysCLIDict_DescEntry>:
    b2d7:	50 72 65 70 61 72 65 20 61 20 73 70 61 63 65 20     Prepare a space 
    b2e7:	73 65 70 61 72 61 74 65 64 20 6c 69 73 74 20 6f     separated list o
    b2f7:	66 20 55 53 42 20 63 6f 64 65 73 20 28 64 65 63     f USB codes (dec
    b307:	69 6d 61 6c 29 2e 20 57 61 69 74 73 20 75 6e 74     imal). Waits unt
    b317:	69 6c 20 1b 5b 33 35 6d 73 65 6e 64 4b 65 79 73     il .[35msendKeys
    b327:	1b 5b 30 6d 2e 00                                   .[0m..

0000b32d <outputCLIDictName>:
    b32d:	55 53 42 20 4d 6f 64 75 6c 65 20 43 6f 6d 6d 61     USB Module Comma
    b33d:	6e 64 73 00                                         nds.

0000b341 <CSWTCH.59>:
    b341:	00 00 00 00 00 00 00 01 01 01 01 01 01 01 01 02     ................
    b351:	02 02 02 02 02 02 02 03 03 03 03 03 03 03 03 04     ................
    b361:	04 04 04 04 04 04 04 05 05 05 05 05 05 05 05        ...............

0000b370 <CSWTCH.64>:
    b370:	15 15 15 15 15 15 15 15 16 16 16 16 16 16 16 16     ................
    b380:	17 17 17 17 17 17 17 17 18 18 18 18 18 18 18 18     ................
    b390:	19 19 19 19 19 19 19 19 1a 1a 1a 1a 1a 1a 1a 1a     ................

0000b3a0 <outputCLIDict>:
    b3a0:	10 b7 00 00 a4 b2 00 00 6d 5d 00 00 1c b7 00 00     ........m]......
    b3b0:	49 b7 00 00 f1 5d 00 00 28 b7 00 00 63 b7 00 00     I....]..(...c...
    b3c0:	95 5d 00 00 31 b7 00 00 f4 b3 00 00 49 5d 00 00     .]..1.......I]..
    b3d0:	3a b7 00 00 d7 b2 00 00 bd 5d 00 00 42 b7 00 00     :........]..B...
    b3e0:	2b b4 00 00 15 5e 00 00 00 00 00 00 00 00 00 00     +....^..........
    b3f0:	00 00 00 00                                         ....

0000b3f4 <sendKeysCLIDict_DescEntry>:
    b3f4:	53 65 6e 64 20 74 68 65 20 70 72 65 70 61 72 65     Send the prepare
    b404:	64 20 6c 69 73 74 20 6f 66 20 55 53 42 20 63 6f     d list of USB co
    b414:	64 65 73 20 61 6e 64 20 6d 6f 64 69 66 69 65 72     des and modifier
    b424:	20 62 79 74 65 2e 00                                 byte..

0000b42b <setModCLIDict_DescEntry>:
    b42b:	53 65 74 20 74 68 65 20 6d 6f 64 66 69 65 72 20     Set the modfier 
    b43b:	62 79 74 65 3a 0d 0a 09 09 31 20 4c 43 74 72 6c     byte:....1 LCtrl
    b44b:	2c 20 32 20 4c 53 68 66 74 2c 20 34 20 4c 41 6c     , 2 LShft, 4 LAl
    b45b:	74 2c 20 38 20 4c 47 55 49 2c 20 31 36 20 52 43     t, 8 LGUI, 16 RC
    b46b:	74 72 6c 2c 20 33 32 20 52 53 68 66 74 2c 20 36     trl, 32 RShft, 6
    b47b:	34 20 52 41 6c 74 2c 20 31 32 38 20 52 47 55 49     4 RAlt, 128 RGUI
    b48b:	00 1b 5b 31 3b 33 32 6d 49 4e 46 4f 1b 5b 30 6d     ..[1;32mINFO.[0m
    b49b:	20 2d 20 4b 65 79 62 6f 61 72 64 20 50 72 6f 74      - Keyboard Prot
    b4ab:	6f 63 6f 6c 3a 20 00 1b 5b 31 3b 33 32 6d 49 4e     ocol: ..[1;32mIN
    b4bb:	46 4f 1b 5b 30 6d 20 2d 20 4c 45 44 20 53 74 61     FO.[0m - LED Sta
    b4cb:	74 65 3a 20 00 4f 75 74 70 75 74 5f 63 6f 6e 73     te: .Output_cons
    b4db:	43 74 72 6c 53 65 6e 64 28 63 6f 6e 73 43 6f 64     CtrlSend(consCod
    b4eb:	65 29 00 1b 5b 31 3b 33 33 6d 57 41 52 4e 49 4e     e)..[1;33mWARNIN
    b4fb:	47 1b 5b 30 6d 20 2d 20 43 6f 6e 73 75 6d 65 72     G.[0m - Consumer
    b50b:	20 43 6f 6e 74 72 6f 6c 20 69 73 20 6e 6f 74 20      Control is not 
    b51b:	69 6d 70 6c 65 6d 65 6e 74 65 64 20 66 6f 72 20     implemented for 
    b52b:	42 6f 6f 74 20 4d 6f 64 65 0d 0a 00 4f 75 74 70     Boot Mode...Outp
    b53b:	75 74 5f 6e 6f 6e 65 53 65 6e 64 28 29 00 4f 75     ut_noneSend().Ou
    b54b:	74 70 75 74 5f 73 79 73 43 74 72 6c 53 65 6e 64     tput_sysCtrlSend
    b55b:	28 73 79 73 43 6f 64 65 29 00 1b 5b 31 3b 33 33     (sysCode)..[1;33
    b56b:	6d 57 41 52 4e 49 4e 47 1b 5b 30 6d 20 2d 20 53     mWARNING.[0m - S
    b57b:	79 73 74 65 6d 20 43 6f 6e 74 72 6f 6c 20 69 73     ystem Control is
    b58b:	20 6e 6f 74 20 69 6d 70 6c 65 6d 65 6e 74 65 64      not implemented
    b59b:	20 66 6f 72 20 42 6f 6f 74 20 4d 6f 64 65 0d 0a      for Boot Mode..
    b5ab:	00 4f 75 74 70 75 74 5f 66 6c 61 73 68 4d 6f 64     .Output_flashMod
    b5bb:	65 28 29 00 4f 75 74 70 75 74 5f 6b 62 64 50 72     e().Output_kbdPr
    b5cb:	6f 74 6f 63 6f 6c 42 6f 6f 74 28 29 00 4f 75 74     otocolBoot().Out
    b5db:	70 75 74 5f 6b 62 64 50 72 6f 74 6f 63 6f 6c 4e     put_kbdProtocolN
    b5eb:	4b 52 4f 28 29 00 4f 75 74 70 75 74 5f 75 73 62     KRO().Output_usb
    b5fb:	43 6f 64 65 53 65 6e 64 28 75 73 62 43 6f 64 65     CodeSend(usbCode
    b60b:	29 00 1b 5b 31 3b 33 33 6d 57 41 52 4e 49 4e 47     )..[1;33mWARNING
    b61b:	1b 5b 30 6d 20 2d 20 55 53 42 20 4b 65 79 20 6c     .[0m - USB Key l
    b62b:	69 6d 69 74 20 72 65 61 63 68 65 64 0d 0a 00 1b     imit reached....
    b63b:	5b 31 3b 33 33 6d 57 41 52 4e 49 4e 47 1b 5b 30     [1;33mWARNING.[0
    b64b:	6d 20 2d 20 55 53 42 20 43 6f 64 65 20 61 62 6f     m - USB Code abo
    b65b:	76 65 20 31 30 34 2f 30 78 36 38 20 69 6e 20 42     ve 104/0x68 in B
    b66b:	6f 6f 74 20 4d 6f 64 65 3a 20 00 1b 5b 31 3b 33     oot Mode: ..[1;3
    b67b:	33 6d 57 41 52 4e 49 4e 47 1b 5b 30 6d 20 2d 20     3mWARNING.[0m - 
    b68b:	55 53 42 20 43 6f 64 65 20 6e 6f 74 20 77 69 74     USB Code not wit
    b69b:	68 69 6e 20 34 2d 34 39 20 28 30 78 34 2d 30 78     hin 4-49 (0x4-0x
    b6ab:	33 31 29 2c 20 35 31 2d 31 35 35 20 28 30 78 33     31), 51-155 (0x3
    b6bb:	33 2d 30 78 39 42 29 2c 20 31 35 37 2d 31 36 34     3-0x9B), 157-164
    b6cb:	20 28 30 78 39 44 2d 30 78 41 34 29 2c 20 31 37      (0x9D-0xA4), 17
    b6db:	36 2d 32 32 31 20 28 30 78 42 30 2d 30 78 44 44     6-221 (0xB0-0xDD
    b6eb:	29 20 6f 72 20 32 32 34 2d 32 33 31 20 28 30 78     ) or 224-231 (0x
    b6fb:	45 30 2d 30 78 45 37 29 20 4e 4b 52 4f 20 4d 6f     E0-0xE7) NKRO Mo
    b70b:	64 65 3a 20 00 6b 62 64 50 72 6f 74 6f 63 6f 6c     de: .kbdProtocol
    b71b:	00 6f 75 74 70 75 74 44 65 62 75 67 00 72 65 61     .outputDebug.rea
    b72b:	64 4c 45 44 73 00 73 65 6e 64 4b 65 79 73 00 73     dLEDs.sendKeys.s
    b73b:	65 74 4b 65 79 73 00 73 65 74 4d 6f 64 00           etKeys.setMod.

0000b749 <outputDebugCLIDict_DescEntry>:
    b749:	54 6f 67 67 6c 65 20 4f 75 74 70 75 74 20 44 65     Toggle Output De
    b759:	62 75 67 20 6d 6f 64 65 2e 00                       bug mode..

0000b763 <readLEDsCLIDict_DescEntry>:
    b763:	52 65 61 64 20 4c 45 44 20 62 79 74 65 3a 0d 0a     Read LED byte:..
    b773:	09 09 31 20 4e 75 6d 4c 63 6b 2c 20 32 20 43 61     ..1 NumLck, 2 Ca
    b783:	70 73 4c 63 6b 2c 20 34 20 53 63 72 6c 4c 63 6b     psLck, 4 ScrlLck
    b793:	2c 20 31 36 20 4b 61 6e 61 2c 20 65 74 63 2e 00     , 16 Kana, etc..

0000b7a3 <CSWTCH.60>:
    b7a3:	01 02 03 04 05 06 07 00 01 02 03 04 05 06 07 00     ................
    b7b3:	01 02 03 04 05 06 07 00 01 02 03 04 05 06 07 00     ................
    b7c3:	01 02 03 04 05 06 07 00 01 02 03 04 05 06 07        ...............

0000b7d2 <CSWTCH.61>:
    b7d2:	06 06 06 06 06 06 06 06 07 07 07 07 07 07 07 07     ................
    b7e2:	08 08 08 08 08 08 08 08 09 09 09 09 09 09 09 09     ................
    b7f2:	0a 0a 0a 0a 0a 0a 0a 0a 0b 0b 0b 0b 0b 0b 0b 0b     ................
    b802:	0c 0c 0c 0c 0c 0c 0c 0c 0d 0d 0d 0d 0d 0d 0d 0d     ................
    b812:	0e 0e 0e 0e 0e 0e 0e 0e 0f 0f 0f 0f 0f 0f 0f 0f     ................
    b822:	10 10 10 10 10 10 10 10 11 11 11 11 11 11 11 11     ................
    b832:	12 12 12 12 12 12 12 12 13 13 13 13 13 13 13 13     ................

0000b842 <CSWTCH.62>:
    b842:	00 01 02 03 04 05 06 07 00 01 02 03 04 05 06 07     ................
    b852:	00 01 02 03 04 05 06 07 00 01 02 03 04 05 06 07     ................
    b862:	00 01 02 03 04 05 06 07 00 01 02 03 04 05 06 07     ................
    b872:	00 01 02 03 04 05 06 07 00 01 02 03 04 05 06 07     ................
    b882:	00 01 02 03 04 05 06 07 00 01 02 03 04 05 06 07     ................
    b892:	00 01 02 03 04 05 06 07 00 01 02 03 04 05 06 07     ................
    b8a2:	00 01 02 03 04 05 06 07 00 01 02 03 04 05 06 07     ................

0000b8b2 <CSWTCH.63>:
    b8b2:	00 01 02 03 04 05 06 07                             ........

0000b8ba <usb_endpoint_config_table>:
    b8ba:	15 15 15 19 15 15 15 15 00 00                       ..........

0000b8c4 <usb_descriptor_list>:
    b8c4:	00 01 00 00 46 91 ff 1f 12 00 00 00 00 02 00 00     ....F...........
    b8d4:	b4 8f ff 1f c8 00 00 00 00 06 00 00 f8 94 ff 1f     ................
    b8e4:	01 00 00 00 00 0a 00 00 f7 94 ff 1f 01 00 00 00     ................
    b8f4:	00 22 00 00 fe 91 ff 1f 3f 00 00 00 00 21 00 00     ."......?....!..
    b904:	c6 8f ff 1f 09 00 00 00 00 22 01 00 52 8e ff 1f     ........."..R...
    b914:	7d 00 00 00 00 21 01 00 df 8f ff 1f 09 00 00 00     }....!..........
    b924:	00 22 04 00 7c 90 ff 1f 76 00 00 00 00 21 04 00     ."..|...v....!..
    b934:	3a 90 ff 1f 09 00 00 00 00 22 05 00 cf 8e ff 1f     :........"......
    b944:	55 00 00 00 00 21 05 00 53 90 ff 1f 09 00 00 00     U....!..S.......
    b954:	00 22 06 00 f2 90 ff 1f 35 00 00 00 00 21 06 00     ."......5....!..
    b964:	6c 90 ff 1f 09 00 00 00 00 03 00 00 3e 92 ff 1f     l...........>...
    b974:	00 00 00 00 01 03 09 04 94 91 ff 1f 00 00 00 00     ................
    b984:	02 03 09 04 a6 91 ff 1f 00 00 00 00 03 03 09 04     ................
    b994:	42 92 ff 1f 00 00 00 00 04 03 09 04 28 91 ff 1f     B...........(...
    b9a4:	00 00 00 00 05 03 09 04 96 8f ff 1f 00 00 00 00     ................
    b9b4:	06 03 09 04 58 91 ff 1f 00 00 00 00 07 03 09 04     ....X...........
    b9c4:	24 8f ff 1f 00 00 00 00 08 03 09 04 70 8f ff 1f     $...........p...
    b9d4:	00 00 00 00 09 03 09 04 5c 8f ff 1f 00 00 00 00     ........\.......
    b9e4:	0a 03 09 04 7e 8f ff 1f 00 00 00 00 00 00 00 00     ....~...........
    b9f4:	00 00 00 00 00 00 00 00 1b 5b 31 3b 33 33 6d 57     .........[1;33mW
    ba04:	41 52 4e 49 4e 47 1b 5b 30 6d 20 2d 20 43 4c 45     ARNING.[0m - CLE
    ba14:	41 52 5f 46 45 41 54 55 52 45 20 2d 20 44 65 76     AR_FEATURE - Dev
    ba24:	69 63 65 2f 49 6e 74 65 72 66 61 63 65 0d 0a 00     ice/Interface...
    ba34:	1b 5b 31 3b 33 33 6d 57 41 52 4e 49 4e 47 1b 5b     .[1;33mWARNING.[
    ba44:	30 6d 20 2d 20 53 45 54 5f 46 45 41 54 55 52 45     0m - SET_FEATURE
    ba54:	20 2d 20 44 65 76 69 63 65 2f 49 6e 74 65 72 66      - Device/Interf
    ba64:	61 63 65 0d 0a 00 1b 5b 31 3b 33 33 6d 57 41 52     ace....[1;33mWAR
    ba74:	4e 49 4e 47 1b 5b 30 6d 20 2d 20 55 6e 6b 6e 6f     NING.[0m - Unkno
    ba84:	77 6e 20 69 6e 74 65 72 66 61 63 65 20 2d 20 00     wn interface - .
    ba94:	1b 5b 31 3b 35 3b 33 31 6d 45 52 52 4f 52 1b 5b     .[1;5;31mERROR.[
    baa4:	30 6d 20 2d 20 55 53 42 20 6e 6f 74 20 63 6f 6e     0m - USB not con
    bab4:	66 69 67 75 72 65 64 2e 2e 2e 0d 0a 00 1b 5b 31     figured.......[1
    bac4:	3b 33 33 6d 57 41 52 4e 49 4e 47 1b 5b 30 6d 20     ;33mWARNING.[0m 
    bad4:	2d 20 55 53 42 20 54 72 61 6e 73 6d 69 74 20 54     - USB Transmit T
    bae4:	69 6d 65 6f 75 74 2e 2e 2e 0d 0a 00 53 79 73 43     imeout......SysC
    baf4:	74 72 6c 5b 00 5d 20 0d 0a 00 43 6f 6e 73 43 74     trl[.] ...ConsCt
    bb04:	72 6c 5b 00 1b 5b 31 3b 33 35 6d 44 45 42 55 47     rl[..[1;35mDEBUG
    bb14:	1b 5b 30 6d 20 2d 20 42 6f 6f 74 20 55 53 42 3a     .[0m - Boot USB:
    bb24:	20 00 1b 5b 31 3b 33 35 6d 44 45 42 55 47 1b 5b      ..[1;35mDEBUG.[
    bb34:	30 6d 20 2d 20 4e 4b 52 4f 20 55 53 42 3a 20 00     0m - NKRO USB: .
    bb44:	00 00 00 00                                         ....

0000bb48 <helpCLIDict_DescEntry>:
    bb48:	59 6f 75 27 72 65 20 6c 6f 6f 6b 69 6e 67 20 61     You're looking a
    bb58:	74 20 69 74 20 3a 50 00                             t it :P.

0000bb60 <restartCLIDict_DescEntry>:
    bb60:	53 65 6e 64 73 20 61 20 73 6f 66 74 77 61 72 65     Sends a software
    bb70:	20 72 65 73 74 61 72 74 2c 20 73 68 6f 75 6c 64      restart, should
    bb80:	20 62 65 20 73 69 6d 69 6c 61 72 20 74 6f 20 70      be similar to p
    bb90:	6f 77 65 72 69 6e 67 20 6f 6e 20 74 68 65 20 64     owering on the d
    bba0:	65 76 69 63 65 2e 00                                evice..

0000bba7 <clearCLIDict_DescEntry>:
    bba7:	43 6c 65 61 72 20 74 68 65 20 73 63 72 65 65 6e     Clear the screen
    bbb7:	2e 00                                               ..

0000bbb9 <reloadCLIDict_DescEntry>:
    bbb9:	53 69 67 6e 61 6c 73 20 6d 69 63 72 6f 63 6f 6e     Signals microcon
    bbc9:	74 72 6f 6c 6c 65 72 20 74 6f 20 72 65 66 6c 61     troller to refla
    bbd9:	73 68 2f 72 65 6c 6f 61 64 2e 00                    sh/reload..

0000bbe4 <versionCLIDict_DescEntry>:
    bbe4:	56 65 72 73 69 6f 6e 20 69 6e 66 6f 72 6d 61 74     Version informat
    bbf4:	69 6f 6e 20 61 62 6f 75 74 20 74 68 69 73 20 66     ion about this f
    bc04:	69 72 6d 77 61 72 65 2e 00 1b 5b 32 4a 1b 5b 48     irmware...[2J.[H
    bc14:	0d 00 1b 63 00 0d 0a 1b 5b 31 3b 33 32 6d 00 1b     ...c....[1;32m..
    bc24:	5b 30 6d 0d 0a 00 20 1b 5b 33 35 6d 00 20 1b 5b     [0m... .[35m. .[
    bc34:	31 6d 52 65 76 69 73 69 6f 6e 3a 1b 5b 30 6d 20     1mRevision:.[0m 
    bc44:	20 20 20 20 20 35 65 30 32 61 34 62 35 32 66 36          5e02a4b52f6
    bc54:	63 65 34 33 39 39 66 35 64 39 39 61 31 66 61 34     ce4399f5d99a1fa4
    bc64:	63 66 63 66 36 36 63 62 32 38 31 31 30 0d 0a 00     cfcf66cb28110...
    bc74:	20 1b 5b 31 6d 42 72 61 6e 63 68 3a 1b 5b 30 6d      .[1mBranch:.[0m
    bc84:	20 20 20 20 20 20 20 20 6d 61 73 74 65 72 0d 0a             master..
    bc94:	00 20 1b 5b 31 6d 54 72 65 65 20 53 74 61 74 75     . .[1mTree Statu
    bca4:	73 3a 1b 5b 30 6d 20 20 20 44 69 72 74 79 0d 0a     s:.[0m   Dirty..
    bcb4:	09 4b 65 79 62 6f 61 72 64 73 2f 49 43 45 44 2d     .Keyboards/ICED-
    bcc4:	4c 2f 62 75 69 6c 64 76 61 72 73 2e 68 0d 0a 09     L/buildvars.h...
    bcd4:	4b 65 79 62 6f 61 72 64 73 2f 49 43 45 44 2d 4c     Keyboards/ICED-L
    bce4:	2f 67 65 6e 65 72 61 74 65 64 4b 65 79 6d 61 70     /generatedKeymap
    bcf4:	2e 68 0d 0a 09 4b 65 79 62 6f 61 72 64 73 2f 49     .h...Keyboards/I
    bd04:	43 45 44 2d 4c 2f 6b 6c 6c 5f 64 65 66 73 2e 68     CED-L/kll_defs.h
    bd14:	0d 0a 09 4b 65 79 62 6f 61 72 64 73 2f 49 43 45     ...Keyboards/ICE
    bd24:	44 2d 52 2f 62 75 69 6c 64 76 61 72 73 2e 68 0d     D-R/buildvars.h.
    bd34:	0a 09 4b 65 79 62 6f 61 72 64 73 2f 49 43 45 44     ..Keyboards/ICED
    bd44:	2d 52 2f 67 65 6e 65 72 61 74 65 64 4b 65 79 6d     -R/generatedKeym
    bd54:	61 70 2e 68 0d 0a 09 4b 65 79 62 6f 61 72 64 73     ap.h...Keyboards
    bd64:	2f 49 43 45 44 2d 52 2f 6b 6c 6c 5f 64 65 66 73     /ICED-R/kll_defs
    bd74:	2e 68 0d 0a 00 20 1b 5b 31 6d 52 65 70 6f 20 4f     .h... .[1mRepo O
    bd84:	72 69 67 69 6e 3a 1b 5b 30 6d 20 20 20 68 74 74     rigin:.[0m   htt
    bd94:	70 73 3a 2f 2f 67 69 74 68 75 62 2e 63 6f 6d 2f     ps://github.com/
    bda4:	6b 69 69 62 6f 68 64 2f 63 6f 6e 74 72 6f 6c 6c     kiibohd/controll
    bdb4:	65 72 2e 67 69 74 0d 0a 00 20 1b 5b 31 6d 43 6f     er.git... .[1mCo
    bdc4:	6d 6d 69 74 20 44 61 74 65 3a 1b 5b 30 6d 20 20     mmit Date:.[0m  
    bdd4:	20 32 30 31 36 2d 30 31 2d 32 32 20 31 36 3a 30      2016-01-22 16:0
    bde4:	34 3a 35 33 20 2d 30 36 30 30 0d 0a 00 20 1b 5b     4:53 -0600... .[
    bdf4:	31 6d 43 6f 6d 6d 69 74 20 41 75 74 68 6f 72 3a     1mCommit Author:
    be04:	1b 5b 30 6d 20 70 63 65 31 39 39 31 20 3c 70 5f     .[0m pce1991 <p_
    be14:	63 5f 65 79 65 40 79 61 68 6f 6f 2e 63 6f 6d 3e     c_eye@yahoo.com>
    be24:	0d 0a 00 20 1b 5b 31 6d 42 75 69 6c 64 20 44 61     ... .[1mBuild Da
    be34:	74 65 3a 1b 5b 30 6d 20 20 20 20 32 30 31 36 2d     te:.[0m    2016-
    be44:	30 31 2d 32 32 20 32 33 3a 32 32 3a 35 35 20 2d     01-22 23:22:55 -
    be54:	30 36 30 30 0d 0a 00 20 1b 5b 31 6d 42 75 69 6c     0600... .[1mBuil
    be64:	64 20 4f 53 3a 1b 5b 30 6d 20 20 20 20 20 20 4c     d OS:.[0m      L
    be74:	69 6e 75 78 2d 33 2e 31 33 2e 30 2d 37 34 2d 67     inux-3.13.0-74-g
    be84:	65 6e 65 72 69 63 0d 0a 00 20 1b 5b 31 6d 41 72     eneric... .[1mAr
    be94:	63 68 69 74 65 63 74 75 72 65 3a 1b 5b 30 6d 20     chitecture:.[0m 
    bea4:	20 61 72 6d 0d 0a 00 20 1b 5b 31 6d 43 68 69 70      arm... .[1mChip
    beb4:	3a 1b 5b 30 6d 20 20 20 20 20 20 20 20 20 20 6d     :.[0m          m
    bec4:	6b 32 30 64 78 32 35 36 76 6c 68 37 0d 0a 00 20     k20dx256vlh7... 
    bed4:	1b 5b 31 6d 43 50 55 3a 1b 5b 30 6d 20 20 20 20     .[1mCPU:.[0m    
    bee4:	20 20 20 20 20 20 20 63 6f 72 74 65 78 2d 6d 34            cortex-m4
    bef4:	0d 0a 00 20 1b 5b 31 6d 44 65 76 69 63 65 3a 1b     ... .[1mDevice:.
    bf04:	5b 30 6d 20 20 20 20 20 20 20 20 4b 65 79 62 6f     [0m        Keybo
    bf14:	61 72 64 0d 0a 00 20 1b 5b 31 6d 4d 6f 64 75 6c     ard... .[1mModul
    bf24:	65 73 3a 1b 5b 30 6d 20 20 20 20 20 20 20 53 63     es:.[0m       Sc
    bf34:	61 6e 28 4d 44 45 72 67 6f 31 29 20 4d 61 63 72     an(MDErgo1) Macr
    bf44:	6f 28 50 61 72 74 69 61 6c 4d 61 70 29 20 4f 75     o(PartialMap) Ou
    bf54:	74 70 75 74 28 70 6a 72 63 55 53 42 29 20 44 65     tput(pjrcUSB) De
    bf64:	62 75 67 28 66 75 6c 6c 29 0d 0a 00 20 1b 5b 31     bug(full)... .[1
    bf74:	6d 55 6e 69 71 75 65 20 49 64 3a 1b 5b 30 6d 20     mUnique Id:.[0m 
    bf84:	20 20 20 20 00 1b 5b 31 3b 33 32 6d 49 4e 46 4f         ..[1;32mINFO
    bf94:	1b 5b 30 6d 20 2d 20 48 65 78 20 64 65 62 75 67     .[0m - Hex debug
    bfa4:	20 6d 6f 64 65 20 64 69 73 61 62 6c 65 64 2e 2e      mode disabled..
    bfb4:	2e 0d 0a 00 1b 5b 31 3b 33 32 6d 49 4e 46 4f 1b     .....[1;32mINFO.
    bfc4:	5b 30 6d 20 2d 20 48 65 78 20 64 65 62 75 67 20     [0m - Hex debug 
    bfd4:	6d 6f 64 65 20 65 6e 61 62 6c 65 64 2e 2e 2e 0d     mode enabled....
    bfe4:	0a 00 1b 5b 00 31 3b 35 3b 33 31 00 45 52 52 4f     ...[.1;5;31.ERRO
    bff4:	52 00 22 00 22 20 69 73 20 6e 6f 74 20 61 20 76     R."." is not a v
    c004:	61 6c 69 64 20 63 6f 6d 6d 61 6e 64 2e 2e 2e 74     alid command...t
    c014:	79 70 65 20 1b 5b 33 35 6d 68 65 6c 70 1b 5b 30     ype .[35mhelp.[0
    c024:	6d 00 1b 5b 31 3b 35 3b 33 31 6d 45 52 52 4f 52     m..[1;5;31mERROR
    c034:	1b 5b 30 6d 20 2d 20 4d 61 78 20 6e 75 6d 62 65     .[0m - Max numbe
    c044:	72 20 6f 66 20 64 69 63 74 69 6f 6e 61 72 69 65     r of dictionarie
    c054:	73 20 64 65 66 69 6e 65 64 20 61 6c 72 65 61 64     s defined alread
    c064:	79 2e 2e 2e 0d 0a 00 1b 5b 32 4b 0d 00 1b 5b 31     y.......[2K...[1
    c074:	3b 33 34 6d 3a 1b 5b 30 6d 20 00 1b 5b 31 3b 35     ;34m:.[0m ..[1;5
    c084:	3b 33 31 6d 45 52 52 4f 52 1b 5b 30 6d 20 2d 20     ;31mERROR.[0m - 
    c094:	53 65 72 69 61 6c 20 6c 69 6e 65 20 62 75 66 66     Serial line buff
    c0a4:	65 72 20 69 73 20 66 75 6c 6c 2c 20 64 72 6f 70     er is full, drop
    c0b4:	70 69 6e 67 20 63 68 61 72 61 63 74 65 72 20 61     ping character a
    c0c4:	6e 64 20 72 65 73 65 74 74 69 6e 67 2e 2e 2e 0d     nd resetting....
    c0d4:	0a 00 1b 5b 73 0d 0a 00 1b 5b 32 4b 00 1b 5b 75     ...[s....[2K..[u
    c0e4:	00 08 20 08 00 63 6c 65 61 72 00 63 6c 69 44 65     .. ..clear.cliDe
    c0f4:	62 75 67 00 68 65 6c 70 00 6c 65 64 00 72 65 6c     bug.help.led.rel
    c104:	6f 61 64 00 72 65 73 65 74 00 72 65 73 74 61 72     oad.reset.restar
    c114:	74 00 76 65 72 73 69 6f 6e 00                       t.version.

0000c11e <resetCLIDict_DescEntry>:
    c11e:	52 65 73 65 74 73 20 74 68 65 20 74 65 72 6d 69     Resets the termi
    c12e:	6e 61 6c 20 62 61 63 6b 20 74 6f 20 69 6e 69 74     nal back to init
    c13e:	69 61 6c 20 73 65 74 74 69 6e 67 73 2e 00           ial settings..

0000c14c <basicCLIDict>:
    c14c:	e9 c0 00 00 a7 bb 00 00 59 70 00 00 ef c0 00 00     ........Yp......
    c15c:	5f c2 00 00 35 72 00 00 f8 c0 00 00 48 bb 00 00     _...5r......H...
    c16c:	95 70 00 00 fd c0 00 00 b8 c1 00 00 49 71 00 00     .p..........Iq..
    c17c:	01 c1 00 00 b9 bb 00 00 65 70 00 00 08 c1 00 00     ........ep......
    c18c:	1e c1 00 00 89 70 00 00 0e c1 00 00 60 bb 00 00     .....p......`...
    c19c:	5d 71 00 00 16 c1 00 00 e4 bb 00 00 61 71 00 00     ]q..........aq..
    c1ac:	00 00 00 00 00 00 00 00 00 00 00 00                 ............

0000c1b8 <ledCLIDict_DescEntry>:
    c1b8:	45 6e 61 62 6c 65 73 2f 44 69 73 61 62 6c 65 73     Enables/Disables
    c1c8:	20 69 6e 64 69 63 61 74 6f 72 20 4c 45 44 2e 20      indicator LED. 
    c1d8:	54 72 79 20 61 20 63 6f 75 70 6c 65 20 74 69 6d     Try a couple tim
    c1e8:	65 73 20 6a 75 73 74 20 69 6e 20 63 61 73 65 20     es just in case 
    c1f8:	74 68 65 20 4c 45 44 20 69 73 20 69 6e 20 61 6e     the LED is in an
    c208:	20 6f 64 64 20 73 74 61 74 65 2e 0d 0a 09 09 1b      odd state......
    c218:	5b 33 33 6d 57 61 72 6e 69 6e 67 1b 5b 30 6d 3a     [33mWarning.[0m:
    c228:	20 4d 61 79 20 61 64 76 65 72 73 65 6c 79 20 61      May adversely a
    c238:	66 66 65 63 74 20 73 6f 6d 65 20 6d 6f 64 75 6c     ffect some modul
    c248:	65 73 2e 2e 2e 00                                   es....

0000c24e <basicCLIDictName>:
    c24e:	47 65 6e 65 72 61 6c 20 43 6f 6d 6d 61 6e 64 73     General Commands
    c25e:	00                                                  .

0000c25f <cliDebugCLIDict_DescEntry>:
    c25f:	45 6e 61 62 6c 65 73 2f 44 69 73 61 62 6c 65 73     Enables/Disables
    c26f:	20 68 65 78 20 6f 75 74 70 75 74 20 6f 66 20 74      hex output of t
    c27f:	68 65 20 6d 6f 73 74 20 72 65 63 65 6e 74 20 63     he most recent c
    c28f:	6c 69 20 69 6e 70 75 74 2e 00 00 00 00              li input.....
